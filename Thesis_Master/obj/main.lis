 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 115
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 8-3-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the parent module of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; #include <stdlib.h>                   // Required for string conversions to floats/ints and vice versa.
 0000           ; #include <string.h>
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (1)
 0000           ; #define               RX_MODE                                         (2)
 0000           ; #define               TX_MODE                                         (3)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR                                           (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; #define               SERVO_START                                     (255)   // The start byte of a servo transmission.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (3)             // This is receive wait time in ms.
 0000           ; #define               POST_RX_WAIT                            (10)    // Wait time after a controller responds in ms.
 0000           ; #define               SERVO_FIND_TIME                         (24)    // The wait time after issuing clear config in ms.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (9)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; // Transmits a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; // Performs a non-blocking read operation on a data packet that has come from a controller.
 0000           ; int validResponse(void);
 0000           ; // Performs a data packet decode on a transmission from an external computer.
 0000           ; // This function also performs the desired operation when it is finished decoding.
 0000           ; void decodeTransmission(void);
 0000           ; // Performs a standard read or write command to a servo.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // Performs a write command to a servo value that is larger than one byte long.
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; // Sends out a request to clear all information and start over.
 0000           ; void clearConfig(void);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeChildren(void);
 0000           ; // A single initialization sweep.
 0000           ; int initSweep(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; // This is a wait that is approximately 1 ms long, used to wait before transmitting to children.
 0000           ; void txConfigWait(void);
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; int PREV_NUM_MODULES;         // Stores the previous number of modules that has been discovered.
 0000           ; int SUGGESTED_NUM_MODULES;    // Stores the module number that is suggested from the PC.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; int TIMEOUT;                          // This flag is set if there is a timeout.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 117
 0000           ;       // Initialize the number of modules.
 0000           ;       NUM_MODULES = 0;
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 118
 0009           ;       PREV_NUM_MODULES = 1;
 0009 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 000C 550101            mov [_PREV_NUM_MODULES+1],1
 000F 550000            mov [_PREV_NUM_MODULES],0
 0012                   .dbline 119
 0012           ;       SUGGESTED_NUM_MODULES = MAX_MODULES;
 0012 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0015 550109            mov [_SUGGESTED_NUM_MODULES+1],9
 0018 550000            mov [_SUGGESTED_NUM_MODULES],0
 001B                   .dbline 122
 001B           ;       
 001B           ;       // Activate GPIO ISR.
 001B           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 001B 43E020            or REG[0xe0],32
 001E                   .dbline 125
 001E           ;       
 001E           ;       // Turn on global interrupts for the transmission timeout timer.
 001E           ;       M8C_EnableGInt;
 001E 7101                      or  F, 01h
 0020           
 0020 8021              xjmp L3
 0022           L2:
 0022                   .dbline 128
 0022           ;       
 0022           ;       while(1)
 0022           ;       {
 0022                   .dbline 129
 0022           ;               if(!NUM_MODULES)
 0022 62D000            mov REG[0xd0],>_NUM_MODULES
 0025 3C0000            cmp [_NUM_MODULES],0
 0028 B00B              jnz L5
 002A 3C0100            cmp [_NUM_MODULES+1],0
 002D B006              jnz L5
 002F           X1:
 002F                   .dbline 130
 002F           ;               {
 002F                   .dbline 132
 002F           ;                       // Find some modules.
 002F           ;                       initializeChildren();
 002F 7C0CA5            xcall _initializeChildren
 0032                   .dbline 133
 0032           ;               }
 0032 800F              xjmp L6
 0034           L5:
 0034                   .dbline 134
 0034           ;               else if(COMP_SERIAL_bCmdCheck())
 0034 10                push X
 0035 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0038 62D000            mov REG[0xd0],>__r0
 003B 20                pop X
 003C 3900              cmp A,0
 003E A003              jz L7
 0040                   .dbline 135
 0040           ;               {
 0040                   .dbline 137
 0040           ;                       // If there's a computer command, read it.
 0040           ;                       decodeTransmission();
 0040 9331              xcall _decodeTransmission
 0042                   .dbline 138
 0042           ;               }
 0042           L7:
 0042           L6:
 0042                   .dbline 139
 0042           ;       }
 0042           L3:
 0042                   .dbline 127
 0042 8FDF              xjmp L2
 0044           X0:
 0044                   .dbline -2
 0044           L1:
 0044                   .dbline 0 ; func end
 0044 8FFF              jmp .
 0046                   .dbend
 0046                   .dbfunc e pingModule _pingModule fI
 0046           ;       response -> X+0
 0046           ;      module_id -> X-5
 0046           _pingModule::
 0046                   .dbline -1
 0046 10                push X
 0047 4F                mov X,SP
 0048 3802              add SP,2
 004A                   .dbline 143
 004A           ; }
 004A           ; 
 004A           ; int pingModule(int module_id)
 004A           ; {
 004A                   .dbline 144
 004A           ;       int response = 0;               // Initialize the response to a fail.
 004A 560100            mov [X+1],0
 004D 560000            mov [X+0],0
 0050                   .dbline 145
 0050           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0050 5000              mov A,0
 0052 08                push A
 0053 5003              mov A,3
 0055 08                push A
 0056 7C0BAB            xcall _configToggle
 0059 38FE              add SP,-2
 005B                   .dbline 146
 005B           ;       txConfigWait();                 // Wait 1 ms, in case this ping function is called in a loop.
 005B 7C0E49            xcall _txConfigWait
 005E                   .dbline 149
 005E           ;       
 005E           ;       // Transmit a hello.
 005E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 005E 10                push X
 005F 50FC              mov A,-4
 0061 7C0000            xcall _TRANSMIT_PutChar
 0064 20                pop X
 0065                   .dbline 150
 0065           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0065 10                push X
 0066 50FC              mov A,-4
 0068 7C0000            xcall _TRANSMIT_PutChar
 006B 20                pop X
 006C                   .dbline 151
 006C           ;       TRANSMIT_PutChar(MASTER_ID);
 006C 10                push X
 006D 5000              mov A,0
 006F 7C0000            xcall _TRANSMIT_PutChar
 0072 20                pop X
 0073                   .dbline 152
 0073           ;       TRANSMIT_PutChar(module_id);
 0073 62D000            mov REG[0xd0],>__r0
 0076 52FC              mov A,[X-4]
 0078 10                push X
 0079 7C0000            xcall _TRANSMIT_PutChar
 007C 20                pop X
 007D                   .dbline 153
 007D           ;       TRANSMIT_PutChar(PING);
 007D 10                push X
 007E 50CB              mov A,-53
 0080 7C0000            xcall _TRANSMIT_PutChar
 0083 20                pop X
 0084                   .dbline 154
 0084           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0084 10                push X
 0085 50FD              mov A,-3
 0087 7C0000            xcall _TRANSMIT_PutChar
 008A 20                pop X
 008B                   .dbline 155
 008B           ;       TRANSMIT_PutChar(END_TRANSMIT);
 008B 10                push X
 008C 50FD              mov A,-3
 008E 7C0000            xcall _TRANSMIT_PutChar
 0091 20                pop X
 0092           L10:
 0092                   .dbline 158
 0092           ;       
 0092           ;       // Wait for the transmission to finish.
 0092           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0092           L11:
 0092                   .dbline 158
 0092 10                push X
 0093 7C0000            xcall _TRANSMIT_bReadTxStatus
 0096 62D000            mov REG[0xd0],>__r0
 0099 20                pop X
 009A 5300              mov [__r0],A
 009C 470020            tst [__r0],32
 009F AFF2              jz L10
 00A1                   .dbline 161
 00A1           ;       
 00A1           ;       // Wait an additional amount of time to be sure.
 00A1           ;       xmitWait();
 00A1 7C0E2A            xcall _xmitWait
 00A4                   .dbline 164
 00A4           ; 
 00A4           ;       // If we get a valid response, check the extracted parameters for what we want.
 00A4           ;       if(validResponse())
 00A4 91C0              xcall _validResponse
 00A6 62D000            mov REG[0xd0],>__r0
 00A9 3C0000            cmp [__r0],0
 00AC B006              jnz X2
 00AE 3C0000            cmp [__r1],0
 00B1 A02D              jz L13
 00B3           X2:
 00B3                   .dbline 165
 00B3           ;       {
 00B3                   .dbline 166
 00B3           ;               if(COMMAND_TYPE == PING)
 00B3 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00B6 3C00CB            cmp [_COMMAND_TYPE],-53
 00B9 B025              jnz L15
 00BB                   .dbline 167
 00BB           ;               {
 00BB                   .dbline 169
 00BB           ;                       // If this is for me, check who it was from.
 00BB           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 00BB 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00BE 3C0000            cmp [_COMMAND_DESTINATION],0
 00C1 B01D              jnz L17
 00C3                   .dbline 170
 00C3           ;                       {
 00C3                   .dbline 171
 00C3           ;                               if(COMMAND_SOURCE == module_id)
 00C3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00C6 5100              mov A,[_COMMAND_SOURCE]
 00C8 62D000            mov REG[0xd0],>__r0
 00CB 5300              mov [__r1],A
 00CD 5000              mov A,0
 00CF 3BFB              cmp A,[X-5]
 00D1 B00D              jnz L19
 00D3 5100              mov A,[__r1]
 00D5 3BFC              cmp A,[X-4]
 00D7 B007              jnz L19
 00D9           X3:
 00D9                   .dbline 172
 00D9           ;                               {
 00D9                   .dbline 173
 00D9           ;                                       response = 1;
 00D9 560101            mov [X+1],1
 00DC 560000            mov [X+0],0
 00DF                   .dbline 174
 00DF           ;                               }
 00DF           L19:
 00DF                   .dbline 175
 00DF           ;                       }
 00DF           L17:
 00DF                   .dbline 176
 00DF           ;               }
 00DF           L15:
 00DF                   .dbline 177
 00DF           ;       }
 00DF           L13:
 00DF                   .dbline 179
 00DF           ;       
 00DF           ;       return response;
 00DF 62D000            mov REG[0xd0],>__r0
 00E2 5201              mov A,[X+1]
 00E4 5300              mov [__r1],A
 00E6 5200              mov A,[X+0]
 00E8 5300              mov [__r0],A
 00EA                   .dbline -2
 00EA           L9:
 00EA 38FE              add SP,-2
 00EC 20                pop X
 00ED                   .dbline 0 ; func end
 00ED 7F                ret
 00EE                   .dbsym l response 0 I
 00EE                   .dbsym l module_id -5 I
 00EE                   .dbend
 00EE                   .dbfunc e assignID _assignID fI
 00EE           ;        success -> X+0
 00EE           ;    assigned_ID -> X-5
 00EE           _assignID::
 00EE                   .dbline -1
 00EE 10                push X
 00EF 4F                mov X,SP
 00F0 3802              add SP,2
 00F2                   .dbline 183
 00F2           ; }
 00F2           ; 
 00F2           ; int assignID(int assigned_ID)
 00F2           ; {
 00F2                   .dbline 184
 00F2           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 00F2 560100            mov [X+1],0
 00F5 560000            mov [X+0],0
 00F8                   .dbline 185
 00F8           ;       configToggle(TX_MODE);  // Switch to TX mode.
 00F8 5000              mov A,0
 00FA 08                push A
 00FB 5003              mov A,3
 00FD 08                push A
 00FE 7C0BAB            xcall _configToggle
 0101 38FE              add SP,-2
 0103                   .dbline 186
 0103           ;       txConfigWait();                 // Wait 1 ms in case this function is called multiple times.
 0103 7C0E49            xcall _txConfigWait
 0106                   .dbline 189
 0106           ;       
 0106           ;       // Transmit the assignment.
 0106           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0106 10                push X
 0107 50FC              mov A,-4
 0109 7C0000            xcall _TRANSMIT_PutChar
 010C 20                pop X
 010D                   .dbline 190
 010D           ;       TRANSMIT_PutChar(START_TRANSMIT);
 010D 10                push X
 010E 50FC              mov A,-4
 0110 7C0000            xcall _TRANSMIT_PutChar
 0113 20                pop X
 0114                   .dbline 191
 0114           ;       TRANSMIT_PutChar(MASTER_ID);
 0114 10                push X
 0115 5000              mov A,0
 0117 7C0000            xcall _TRANSMIT_PutChar
 011A 20                pop X
 011B                   .dbline 192
 011B           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 011B 10                push X
 011C 50FB              mov A,-5
 011E 7C0000            xcall _TRANSMIT_PutChar
 0121 20                pop X
 0122                   .dbline 193
 0122           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0122 10                push X
 0123 50C9              mov A,-55
 0125 7C0000            xcall _TRANSMIT_PutChar
 0128 20                pop X
 0129                   .dbline 194
 0129           ;       TRANSMIT_PutChar(assigned_ID);
 0129 62D000            mov REG[0xd0],>__r0
 012C 52FC              mov A,[X-4]
 012E 10                push X
 012F 7C0000            xcall _TRANSMIT_PutChar
 0132 20                pop X
 0133                   .dbline 195
 0133           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0133 10                push X
 0134 50FD              mov A,-3
 0136 7C0000            xcall _TRANSMIT_PutChar
 0139 20                pop X
 013A                   .dbline 196
 013A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 013A 10                push X
 013B 50FD              mov A,-3
 013D 7C0000            xcall _TRANSMIT_PutChar
 0140 20                pop X
 0141           L22:
 0141                   .dbline 199
 0141           ;       
 0141           ;       // Wait for the transmission to finish.
 0141           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0141           L23:
 0141                   .dbline 199
 0141 10                push X
 0142 7C0000            xcall _TRANSMIT_bReadTxStatus
 0145 62D000            mov REG[0xd0],>__r0
 0148 20                pop X
 0149 5300              mov [__r0],A
 014B 470020            tst [__r0],32
 014E AFF2              jz L22
 0150                   .dbline 202
 0150           ;       
 0150           ;       // Wait an additional amount of time to make sure the xmit gets out.
 0150           ;       xmitWait();
 0150 7C0E2A            xcall _xmitWait
 0153                   .dbline 205
 0153           ;       
 0153           ;       // If we read a valid response, check the extracted parameters for what we want.
 0153           ;       if(validResponse())
 0153 9111              xcall _validResponse
 0155 62D000            mov REG[0xd0],>__r0
 0158 3C0000            cmp [__r0],0
 015B B006              jnz X4
 015D 3C0000            cmp [__r1],0
 0160 A02D              jz L25
 0162           X4:
 0162                   .dbline 206
 0162           ;       {
 0162                   .dbline 207
 0162           ;               if(COMMAND_TYPE == ID_ASSIGN_OK)
 0162 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0165 3C00CA            cmp [_COMMAND_TYPE],-54
 0168 B025              jnz L27
 016A                   .dbline 208
 016A           ;               {
 016A                   .dbline 210
 016A           ;                       // If this is for me, check who it was from.
 016A           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 016A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 016D 3C0000            cmp [_COMMAND_DESTINATION],0
 0170 B01D              jnz L29
 0172                   .dbline 211
 0172           ;                       {
 0172                   .dbline 212
 0172           ;                               if(COMMAND_SOURCE == assigned_ID)
 0172 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0175 5100              mov A,[_COMMAND_SOURCE]
 0177 62D000            mov REG[0xd0],>__r0
 017A 5300              mov [__r1],A
 017C 5000              mov A,0
 017E 3BFB              cmp A,[X-5]
 0180 B00D              jnz L31
 0182 5100              mov A,[__r1]
 0184 3BFC              cmp A,[X-4]
 0186 B007              jnz L31
 0188           X5:
 0188                   .dbline 213
 0188           ;                               {
 0188                   .dbline 214
 0188           ;                                       success = 1;
 0188 560101            mov [X+1],1
 018B 560000            mov [X+0],0
 018E                   .dbline 215
 018E           ;                               }
 018E           L31:
 018E                   .dbline 216
 018E           ;                       }
 018E           L29:
 018E                   .dbline 217
 018E           ;               }
 018E           L27:
 018E                   .dbline 218
 018E           ;       }
 018E           L25:
 018E                   .dbline 220
 018E           ;       
 018E           ;       return success;
 018E 62D000            mov REG[0xd0],>__r0
 0191 5201              mov A,[X+1]
 0193 5300              mov [__r1],A
 0195 5200              mov A,[X+0]
 0197 5300              mov [__r0],A
 0199                   .dbline -2
 0199           L21:
 0199 38FE              add SP,-2
 019B 20                pop X
 019C                   .dbline 0 ; func end
 019C 7F                ret
 019D                   .dbsym l success 0 I
 019D                   .dbsym l assigned_ID -5 I
 019D                   .dbend
 019D                   .dbfunc e clearConfig _clearConfig fV
 019D           _clearConfig::
 019D                   .dbline -1
 019D                   .dbline 224
 019D           ; }
 019D           ; 
 019D           ; void clearConfig(void)
 019D           ; {
 019D                   .dbline 225
 019D           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 019D 5000              mov A,0
 019F 08                push A
 01A0 5003              mov A,3
 01A2 08                push A
 01A3 7C0BAB            xcall _configToggle
 01A6 38FE              add SP,-2
 01A8                   .dbline 226
 01A8           ;       txConfigWait();                 // Wait 1 ms.
 01A8 7C0E49            xcall _txConfigWait
 01AB                   .dbline 229
 01AB           ;       
 01AB           ;       // Transmit a clear.
 01AB           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01AB 10                push X
 01AC 50FC              mov A,-4
 01AE 7C0000            xcall _TRANSMIT_PutChar
 01B1 20                pop X
 01B2                   .dbline 230
 01B2           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01B2 10                push X
 01B3 50FC              mov A,-4
 01B5 7C0000            xcall _TRANSMIT_PutChar
 01B8 20                pop X
 01B9                   .dbline 231
 01B9           ;       TRANSMIT_PutChar(MASTER_ID);
 01B9 10                push X
 01BA 5000              mov A,0
 01BC 7C0000            xcall _TRANSMIT_PutChar
 01BF 20                pop X
 01C0                   .dbline 232
 01C0           ;       TRANSMIT_PutChar(BROADCAST);
 01C0 10                push X
 01C1 50FE              mov A,-2
 01C3 7C0000            xcall _TRANSMIT_PutChar
 01C6 20                pop X
 01C7                   .dbline 233
 01C7           ;       TRANSMIT_PutChar(CLEAR);
 01C7 10                push X
 01C8 50CC              mov A,-52
 01CA 7C0000            xcall _TRANSMIT_PutChar
 01CD 20                pop X
 01CE                   .dbline 234
 01CE           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01CE 10                push X
 01CF 50FD              mov A,-3
 01D1 7C0000            xcall _TRANSMIT_PutChar
 01D4 20                pop X
 01D5                   .dbline 235
 01D5           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01D5 10                push X
 01D6 50FD              mov A,-3
 01D8 7C0000            xcall _TRANSMIT_PutChar
 01DB 20                pop X
 01DC           L34:
 01DC                   .dbline 238
 01DC           ;       
 01DC           ;       // Wait for the transmission to finish.
 01DC           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01DC           L35:
 01DC                   .dbline 238
 01DC 10                push X
 01DD 7C0000            xcall _TRANSMIT_bReadTxStatus
 01E0 62D000            mov REG[0xd0],>__r0
 01E3 20                pop X
 01E4 5300              mov [__r0],A
 01E6 470020            tst [__r0],32
 01E9 AFF2              jz L34
 01EB                   .dbline 241
 01EB           ;       
 01EB           ;       // Wait an additional amount of time to make sure that our xmit got out.
 01EB           ;       xmitWait();
 01EB 7C0E2A            xcall _xmitWait
 01EE                   .dbline 244
 01EE           ;       
 01EE           ;       // Wait for servo find time to allow the children to reset.
 01EE           ;       configToggle(RX_MODE);
 01EE 5000              mov A,0
 01F0 08                push A
 01F1 5002              mov A,2
 01F3 08                push A
 01F4 7C0BAB            xcall _configToggle
 01F7 38FE              add SP,-2
 01F9           L37:
 01F9                   .dbline 245
 01F9           ;       while(TIMEOUT < SERVO_FIND_TIME) { }
 01F9                   .dbline 245
 01F9           L38:
 01F9                   .dbline 245
 01F9 62D000            mov REG[0xd0],>_TIMEOUT
 01FC 5101              mov A,[_TIMEOUT+1]
 01FE 1118              sub A,24
 0200 5100              mov A,[_TIMEOUT]
 0202 3180              xor A,-128
 0204 1980              sbb A,(0 ^ 0x80)
 0206 CFF2              jc L37
 0208           X6:
 0208                   .dbline -2
 0208           L33:
 0208                   .dbline 0 ; func end
 0208 7F                ret
 0209                   .dbend
 0209                   .dbfunc e sayHello _sayHello fV
 0209           _sayHello::
 0209                   .dbline -1
 0209                   .dbline 250
 0209           ; }
 0209           ; 
 0209           ; // This function transmits a hello message.
 0209           ; void sayHello(void)
 0209           ; {
 0209                   .dbline 251
 0209           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0209 5000              mov A,0
 020B 08                push A
 020C 5003              mov A,3
 020E 08                push A
 020F 7C0BAB            xcall _configToggle
 0212 38FE              add SP,-2
 0214                   .dbline 252
 0214           ;       txConfigWait();                 // Wait 1 ms so that this function can be called in a loop.
 0214 7C0E49            xcall _txConfigWait
 0217                   .dbline 255
 0217           ;       
 0217           ;       // Transmit a hello.
 0217           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0217 10                push X
 0218 50FC              mov A,-4
 021A 7C0000            xcall _TRANSMIT_PutChar
 021D 20                pop X
 021E                   .dbline 256
 021E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 021E 10                push X
 021F 50FC              mov A,-4
 0221 7C0000            xcall _TRANSMIT_PutChar
 0224 20                pop X
 0225                   .dbline 257
 0225           ;       TRANSMIT_PutChar(MASTER_ID);
 0225 10                push X
 0226 5000              mov A,0
 0228 7C0000            xcall _TRANSMIT_PutChar
 022B 20                pop X
 022C                   .dbline 258
 022C           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 022C 10                push X
 022D 50FB              mov A,-5
 022F 7C0000            xcall _TRANSMIT_PutChar
 0232 20                pop X
 0233                   .dbline 259
 0233           ;       TRANSMIT_PutChar(HELLO_BYTE);
 0233 10                push X
 0234 50C8              mov A,-56
 0236 7C0000            xcall _TRANSMIT_PutChar
 0239 20                pop X
 023A                   .dbline 260
 023A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 023A 10                push X
 023B 50FD              mov A,-3
 023D 7C0000            xcall _TRANSMIT_PutChar
 0240 20                pop X
 0241                   .dbline 261
 0241           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0241 10                push X
 0242 50FD              mov A,-3
 0244 7C0000            xcall _TRANSMIT_PutChar
 0247 20                pop X
 0248           L41:
 0248                   .dbline 264
 0248           ;       
 0248           ;       // Wait for the transmission to finish.
 0248           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0248           L42:
 0248                   .dbline 264
 0248 10                push X
 0249 7C0000            xcall _TRANSMIT_bReadTxStatus
 024C 62D000            mov REG[0xd0],>__r0
 024F 20                pop X
 0250 5300              mov [__r0],A
 0252 470020            tst [__r0],32
 0255 AFF2              jz L41
 0257                   .dbline 267
 0257           ;       
 0257           ;       // Wait an additional amount of time to allow the xmit to get out.
 0257           ;       xmitWait();
 0257 7C0E2A            xcall _xmitWait
 025A                   .dbline 270
 025A           ;       
 025A           ;       // Listen for the response.
 025A           ;       configToggle(RX_MODE);
 025A 5000              mov A,0
 025C 08                push A
 025D 5002              mov A,2
 025F 08                push A
 0260 7C0BAB            xcall _configToggle
 0263 38FE              add SP,-2
 0265                   .dbline -2
 0265           L40:
 0265                   .dbline 0 ; func end
 0265 7F                ret
 0266                   .dbend
 0266                   .dbfunc e validResponse _validResponse fI
 0266           ; valid_transmit -> X+3
 0266           ;              i -> X+1
 0266           ;       tempByte -> X+0
 0266           _validResponse::
 0266                   .dbline -1
 0266 10                push X
 0267 4F                mov X,SP
 0268 3805              add SP,5
 026A                   .dbline 275
 026A           ; }
 026A           ; 
 026A           ; // This function returns whether or not a valid transmission has been received.
 026A           ; int validResponse(void)
 026A           ; {
 026A                   .dbline 276
 026A           ;       int valid_transmit = 0;
 026A 560400            mov [X+4],0
 026D 560300            mov [X+3],0
 0270                   .dbline 277
 0270           ;       int i = 0;
 0270 560200            mov [X+2],0
 0273 560100            mov [X+1],0
 0276                   .dbline 278
 0276           ;       char tempByte = 0;
 0276 560000            mov [X+0],0
 0279                   .dbline 280
 0279           ;       
 0279           ;       configToggle(RX_MODE);  // Listen for the response.
 0279 5000              mov A,0
 027B 08                push A
 027C 5002              mov A,2
 027E 08                push A
 027F 7C0BAB            xcall _configToggle
 0282 38FE              add SP,-2
 0284 80C2              xjmp L46
 0286           L45:
 0286                   .dbline 287
 0286           ;       
 0286           ;       // The following code looks very nasty. Basically, while we haven't hit the rx timeout,
 0286           ;       // it checks the buffer for a command with non-blocking read commands. When the next byte
 0286           ;       // is found, we enter another while loop to read for the next byte and so on. We do this
 0286           ;       // so that the parent doesn't get stuck in rx mode when a child doesn't respond.
 0286           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0286           ;       {
 0286                   .dbline 288
 0286           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0286 10                push X
 0287 7C0000            xcall _RECEIVE_cReadChar
 028A 62D000            mov REG[0xd0],>__r0
 028D 20                pop X
 028E 39FC              cmp A,-4
 0290 B0B6              jnz L48
 0292                   .dbline 289
 0292           ;               {
 0292 80A5              xjmp L51
 0294           L50:
 0294                   .dbline 291
 0294           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0294           ;                       {
 0294                   .dbline 292
 0294           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0294 10                push X
 0295 7C0000            xcall _RECEIVE_cReadChar
 0298 62D000            mov REG[0xd0],>__r0
 029B 20                pop X
 029C 39FC              cmp A,-4
 029E B099              jnz L53
 02A0                   .dbline 293
 02A0           ;                               {
 02A0 8088              xjmp L56
 02A2           L55:
 02A2                   .dbline 295
 02A2           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02A2           ;                                       {
 02A2                   .dbline 296
 02A2           ;                                               if(tempByte = RECEIVE_cReadChar())
 02A2 10                push X
 02A3 7C0000            xcall _RECEIVE_cReadChar
 02A6 20                pop X
 02A7 5400              mov [X+0],A
 02A9 3900              cmp A,0
 02AB A07D              jz L58
 02AD                   .dbline 297
 02AD           ;                                               {
 02AD                   .dbline 298
 02AD           ;                                                       COMMAND_SOURCE = tempByte;
 02AD 5200              mov A,[X+0]
 02AF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02B2 5300              mov [_COMMAND_SOURCE],A
 02B4 8065              xjmp L61
 02B6           L60:
 02B6                   .dbline 301
 02B6           ;                                                       
 02B6           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02B6           ;                                                       {
 02B6                   .dbline 302
 02B6           ;                                                               if(tempByte = RECEIVE_cReadChar())
 02B6 10                push X
 02B7 7C0000            xcall _RECEIVE_cReadChar
 02BA 62D000            mov REG[0xd0],>__r0
 02BD 20                pop X
 02BE 5400              mov [X+0],A
 02C0 3900              cmp A,0
 02C2 A057              jz L63
 02C4                   .dbline 303
 02C4           ;                                                               {
 02C4                   .dbline 304
 02C4           ;                                                                       if(tempByte >= HELLO_BYTE)
 02C4 3D00C8            cmp [X+0],-56
 02C7 C052              jc L65
 02C9           X7:
 02C9                   .dbline 305
 02C9           ;                                                                       {
 02C9                   .dbline 306
 02C9           ;                                                                               COMMAND_TYPE = tempByte;
 02C9 5200              mov A,[X+0]
 02CB 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02CE 5300              mov [_COMMAND_TYPE],A
 02D0 803A              xjmp L68
 02D2           L67:
 02D2                   .dbline 309
 02D2           ;                                                                               
 02D2           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 02D2           ;                                                                               {
 02D2                   .dbline 310
 02D2           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 02D2 10                push X
 02D3 7C0000            xcall _RECEIVE_cReadChar
 02D6 62D000            mov REG[0xd0],>__r0
 02D9 20                pop X
 02DA 5400              mov [X+0],A
 02DC 3900              cmp A,0
 02DE A02C              jz L70
 02E0                   .dbline 311
 02E0           ;                                                                                       {
 02E0                   .dbline 312
 02E0           ;                                                                                               if(tempByte != END_TRANSMIT)
 02E0 3D00FD            cmp [X+0],-3
 02E3 A018              jz L72
 02E5                   .dbline 313
 02E5           ;                                                                                               {
 02E5                   .dbline 314
 02E5           ;                                                                                                       PARAM[i] = tempByte;
 02E5 5202              mov A,[X+2]
 02E7 0100              add A,<_PARAM
 02E9 5300              mov [__r1],A
 02EB 5201              mov A,[X+1]
 02ED 0900              adc A,>_PARAM
 02EF 60D5              mov REG[0xd5],A
 02F1 5200              mov A,[X+0]
 02F3 3F00              mvi [__r1],A
 02F5                   .dbline 315
 02F5           ;                                                                                                       i++;
 02F5 7702              inc [X+2]
 02F7 0F0100            adc [X+1],0
 02FA                   .dbline 316
 02FA           ;                                                                                               }
 02FA 8010              xjmp L73
 02FC           L72:
 02FC                   .dbline 318
 02FC           ;                                                                                               else
 02FC           ;                                                                                               {
 02FC                   .dbline 319
 02FC           ;                                                                                                       valid_transmit = 1;
 02FC 560401            mov [X+4],1
 02FF 560300            mov [X+3],0
 0302                   .dbline 320
 0302           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0302 62D000            mov REG[0xd0],>_TIMEOUT
 0305 550103            mov [_TIMEOUT+1],3
 0308 550000            mov [_TIMEOUT],0
 030B                   .dbline 321
 030B           ;                                                                                               }
 030B           L73:
 030B                   .dbline 322
 030B           ;                                                                                       }
 030B           L70:
 030B                   .dbline 323
 030B           ;                                                                               }
 030B           L68:
 030B                   .dbline 308
 030B 62D000            mov REG[0xd0],>_TIMEOUT
 030E 5101              mov A,[_TIMEOUT+1]
 0310 1103              sub A,3
 0312 5100              mov A,[_TIMEOUT]
 0314 3180              xor A,-128
 0316 1980              sbb A,(0 ^ 0x80)
 0318 CFB9              jc L67
 031A           X8:
 031A                   .dbline 324
 031A           ;                                                                       }
 031A           L65:
 031A                   .dbline 325
 031A           ;                                                               }
 031A           L63:
 031A                   .dbline 326
 031A           ;                                                       }
 031A           L61:
 031A                   .dbline 300
 031A 62D000            mov REG[0xd0],>_TIMEOUT
 031D 5101              mov A,[_TIMEOUT+1]
 031F 1103              sub A,3
 0321 5100              mov A,[_TIMEOUT]
 0323 3180              xor A,-128
 0325 1980              sbb A,(0 ^ 0x80)
 0327 CF8E              jc L60
 0329           X9:
 0329                   .dbline 327
 0329           ;                                               }
 0329           L58:
 0329                   .dbline 328
 0329           ;                                       }
 0329           L56:
 0329                   .dbline 294
 0329 62D000            mov REG[0xd0],>_TIMEOUT
 032C 5101              mov A,[_TIMEOUT+1]
 032E 1103              sub A,3
 0330 5100              mov A,[_TIMEOUT]
 0332 3180              xor A,-128
 0334 1980              sbb A,(0 ^ 0x80)
 0336 CF6B              jc L55
 0338           X10:
 0338                   .dbline 329
 0338           ;                               }
 0338           L53:
 0338                   .dbline 330
 0338           ;                       }
 0338           L51:
 0338                   .dbline 290
 0338 62D000            mov REG[0xd0],>_TIMEOUT
 033B 5101              mov A,[_TIMEOUT+1]
 033D 1103              sub A,3
 033F 5100              mov A,[_TIMEOUT]
 0341 3180              xor A,-128
 0343 1980              sbb A,(0 ^ 0x80)
 0345 CF4E              jc L50
 0347           X11:
 0347                   .dbline 331
 0347           ;               }
 0347           L48:
 0347                   .dbline 332
 0347           ;       }
 0347           L46:
 0347                   .dbline 286
 0347 62D000            mov REG[0xd0],>_TIMEOUT
 034A 5101              mov A,[_TIMEOUT+1]
 034C 1103              sub A,3
 034E 5100              mov A,[_TIMEOUT]
 0350 3180              xor A,-128
 0352 1980              sbb A,(0 ^ 0x80)
 0354 CF31              jc L45
 0356           X12:
 0356                   .dbline 334
 0356           ;       
 0356           ;       RX_TIMEOUT_Stop();
 0356 10                push X
 0357 7C0000            xcall _RX_TIMEOUT_Stop
 035A 20                pop X
 035B                   .dbline 335
 035B           ;       TIMEOUT = 0;
 035B 62D000            mov REG[0xd0],>_TIMEOUT
 035E 550100            mov [_TIMEOUT+1],0
 0361 550000            mov [_TIMEOUT],0
 0364                   .dbline 337
 0364           ;       
 0364           ;       return valid_transmit;
 0364 62D000            mov REG[0xd0],>__r0
 0367 5204              mov A,[X+4]
 0369 5300              mov [__r1],A
 036B 5203              mov A,[X+3]
 036D 5300              mov [__r0],A
 036F                   .dbline -2
 036F           L44:
 036F 38FB              add SP,-5
 0371 20                pop X
 0372                   .dbline 0 ; func end
 0372 7F                ret
 0373                   .dbsym l valid_transmit 3 I
 0373                   .dbsym l i 1 I
 0373                   .dbsym l tempByte 0 c
 0373                   .dbend
 0373                   .dbfunc e decodeTransmission _decodeTransmission fV
 0373           ;          speed -> X+10
 0373           ;          angle -> X+8
 0373           ;       tempByte -> X+7
 0373           ;          total -> X+5
 0373           ;             ID -> X+4
 0373           ;   runningTotal -> X+2
 0373           ;          param -> X+0
 0373           _decodeTransmission::
 0373                   .dbline -1
 0373 10                push X
 0374 4F                mov X,SP
 0375 380C              add SP,12
 0377                   .dbline 342
 0377           ; }
 0377           ; 
 0377           ; // This function decodes the transmission and takes the correct action.
 0377           ; void decodeTransmission(void)
 0377           ; {
 0377                   .dbline 344
 0377           ;       char* param;
 0377           ;       char ID = 0;
 0377 560400            mov [X+4],0
 037A                   .dbline 348
 037A           ;       char tempByte;
 037A           ;       char angle[2];
 037A           ;       char speed[2];
 037A           ;       int total = 0;
 037A 560600            mov [X+6],0
 037D 560500            mov [X+5],0
 0380                   .dbline 349
 0380           ;       int runningTotal = 0;
 0380 560300            mov [X+3],0
 0383 560200            mov [X+2],0
 0386                   .dbline 351
 0386           ;       
 0386           ;       if(param = COMP_SERIAL_szGetParam())
 0386 10                push X
 0387 7C0000            xcall _COMP_SERIAL_szGetParam
 038A 62D000            mov REG[0xd0],>__r0
 038D 5300              mov [__r0],A
 038F 5A00              mov [__r1],X
 0391 20                pop X
 0392 5100              mov A,[__r1]
 0394 5401              mov [X+1],A
 0396 5100              mov A,[__r0]
 0398 5400              mov [X+0],A
 039A 3C0000            cmp [__r0],0
 039D B006              jnz X13
 039F 3C0000            cmp [__r1],0
 03A2 A689              jz L75
 03A4           X13:
 03A4                   .dbline 352
 03A4           ;       {
 03A4                   .dbline 353
 03A4           ;               if((param[0] == 'x') || (param[0] == 'X'))
 03A4 62D000            mov REG[0xd0],>__r0
 03A7 5201              mov A,[X+1]
 03A9 5300              mov [__r1],A
 03AB 5200              mov A,[X+0]
 03AD 60D4              mov REG[0xd4],A
 03AF 3E00              mvi A,[__r1]
 03B1 5300              mov [__r1],A
 03B3 550000            mov [__r0],0
 03B6 3C0000            cmp [__r0],0
 03B9 B005              jnz X14
 03BB 3978              cmp A,120
 03BD A00E              jz L79
 03BF           X14:
 03BF 62D000            mov REG[0xd0],>__r0
 03C2 3C0000            cmp [__r0],0
 03C5 B099              jnz L77
 03C7 3C0058            cmp [__r1],88
 03CA B094              jnz L77
 03CC           X15:
 03CC           L79:
 03CC                   .dbline 354
 03CC           ;               {
 03CC                   .dbline 356
 03CC           ;                       // Reset the arm.
 03CC           ;                       NUM_MODULES = 0;
 03CC 62D000            mov REG[0xd0],>_NUM_MODULES
 03CF 550100            mov [_NUM_MODULES+1],0
 03D2 550000            mov [_NUM_MODULES],0
 03D5                   .dbline 357
 03D5           ;                       if(param = COMP_SERIAL_szGetParam())
 03D5 10                push X
 03D6 7C0000            xcall _COMP_SERIAL_szGetParam
 03D9 62D000            mov REG[0xd0],>__r0
 03DC 5300              mov [__r0],A
 03DE 5A00              mov [__r1],X
 03E0 20                pop X
 03E1 5100              mov A,[__r1]
 03E3 5401              mov [X+1],A
 03E5 5100              mov A,[__r0]
 03E7 5400              mov [X+0],A
 03E9 3C0000            cmp [__r0],0
 03EC B006              jnz X16
 03EE 3C0000            cmp [__r1],0
 03F1 A059              jz L80
 03F3           X16:
 03F3                   .dbline 358
 03F3           ;                       {
 03F3                   .dbline 359
 03F3           ;                               if((param[0] >= '1') && (param[0] <= '9'))
 03F3 62D000            mov REG[0xd0],>__r0
 03F6 5201              mov A,[X+1]
 03F8 5300              mov [__r1],A
 03FA 5200              mov A,[X+0]
 03FC 60D4              mov REG[0xd4],A
 03FE 3E00              mvi A,[__r1]
 0400 5300              mov [__r1],A
 0402 550000            mov [__r0],0
 0405 1131              sub A,49
 0407 5000              mov A,0
 0409 3180              xor A,-128
 040B 1980              sbb A,(0 ^ 0x80)
 040D C61E              jc L78
 040F           X17:
 040F 62D000            mov REG[0xd0],>__r0
 0412 5039              mov A,57
 0414 1200              sub A,[__r1]
 0416 5100              mov A,[__r0]
 0418 3180              xor A,-128
 041A 5300              mov [__rX],A
 041C 5080              mov A,(0 ^ 0x80)
 041E 1A00              sbb A,[__rX]
 0420 C60B              jc L78
 0422           X18:
 0422                   .dbline 360
 0422           ;                               {
 0422                   .dbline 361
 0422           ;                                       PREV_NUM_MODULES = param[0] - 48;
 0422 62D000            mov REG[0xd0],>__r0
 0425 5201              mov A,[X+1]
 0427 5300              mov [__r1],A
 0429 5200              mov A,[X+0]
 042B 60D4              mov REG[0xd4],A
 042D 3E00              mvi A,[__r1]
 042F 1130              sub A,48
 0431 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0434 5301              mov [_PREV_NUM_MODULES+1],A
 0436 5000              mov A,0
 0438 1900              sbb A,0
 043A 5300              mov [_PREV_NUM_MODULES],A
 043C                   .dbline 362
 043C           ;                                       SUGGESTED_NUM_MODULES = PREV_NUM_MODULES;
 043C 5101              mov A,[_PREV_NUM_MODULES+1]
 043E 08                push A
 043F 5100              mov A,[_PREV_NUM_MODULES]
 0441 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0444 5300              mov [_SUGGESTED_NUM_MODULES],A
 0446 18                pop A
 0447 5301              mov [_SUGGESTED_NUM_MODULES+1],A
 0449                   .dbline 363
 0449           ;                               }
 0449                   .dbline 364
 0449           ;                       }
 0449 85E2              xjmp L78
 044B           L80:
 044B                   .dbline 366
 044B           ;                       else
 044B           ;                       {
 044B                   .dbline 367
 044B           ;                               PREV_NUM_MODULES = 1;
 044B 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 044E 550101            mov [_PREV_NUM_MODULES+1],1
 0451 550000            mov [_PREV_NUM_MODULES],0
 0454                   .dbline 368
 0454           ;                               SUGGESTED_NUM_MODULES = MAX_MODULES;
 0454 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0457 550109            mov [_SUGGESTED_NUM_MODULES+1],9
 045A 550000            mov [_SUGGESTED_NUM_MODULES],0
 045D                   .dbline 369
 045D           ;                       }
 045D                   .dbline 370
 045D           ;               }
 045D 85CE              xjmp L78
 045F           L77:
 045F                   .dbline 371
 045F           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 045F 62D000            mov REG[0xd0],>__r0
 0462 5201              mov A,[X+1]
 0464 5300              mov [__r1],A
 0466 5200              mov A,[X+0]
 0468 60D4              mov REG[0xd4],A
 046A 3E00              mvi A,[__r1]
 046C 5300              mov [__r1],A
 046E 550000            mov [__r0],0
 0471 3C0000            cmp [__r0],0
 0474 B005              jnz X19
 0476 396E              cmp A,110
 0478 A00E              jz L86
 047A           X19:
 047A 62D000            mov REG[0xd0],>__r0
 047D 3C0000            cmp [__r0],0
 0480 B035              jnz L84
 0482 3C004E            cmp [__r1],78
 0485 B030              jnz L84
 0487           X20:
 0487           L86:
 0487                   .dbline 372
 0487           ;               {
 0487                   .dbline 374
 0487           ;                       // Return the number of modules that we have found.
 0487           ;                       itoa(param,NUM_MODULES,10);
 0487 5000              mov A,0
 0489 08                push A
 048A 500A              mov A,10
 048C 08                push A
 048D 62D000            mov REG[0xd0],>_NUM_MODULES
 0490 5100              mov A,[_NUM_MODULES]
 0492 08                push A
 0493 5101              mov A,[_NUM_MODULES+1]
 0495 08                push A
 0496 5200              mov A,[X+0]
 0498 08                push A
 0499 5201              mov A,[X+1]
 049B 08                push A
 049C 7C0000            xcall _itoa
 049F 38FA              add SP,-6
 04A1                   .dbline 375
 04A1           ;                       COMP_SERIAL_PutString(param);
 04A1 10                push X
 04A2 5200              mov A,[X+0]
 04A4 08                push A
 04A5 5201              mov A,[X+1]
 04A7 5C                mov X,A
 04A8 18                pop A
 04A9 7C0000            xcall _COMP_SERIAL_PutString
 04AC 20                pop X
 04AD                   .dbline 376
 04AD           ;                       COMP_SERIAL_PutChar('\n');
 04AD 10                push X
 04AE 500A              mov A,10
 04B0 7C0000            xcall _COMP_SERIAL_PutChar
 04B3 20                pop X
 04B4                   .dbline 377
 04B4           ;               }
 04B4 8577              xjmp L85
 04B6           L84:
 04B6                   .dbline 378
 04B6           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04B6 62D000            mov REG[0xd0],>__r0
 04B9 5201              mov A,[X+1]
 04BB 5300              mov [__r1],A
 04BD 5200              mov A,[X+0]
 04BF 60D4              mov REG[0xd4],A
 04C1 3E00              mvi A,[__r1]
 04C3 5300              mov [__r1],A
 04C5 550000            mov [__r0],0
 04C8 3C0000            cmp [__r0],0
 04CB B005              jnz X21
 04CD 3977              cmp A,119
 04CF A00E              jz L89
 04D1           X21:
 04D1 62D000            mov REG[0xd0],>__r0
 04D4 3C0000            cmp [__r0],0
 04D7 B214              jnz L87
 04D9 3C0057            cmp [__r1],87
 04DC B20F              jnz L87
 04DE           X22:
 04DE           L89:
 04DE                   .dbline 379
 04DE           ;               {
 04DE                   .dbline 380
 04DE           ;                       if(param = COMP_SERIAL_szGetParam())
 04DE 10                push X
 04DF 7C0000            xcall _COMP_SERIAL_szGetParam
 04E2 62D000            mov REG[0xd0],>__r0
 04E5 5300              mov [__r0],A
 04E7 5A00              mov [__r1],X
 04E9 20                pop X
 04EA 5100              mov A,[__r1]
 04EC 5401              mov [X+1],A
 04EE 5100              mov A,[__r0]
 04F0 5400              mov [X+0],A
 04F2 3C0000            cmp [__r0],0
 04F5 B006              jnz X23
 04F7 3C0000            cmp [__r1],0
 04FA A531              jz L88
 04FC           X23:
 04FC                   .dbline 381
 04FC           ;                       {
 04FC                   .dbline 382
 04FC           ;                               ID = atoi(param);
 04FC 5200              mov A,[X+0]
 04FE 08                push A
 04FF 5201              mov A,[X+1]
 0501 08                push A
 0502 7C0000            xcall _atoi
 0505 38FE              add SP,-2
 0507 62D000            mov REG[0xd0],>__r0
 050A 5100              mov A,[__r1]
 050C 5404              mov [X+4],A
 050E                   .dbline 384
 050E           ;                               
 050E           ;                               if(param = COMP_SERIAL_szGetParam())
 050E 10                push X
 050F 7C0000            xcall _COMP_SERIAL_szGetParam
 0512 62D000            mov REG[0xd0],>__r0
 0515 5300              mov [__r0],A
 0517 5A00              mov [__r1],X
 0519 20                pop X
 051A 5100              mov A,[__r1]
 051C 5401              mov [X+1],A
 051E 5100              mov A,[__r0]
 0520 5400              mov [X+0],A
 0522 3C0000            cmp [__r0],0
 0525 B006              jnz X24
 0527 3C0000            cmp [__r1],0
 052A A501              jz L88
 052C           X24:
 052C                   .dbline 385
 052C           ;                               {
 052C                   .dbline 386
 052C           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 052C 62D000            mov REG[0xd0],>__r0
 052F 5201              mov A,[X+1]
 0531 5300              mov [__r1],A
 0533 5200              mov A,[X+0]
 0535 60D4              mov REG[0xd4],A
 0537 3E00              mvi A,[__r1]
 0539 5300              mov [__r1],A
 053B 550000            mov [__r0],0
 053E 3C0000            cmp [__r0],0
 0541 B005              jnz X25
 0543 3961              cmp A,97
 0545 A00E              jz L96
 0547           X25:
 0547 62D000            mov REG[0xd0],>__r0
 054A 3C0000            cmp [__r0],0
 054D B084              jnz L94
 054F 3C0041            cmp [__r1],65
 0552 B07F              jnz L94
 0554           X26:
 0554           L96:
 0554                   .dbline 387
 0554           ;                                       {
 0554                   .dbline 388
 0554           ;                                               if(param = COMP_SERIAL_szGetParam())
 0554 10                push X
 0555 7C0000            xcall _COMP_SERIAL_szGetParam
 0558 62D000            mov REG[0xd0],>__r0
 055B 5300              mov [__r0],A
 055D 5A00              mov [__r1],X
 055F 20                pop X
 0560 5100              mov A,[__r1]
 0562 5401              mov [X+1],A
 0564 5100              mov A,[__r0]
 0566 5400              mov [X+0],A
 0568 3C0000            cmp [__r0],0
 056B B006              jnz X27
 056D 3C0000            cmp [__r1],0
 0570 A4BB              jz L88
 0572           X27:
 0572                   .dbline 389
 0572           ;                                               {
 0572                   .dbline 391
 0572           ;                                                       // Write the desired angle to the servo.
 0572           ;                                                       total = atoi(param);
 0572 5200              mov A,[X+0]
 0574 08                push A
 0575 5201              mov A,[X+1]
 0577 08                push A
 0578 7C0000            xcall _atoi
 057B 38FE              add SP,-2
 057D 62D000            mov REG[0xd0],>__r0
 0580 5100              mov A,[__r1]
 0582 5406              mov [X+6],A
 0584 5100              mov A,[__r0]
 0586 5405              mov [X+5],A
 0588                   .dbline 392
 0588           ;                                                       angle[0] = total%256;
 0588 5001              mov A,1
 058A 08                push A
 058B 5000              mov A,0
 058D 08                push A
 058E 5205              mov A,[X+5]
 0590 08                push A
 0591 5206              mov A,[X+6]
 0593 08                push A
 0594 7C0000            xcall __divmod_16X16_16
 0597 38FE              add SP,-2
 0599 18                pop A
 059A 5300              mov [__r1],A
 059C 18                pop A
 059D 5100              mov A,[__r1]
 059F 5408              mov [X+8],A
 05A1                   .dbline 393
 05A1           ;                                                       angle[1] = total/256;
 05A1 5001              mov A,1
 05A3 08                push A
 05A4 5000              mov A,0
 05A6 08                push A
 05A7 5205              mov A,[X+5]
 05A9 08                push A
 05AA 5206              mov A,[X+6]
 05AC 08                push A
 05AD 7C0000            xcall __divmod_16X16_16
 05B0 18                pop A
 05B1 5300              mov [__r1],A
 05B3 18                pop A
 05B4 38FE              add SP,-2
 05B6 5100              mov A,[__r1]
 05B8 5409              mov [X+9],A
 05BA                   .dbline 394
 05BA           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05BA 5209              mov A,[X+9]
 05BC 08                push A
 05BD 5208              mov A,[X+8]
 05BF 08                push A
 05C0 501E              mov A,30
 05C2 08                push A
 05C3 5003              mov A,3
 05C5 08                push A
 05C6 5005              mov A,5
 05C8 08                push A
 05C9 5204              mov A,[X+4]
 05CB 08                push A
 05CC 952C              xcall _longServoInstruction
 05CE 38FA              add SP,-6
 05D0                   .dbline 395
 05D0           ;                                               }
 05D0                   .dbline 396
 05D0           ;                                       }
 05D0 845B              xjmp L88
 05D2           L94:
 05D2                   .dbline 397
 05D2           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 05D2 62D000            mov REG[0xd0],>__r0
 05D5 5201              mov A,[X+1]
 05D7 5300              mov [__r1],A
 05D9 5200              mov A,[X+0]
 05DB 60D4              mov REG[0xd4],A
 05DD 3E00              mvi A,[__r1]
 05DF 5300              mov [__r1],A
 05E1 550000            mov [__r0],0
 05E4 3C0000            cmp [__r0],0
 05E7 B005              jnz X28
 05E9 3970              cmp A,112
 05EB A00E              jz L103
 05ED           X28:
 05ED 62D000            mov REG[0xd0],>__r0
 05F0 3C0000            cmp [__r0],0
 05F3 B045              jnz L101
 05F5 3C0050            cmp [__r1],80
 05F8 B040              jnz L101
 05FA           X29:
 05FA           L103:
 05FA                   .dbline 398
 05FA           ;                                       {
 05FA                   .dbline 399
 05FA           ;                                               if(param = COMP_SERIAL_szGetParam())
 05FA 10                push X
 05FB 7C0000            xcall _COMP_SERIAL_szGetParam
 05FE 62D000            mov REG[0xd0],>__r0
 0601 5300              mov [__r0],A
 0603 5A00              mov [__r1],X
 0605 20                pop X
 0606 5100              mov A,[__r1]
 0608 5401              mov [X+1],A
 060A 5100              mov A,[__r0]
 060C 5400              mov [X+0],A
 060E 3C0000            cmp [__r0],0
 0611 B006              jnz X30
 0613 3C0000            cmp [__r1],0
 0616 A415              jz L88
 0618           X30:
 0618                   .dbline 400
 0618           ;                                               {
 0618                   .dbline 402
 0618           ;                                                       // Write the desired power value to the servo.
 0618           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0618 5200              mov A,[X+0]
 061A 08                push A
 061B 5201              mov A,[X+1]
 061D 08                push A
 061E 7C0000            xcall _atoi
 0621 62D000            mov REG[0xd0],>__r0
 0624 5100              mov A,[__r1]
 0626 08                push A
 0627 5018              mov A,24
 0629 08                push A
 062A 5003              mov A,3
 062C 08                push A
 062D 5004              mov A,4
 062F 08                push A
 0630 5204              mov A,[X+4]
 0632 08                push A
 0633 9422              xcall _servoInstruction
 0635 38F9              add SP,-7
 0637                   .dbline 403
 0637           ;                                               }
 0637                   .dbline 404
 0637           ;                                       }
 0637 83F4              xjmp L88
 0639           L101:
 0639                   .dbline 405
 0639           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 0639 62D000            mov REG[0xd0],>__r0
 063C 5201              mov A,[X+1]
 063E 5300              mov [__r1],A
 0640 5200              mov A,[X+0]
 0642 60D4              mov REG[0xd4],A
 0644 3E00              mvi A,[__r1]
 0646 5300              mov [__r1],A
 0648 550000            mov [__r0],0
 064B 3C0000            cmp [__r0],0
 064E B005              jnz X31
 0650 3973              cmp A,115
 0652 A00E              jz L108
 0654           X31:
 0654 62D000            mov REG[0xd0],>__r0
 0657 3C0000            cmp [__r0],0
 065A B3D1              jnz L88
 065C 3C0053            cmp [__r1],83
 065F B3CC              jnz L88
 0661           X32:
 0661           L108:
 0661                   .dbline 406
 0661           ;                                       {
 0661                   .dbline 407
 0661           ;                                               if(param = COMP_SERIAL_szGetParam())
 0661 10                push X
 0662 7C0000            xcall _COMP_SERIAL_szGetParam
 0665 62D000            mov REG[0xd0],>__r0
 0668 5300              mov [__r0],A
 066A 5A00              mov [__r1],X
 066C 20                pop X
 066D 5100              mov A,[__r1]
 066F 5401              mov [X+1],A
 0671 5100              mov A,[__r0]
 0673 5400              mov [X+0],A
 0675 3C0000            cmp [__r0],0
 0678 B006              jnz X33
 067A 3C0000            cmp [__r1],0
 067D A3AE              jz L88
 067F           X33:
 067F                   .dbline 408
 067F           ;                                               {
 067F                   .dbline 409
 067F           ;                                                       total = atoi(param);
 067F 5200              mov A,[X+0]
 0681 08                push A
 0682 5201              mov A,[X+1]
 0684 08                push A
 0685 7C0000            xcall _atoi
 0688 38FE              add SP,-2
 068A 62D000            mov REG[0xd0],>__r0
 068D 5100              mov A,[__r1]
 068F 5406              mov [X+6],A
 0691 5100              mov A,[__r0]
 0693 5405              mov [X+5],A
 0695                   .dbline 412
 0695           ;                                                       
 0695           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 0695           ;                                                       if(total)
 0695 3D0500            cmp [X+5],0
 0698 B006              jnz X34
 069A 3D0600            cmp [X+6],0
 069D A38E              jz L88
 069F           X34:
 069F                   .dbline 413
 069F           ;                                                       {
 069F                   .dbline 414
 069F           ;                                                               speed[0] = total%256;
 069F 62D000            mov REG[0xd0],>__r0
 06A2 5001              mov A,1
 06A4 08                push A
 06A5 5000              mov A,0
 06A7 08                push A
 06A8 5205              mov A,[X+5]
 06AA 08                push A
 06AB 5206              mov A,[X+6]
 06AD 08                push A
 06AE 7C0000            xcall __divmod_16X16_16
 06B1 38FE              add SP,-2
 06B3 18                pop A
 06B4 5300              mov [__r1],A
 06B6 18                pop A
 06B7 5100              mov A,[__r1]
 06B9 540A              mov [X+10],A
 06BB                   .dbline 415
 06BB           ;                                                               speed[1] = total/256;
 06BB 5001              mov A,1
 06BD 08                push A
 06BE 5000              mov A,0
 06C0 08                push A
 06C1 5205              mov A,[X+5]
 06C3 08                push A
 06C4 5206              mov A,[X+6]
 06C6 08                push A
 06C7 7C0000            xcall __divmod_16X16_16
 06CA 18                pop A
 06CB 5300              mov [__r1],A
 06CD 18                pop A
 06CE 38FE              add SP,-2
 06D0 5100              mov A,[__r1]
 06D2 540B              mov [X+11],A
 06D4                   .dbline 416
 06D4           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 06D4 520B              mov A,[X+11]
 06D6 08                push A
 06D7 520A              mov A,[X+10]
 06D9 08                push A
 06DA 5020              mov A,32
 06DC 08                push A
 06DD 5003              mov A,3
 06DF 08                push A
 06E0 5005              mov A,5
 06E2 08                push A
 06E3 5204              mov A,[X+4]
 06E5 08                push A
 06E6 9412              xcall _longServoInstruction
 06E8 38FA              add SP,-6
 06EA                   .dbline 417
 06EA           ;                                                       }
 06EA                   .dbline 418
 06EA           ;                                               }
 06EA                   .dbline 419
 06EA           ;                                       }
 06EA                   .dbline 420
 06EA           ;                               }
 06EA                   .dbline 421
 06EA           ;                       }
 06EA                   .dbline 422
 06EA           ;               }
 06EA 8341              xjmp L88
 06EC           L87:
 06EC                   .dbline 423
 06EC           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 06EC 62D000            mov REG[0xd0],>__r0
 06EF 5201              mov A,[X+1]
 06F1 5300              mov [__r1],A
 06F3 5200              mov A,[X+0]
 06F5 60D4              mov REG[0xd4],A
 06F7 3E00              mvi A,[__r1]
 06F9 5300              mov [__r1],A
 06FB 550000            mov [__r0],0
 06FE 3C0000            cmp [__r0],0
 0701 B005              jnz X35
 0703 3972              cmp A,114
 0705 A00E              jz L117
 0707           X35:
 0707 62D000            mov REG[0xd0],>__r0
 070A 3C0000            cmp [__r0],0
 070D B31E              jnz L115
 070F 3C0052            cmp [__r1],82
 0712 B319              jnz L115
 0714           X36:
 0714           L117:
 0714                   .dbline 424
 0714           ;               {                       
 0714                   .dbline 425
 0714           ;                       if(param = COMP_SERIAL_szGetParam())
 0714 10                push X
 0715 7C0000            xcall _COMP_SERIAL_szGetParam
 0718 62D000            mov REG[0xd0],>__r0
 071B 5300              mov [__r0],A
 071D 5A00              mov [__r1],X
 071F 20                pop X
 0720 5100              mov A,[__r1]
 0722 5401              mov [X+1],A
 0724 5100              mov A,[__r0]
 0726 5400              mov [X+0],A
 0728 3C0000            cmp [__r0],0
 072B B006              jnz X37
 072D 3C0000            cmp [__r1],0
 0730 A2FB              jz L118
 0732           X37:
 0732                   .dbline 426
 0732           ;                       {
 0732                   .dbline 427
 0732           ;                               ID = atoi(param);
 0732 5200              mov A,[X+0]
 0734 08                push A
 0735 5201              mov A,[X+1]
 0737 08                push A
 0738 7C0000            xcall _atoi
 073B 38FE              add SP,-2
 073D 62D000            mov REG[0xd0],>__r0
 0740 5100              mov A,[__r1]
 0742 5404              mov [X+4],A
 0744                   .dbline 428
 0744           ;                               if(param = COMP_SERIAL_szGetParam())
 0744 10                push X
 0745 7C0000            xcall _COMP_SERIAL_szGetParam
 0748 62D000            mov REG[0xd0],>__r0
 074B 5300              mov [__r0],A
 074D 5A00              mov [__r1],X
 074F 20                pop X
 0750 5100              mov A,[__r1]
 0752 5401              mov [X+1],A
 0754 5100              mov A,[__r0]
 0756 5400              mov [X+0],A
 0758 3C0000            cmp [__r0],0
 075B B006              jnz X38
 075D 3C0000            cmp [__r1],0
 0760 A2CB              jz L120
 0762           X38:
 0762                   .dbline 429
 0762           ;                               {
 0762                   .dbline 430
 0762           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0762 62D000            mov REG[0xd0],>__r0
 0765 5201              mov A,[X+1]
 0767 5300              mov [__r1],A
 0769 5200              mov A,[X+0]
 076B 60D4              mov REG[0xd4],A
 076D 3E00              mvi A,[__r1]
 076F 5300              mov [__r1],A
 0771 550000            mov [__r0],0
 0774 3C0000            cmp [__r0],0
 0777 B005              jnz X39
 0779 3961              cmp A,97
 077B A00E              jz L124
 077D           X39:
 077D 62D000            mov REG[0xd0],>__r0
 0780 3C0000            cmp [__r0],0
 0783 B0D1              jnz L122
 0785 3C0041            cmp [__r1],65
 0788 B0CC              jnz L122
 078A           X40:
 078A           L124:
 078A                   .dbline 431
 078A           ;                                       {
 078A                   .dbline 432
 078A           ;                                               angle[0] = 0;
 078A 560800            mov [X+8],0
 078D                   .dbline 433
 078D           ;                                               angle[1] = 0;
 078D 560900            mov [X+9],0
 0790                   .dbline 436
 0790           ;                                               
 0790           ;                                               // Send a request for the servo's angle.
 0790           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 0790 5002              mov A,2
 0792 08                push A
 0793 5024              mov A,36
 0795 08                push A
 0796 5002              mov A,2
 0798 08                push A
 0799 5004              mov A,4
 079B 08                push A
 079C 5204              mov A,[X+4]
 079E 08                push A
 079F 92B6              xcall _servoInstruction
 07A1                   .dbline 437
 07A1           ;                                               configToggle(RX_MODE);
 07A1 5000              mov A,0
 07A3 08                push A
 07A4 5002              mov A,2
 07A6 08                push A
 07A7 9402              xcall _configToggle
 07A9 38F9              add SP,-7
 07AB 8098              xjmp L127
 07AD           L126:
 07AD                   .dbline 441
 07AD           ;                                                       
 07AD           ;                                               // Loop until we read a response or time out.
 07AD           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07AD           ;                                               {
 07AD                   .dbline 442
 07AD           ;                                                       if(RECEIVE_cReadChar() == ID)
 07AD 10                push X
 07AE 7C0000            xcall _RECEIVE_cReadChar
 07B1 62D000            mov REG[0xd0],>__r0
 07B4 20                pop X
 07B5 3B04              cmp A,[X+4]
 07B7 B08C              jnz L129
 07B9                   .dbline 443
 07B9           ;                                                       {
 07B9 807B              xjmp L132
 07BB           L131:
 07BB                   .dbline 445
 07BB           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07BB           ;                                                               {
 07BB                   .dbline 446
 07BB           ;                                                                       if(RECEIVE_cReadChar() == 4)
 07BB 10                push X
 07BC 7C0000            xcall _RECEIVE_cReadChar
 07BF 62D000            mov REG[0xd0],>__r0
 07C2 20                pop X
 07C3 3904              cmp A,4
 07C5 B06F              jnz L134
 07C7                   .dbline 447
 07C7           ;                                                                       {
 07C7                   .dbline 448
 07C7           ;                                                                               if(RECEIVE_cGetChar() == 0)
 07C7 10                push X
 07C8 7C0000            xcall _RECEIVE_cGetChar
 07CB 62D000            mov REG[0xd0],>__r0
 07CE 20                pop X
 07CF 3900              cmp A,0
 07D1 B05A              jnz L136
 07D3                   .dbline 449
 07D3           ;                                                                               {
 07D3                   .dbline 451
 07D3           ;                                                                                       // Grab the angle bytes.
 07D3           ;                                                                                       angle[0] = RECEIVE_cGetChar();
 07D3 10                push X
 07D4 7C0000            xcall _RECEIVE_cGetChar
 07D7 62D000            mov REG[0xd0],>__r0
 07DA 20                pop X
 07DB 5408              mov [X+8],A
 07DD                   .dbline 452
 07DD           ;                                                                                       angle[1] = RECEIVE_cGetChar();
 07DD 10                push X
 07DE 7C0000            xcall _RECEIVE_cGetChar
 07E1 62D000            mov REG[0xd0],>__r0
 07E4 20                pop X
 07E5 5409              mov [X+9],A
 07E7                   .dbline 454
 07E7           ;                                                                                       
 07E7           ;                                                                                       configToggle(PC_MODE);
 07E7 5000              mov A,0
 07E9 08                push A
 07EA 5001              mov A,1
 07EC 08                push A
 07ED 93BC              xcall _configToggle
 07EF                   .dbline 457
 07EF           ;                                                                                       
 07EF           ;                                                                                       // Convert the bytes to an int from 0-1023 and send.
 07EF           ;                                                                                       total = ((angle[1])*256) + angle[0];
 07EF 5208              mov A,[X+8]
 07F1 5406              mov [X+6],A
 07F3 5209              mov A,[X+9]
 07F5 5405              mov [X+5],A
 07F7                   .dbline 458
 07F7           ;                                                                                       itoa(param,total,10);
 07F7 5000              mov A,0
 07F9 08                push A
 07FA 500A              mov A,10
 07FC 08                push A
 07FD 5205              mov A,[X+5]
 07FF 08                push A
 0800 5206              mov A,[X+6]
 0802 08                push A
 0803 5200              mov A,[X+0]
 0805 08                push A
 0806 5201              mov A,[X+1]
 0808 08                push A
 0809 7C0000            xcall _itoa
 080C 38F8              add SP,-8
 080E                   .dbline 459
 080E           ;                                                                                       COMP_SERIAL_PutString(param);
 080E 10                push X
 080F 5200              mov A,[X+0]
 0811 08                push A
 0812 5201              mov A,[X+1]
 0814 5C                mov X,A
 0815 18                pop A
 0816 7C0000            xcall _COMP_SERIAL_PutString
 0819 20                pop X
 081A                   .dbline 460
 081A           ;                                                                                       COMP_SERIAL_PutChar('\n');
 081A 10                push X
 081B 500A              mov A,10
 081D 7C0000            xcall _COMP_SERIAL_PutChar
 0820 20                pop X
 0821                   .dbline 462
 0821           ; 
 0821           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0821 62D000            mov REG[0xd0],>_TIMEOUT
 0824 550103            mov [_TIMEOUT+1],3
 0827 550000            mov [_TIMEOUT],0
 082A                   .dbline 463
 082A           ;                                                                               }
 082A 800A              xjmp L137
 082C           L136:
 082C                   .dbline 465
 082C           ;                                                                               else
 082C           ;                                                                               {
 082C                   .dbline 466
 082C           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 082C 62D000            mov REG[0xd0],>_TIMEOUT
 082F 550103            mov [_TIMEOUT+1],3
 0832 550000            mov [_TIMEOUT],0
 0835                   .dbline 467
 0835           ;                                                                               }
 0835           L137:
 0835                   .dbline 468
 0835           ;                                                                       }
 0835           L134:
 0835                   .dbline 469
 0835           ;                                                               }
 0835           L132:
 0835                   .dbline 444
 0835 62D000            mov REG[0xd0],>_TIMEOUT
 0838 5101              mov A,[_TIMEOUT+1]
 083A 1103              sub A,3
 083C 5100              mov A,[_TIMEOUT]
 083E 3180              xor A,-128
 0840 1980              sbb A,(0 ^ 0x80)
 0842 CF78              jc L131
 0844           X41:
 0844                   .dbline 470
 0844           ;                                                       }
 0844           L129:
 0844                   .dbline 471
 0844           ;                                               }
 0844           L127:
 0844                   .dbline 440
 0844 62D000            mov REG[0xd0],>_TIMEOUT
 0847 5101              mov A,[_TIMEOUT+1]
 0849 1103              sub A,3
 084B 5100              mov A,[_TIMEOUT]
 084D 3180              xor A,-128
 084F 1980              sbb A,(0 ^ 0x80)
 0851 CF5B              jc L126
 0853           X42:
 0853                   .dbline 472
 0853           ;                                       }
 0853 81D8              xjmp L123
 0855           L122:
 0855                   .dbline 473
 0855           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 0855 62D000            mov REG[0xd0],>__r0
 0858 5201              mov A,[X+1]
 085A 5300              mov [__r1],A
 085C 5200              mov A,[X+0]
 085E 60D4              mov REG[0xd4],A
 0860 3E00              mvi A,[__r1]
 0862 5300              mov [__r1],A
 0864 550000            mov [__r0],0
 0867 3C0000            cmp [__r0],0
 086A B005              jnz X43
 086C 3970              cmp A,112
 086E A00E              jz L142
 0870           X43:
 0870 62D000            mov REG[0xd0],>__r0
 0873 3C0000            cmp [__r0],0
 0876 B0EF              jnz L140
 0878 3C0050            cmp [__r1],80
 087B B0EA              jnz L140
 087D           X44:
 087D           L142:
 087D                   .dbline 474
 087D           ;                                       {
 087D                   .dbline 475
 087D           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 087D 5001              mov A,1
 087F 08                push A
 0880 5018              mov A,24
 0882 08                push A
 0883 5002              mov A,2
 0885 08                push A
 0886 5004              mov A,4
 0888 08                push A
 0889 5204              mov A,[X+4]
 088B 08                push A
 088C 91C9              xcall _servoInstruction
 088E                   .dbline 476
 088E           ;                                               configToggle(RX_MODE);
 088E 5000              mov A,0
 0890 08                push A
 0891 5002              mov A,2
 0893 08                push A
 0894 9315              xcall _configToggle
 0896 38F9              add SP,-7
 0898 80BC              xjmp L144
 089A           L143:
 089A                   .dbline 480
 089A           ;                                               
 089A           ;                                               // Loop until we read a response or time out.
 089A           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 089A           ;                                               {
 089A                   .dbline 481
 089A           ;                                                       if(RECEIVE_cReadChar() == ID)
 089A 10                push X
 089B 7C0000            xcall _RECEIVE_cReadChar
 089E 62D000            mov REG[0xd0],>__r0
 08A1 20                pop X
 08A2 3B04              cmp A,[X+4]
 08A4 B0B0              jnz L146
 08A6                   .dbline 482
 08A6           ;                                                       {
 08A6                   .dbline 483
 08A6           ;                                                               runningTotal = ID;
 08A6 5204              mov A,[X+4]
 08A8 5403              mov [X+3],A
 08AA 560200            mov [X+2],0
 08AD 8098              xjmp L149
 08AF           L148:
 08AF                   .dbline 486
 08AF           ;                                                               // Loop until we read a response or time out.
 08AF           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 08AF           ;                                                               {
 08AF                   .dbline 488
 08AF           ;                                                                       // Check the length of the packet.
 08AF           ;                                                                       if(RECEIVE_cReadChar() == 3)
 08AF 10                push X
 08B0 7C0000            xcall _RECEIVE_cReadChar
 08B3 62D000            mov REG[0xd0],>__r0
 08B6 20                pop X
 08B7 3903              cmp A,3
 08B9 B08C              jnz L151
 08BB                   .dbline 489
 08BB           ;                                                                       {
 08BB                   .dbline 490
 08BB           ;                                                                               runningTotal += 3;
 08BB 070303            add [X+3],3
 08BE 0F0200            adc [X+2],0
 08C1 8075              xjmp L154
 08C3           L153:
 08C3                   .dbline 493
 08C3           ;                                                                               // Loop until we read a response or time out.
 08C3           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 08C3           ;                                                                               {
 08C3                   .dbline 495
 08C3           ;                                                                                       // Check for the checksum or 1.
 08C3           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 08C3 10                push X
 08C4 7C0000            xcall _RECEIVE_cReadChar
 08C7 62D000            mov REG[0xd0],>__r0
 08CA 20                pop X
 08CB 5407              mov [X+7],A
 08CD 3900              cmp A,0
 08CF A067              jz L156
 08D1                   .dbline 496
 08D1           ;                                                                                       {
 08D1                   .dbline 497
 08D1           ;                                                                                               configToggle(PC_MODE);
 08D1 5000              mov A,0
 08D3 08                push A
 08D4 5001              mov A,1
 08D6 08                push A
 08D7 92D2              xcall _configToggle
 08D9 38FE              add SP,-2
 08DB                   .dbline 499
 08DB           ;                                                                                               
 08DB           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 08DB 62D000            mov REG[0xd0],>__r0
 08DE 5207              mov A,[X+7]
 08E0 5300              mov [__r1],A
 08E2 550000            mov [__r0],0
 08E5 50FF              mov A,-1
 08E7 1200              sub A,[__r1]
 08E9 5300              mov [__r1],A
 08EB 5000              mov A,0
 08ED 1A00              sbb A,[__r0]
 08EF 5300              mov [__r0],A
 08F1 5001              mov A,1
 08F3 08                push A
 08F4 5000              mov A,0
 08F6 08                push A
 08F7 5202              mov A,[X+2]
 08F9 08                push A
 08FA 5203              mov A,[X+3]
 08FC 08                push A
 08FD 7C0000            xcall __divmod_16X16_16
 0900 38FE              add SP,-2
 0902 18                pop A
 0903 5300              mov [__r3],A
 0905 18                pop A
 0906 3A00              cmp A,[__r0]
 0908 B017              jnz L158
 090A 5100              mov A,[__r3]
 090C 3A00              cmp A,[__r1]
 090E B011              jnz L158
 0910           X45:
 0910                   .dbline 500
 0910           ;                                                                                               {
 0910                   .dbline 502
 0910           ;                                                                                                       // Send a 0 if we hit the checksum.
 0910           ;                                                                                                       COMP_SERIAL_PutChar('0');
 0910 10                push X
 0911 5030              mov A,48
 0913 7C0000            xcall _COMP_SERIAL_PutChar
 0916 20                pop X
 0917                   .dbline 503
 0917           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0917 10                push X
 0918 500A              mov A,10
 091A 7C0000            xcall _COMP_SERIAL_PutChar
 091D 20                pop X
 091E                   .dbline 504
 091E           ;                                                                                               }
 091E 800F              xjmp L159
 0920           L158:
 0920                   .dbline 506
 0920           ;                                                                                               else
 0920           ;                                                                                               {
 0920                   .dbline 508
 0920           ;                                                                                                       // Send a 1.
 0920           ;                                                                                                       COMP_SERIAL_PutChar('1');
 0920 10                push X
 0921 5031              mov A,49
 0923 7C0000            xcall _COMP_SERIAL_PutChar
 0926 20                pop X
 0927                   .dbline 509
 0927           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0927 10                push X
 0928 500A              mov A,10
 092A 7C0000            xcall _COMP_SERIAL_PutChar
 092D 20                pop X
 092E                   .dbline 510
 092E           ;                                                                                               }
 092E           L159:
 092E                   .dbline 512
 092E           ;               
 092E           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 092E 62D000            mov REG[0xd0],>_TIMEOUT
 0931 550103            mov [_TIMEOUT+1],3
 0934 550000            mov [_TIMEOUT],0
 0937                   .dbline 513
 0937           ;                                                                                       }
 0937           L156:
 0937                   .dbline 514
 0937           ;                                                                               }
 0937           L154:
 0937                   .dbline 492
 0937 62D000            mov REG[0xd0],>_TIMEOUT
 093A 5101              mov A,[_TIMEOUT+1]
 093C 1103              sub A,3
 093E 5100              mov A,[_TIMEOUT]
 0940 3180              xor A,-128
 0942 1980              sbb A,(0 ^ 0x80)
 0944 CF7E              jc L153
 0946           X46:
 0946                   .dbline 515
 0946           ;                                                                       }
 0946           L151:
 0946                   .dbline 516
 0946           ;                                                               }
 0946           L149:
 0946                   .dbline 485
 0946 62D000            mov REG[0xd0],>_TIMEOUT
 0949 5101              mov A,[_TIMEOUT+1]
 094B 1103              sub A,3
 094D 5100              mov A,[_TIMEOUT]
 094F 3180              xor A,-128
 0951 1980              sbb A,(0 ^ 0x80)
 0953 CF5B              jc L148
 0955           X47:
 0955                   .dbline 517
 0955           ;                                                       }
 0955           L146:
 0955                   .dbline 518
 0955           ;                                               }
 0955           L144:
 0955                   .dbline 479
 0955 62D000            mov REG[0xd0],>_TIMEOUT
 0958 5101              mov A,[_TIMEOUT+1]
 095A 1103              sub A,3
 095C 5100              mov A,[_TIMEOUT]
 095E 3180              xor A,-128
 0960 1980              sbb A,(0 ^ 0x80)
 0962 CF37              jc L143
 0964           X48:
 0964                   .dbline 519
 0964           ;                                       }
 0964 80C7              xjmp L141
 0966           L140:
 0966                   .dbline 520
 0966           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 0966 62D000            mov REG[0xd0],>__r0
 0969 5201              mov A,[X+1]
 096B 5300              mov [__r1],A
 096D 5200              mov A,[X+0]
 096F 60D4              mov REG[0xd4],A
 0971 3E00              mvi A,[__r1]
 0973 5300              mov [__r1],A
 0975 550000            mov [__r0],0
 0978 3C0000            cmp [__r0],0
 097B B005              jnz X49
 097D 3974              cmp A,116
 097F A00E              jz L162
 0981           X49:
 0981 62D000            mov REG[0xd0],>__r0
 0984 3C0000            cmp [__r0],0
 0987 B042              jnz L160
 0989 3C0054            cmp [__r1],84
 098C B03D              jnz L160
 098E           X50:
 098E           L162:
 098E                   .dbline 521
 098E           ;                                       {
 098E                   .dbline 523
 098E           ;                                               // Ping the module and return its type field to the PC.
 098E           ;                                               if(pingModule(ID))
 098E 62D000            mov REG[0xd0],>__r0
 0991 5204              mov A,[X+4]
 0993 5300              mov [__r1],A
 0995 5000              mov A,0
 0997 08                push A
 0998 5100              mov A,[__r1]
 099A 08                push A
 099B 7C0046            xcall _pingModule
 099E 38FE              add SP,-2
 09A0 62D000            mov REG[0xd0],>__r0
 09A3 3C0000            cmp [__r0],0
 09A6 B006              jnz X51
 09A8 3C0000            cmp [__r1],0
 09AB A080              jz L161
 09AD           X51:
 09AD                   .dbline 524
 09AD           ;                                               {
 09AD                   .dbline 525
 09AD           ;                                                       configToggle(PC_MODE);
 09AD 5000              mov A,0
 09AF 08                push A
 09B0 5001              mov A,1
 09B2 08                push A
 09B3 91F6              xcall _configToggle
 09B5 38FE              add SP,-2
 09B7                   .dbline 527
 09B7           ;                                                       
 09B7           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 09B7 10                push X
 09B8 62D000            mov REG[0xd0],>_PARAM
 09BB 5100              mov A,[_PARAM]
 09BD 7C0000            xcall _COMP_SERIAL_PutChar
 09C0 20                pop X
 09C1                   .dbline 528
 09C1           ;                                                       COMP_SERIAL_PutChar('\n');
 09C1 10                push X
 09C2 500A              mov A,10
 09C4 7C0000            xcall _COMP_SERIAL_PutChar
 09C7 20                pop X
 09C8                   .dbline 529
 09C8           ;                                               }
 09C8                   .dbline 530
 09C8           ;                                       }
 09C8 8063              xjmp L161
 09CA           L160:
 09CA                   .dbline 531
 09CA           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 09CA 62D000            mov REG[0xd0],>__r0
 09CD 5201              mov A,[X+1]
 09CF 5300              mov [__r1],A
 09D1 5200              mov A,[X+0]
 09D3 60D4              mov REG[0xd4],A
 09D5 3E00              mvi A,[__r1]
 09D7 5300              mov [__r1],A
 09D9 550000            mov [__r0],0
 09DC 3C0000            cmp [__r0],0
 09DF B005              jnz X52
 09E1 3963              cmp A,99
 09E3 A00E              jz L167
 09E5           X52:
 09E5 62D000            mov REG[0xd0],>__r0
 09E8 3C0000            cmp [__r0],0
 09EB B040              jnz L165
 09ED 3C0043            cmp [__r1],67
 09F0 B03B              jnz L165
 09F2           X53:
 09F2           L167:
 09F2                   .dbline 532
 09F2           ;                                       {
 09F2                   .dbline 534
 09F2           ;                                               // Ping the module and return its child port to the PC.
 09F2           ;                                               if(pingModule(ID))
 09F2 62D000            mov REG[0xd0],>__r0
 09F5 5204              mov A,[X+4]
 09F7 5300              mov [__r1],A
 09F9 5000              mov A,0
 09FB 08                push A
 09FC 5100              mov A,[__r1]
 09FE 08                push A
 09FF 7C0046            xcall _pingModule
 0A02 38FE              add SP,-2
 0A04 62D000            mov REG[0xd0],>__r0
 0A07 3C0000            cmp [__r0],0
 0A0A B006              jnz X54
 0A0C 3C0000            cmp [__r1],0
 0A0F A01C              jz L168
 0A11           X54:
 0A11                   .dbline 535
 0A11           ;                                               {       
 0A11                   .dbline 536
 0A11           ;                                                       configToggle(PC_MODE);
 0A11 5000              mov A,0
 0A13 08                push A
 0A14 5001              mov A,1
 0A16 08                push A
 0A17 9192              xcall _configToggle
 0A19 38FE              add SP,-2
 0A1B                   .dbline 538
 0A1B           ;                                                       
 0A1B           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 0A1B 10                push X
 0A1C 62D000            mov REG[0xd0],>_PARAM
 0A1F 5101              mov A,[_PARAM+1]
 0A21 7C0000            xcall _COMP_SERIAL_PutChar
 0A24 20                pop X
 0A25                   .dbline 539
 0A25           ;                                                       COMP_SERIAL_PutChar('\n');
 0A25 10                push X
 0A26 500A              mov A,10
 0A28 7C0000            xcall _COMP_SERIAL_PutChar
 0A2B 20                pop X
 0A2C                   .dbline 540
 0A2C           ;                                               }
 0A2C           L168:
 0A2C                   .dbline 541
 0A2C           ;                                       }
 0A2C           L165:
 0A2C           L161:
 0A2C           L141:
 0A2C           L123:
 0A2C                   .dbline 542
 0A2C           ;                               }
 0A2C           L120:
 0A2C                   .dbline 543
 0A2C           ;                       }
 0A2C           L118:
 0A2C                   .dbline 544
 0A2C           ;               }
 0A2C           L115:
 0A2C           L88:
 0A2C           L85:
 0A2C           L78:
 0A2C                   .dbline 545
 0A2C           ;       }
 0A2C           L75:
 0A2C                   .dbline 547
 0A2C           ;       
 0A2C           ;       if(STATE != PC_MODE)
 0A2C 62D000            mov REG[0xd0],>_STATE
 0A2F 3C0000            cmp [_STATE],0
 0A32 B006              jnz X55
 0A34 3C0101            cmp [_STATE+1],1
 0A37 A00D              jz L171
 0A39           X55:
 0A39                   .dbline 548
 0A39           ;       {
 0A39                   .dbline 549
 0A39           ;               configToggle(PC_MODE);
 0A39 5000              mov A,0
 0A3B 08                push A
 0A3C 5001              mov A,1
 0A3E 08                push A
 0A3F 916A              xcall _configToggle
 0A41 38FE              add SP,-2
 0A43                   .dbline 550
 0A43           ;       }
 0A43 800F              xjmp L172
 0A45           L171:
 0A45                   .dbline 552
 0A45           ;       else
 0A45           ;       {
 0A45                   .dbline 553
 0A45           ;               TIMEOUT = 0;
 0A45 62D000            mov REG[0xd0],>_TIMEOUT
 0A48 550100            mov [_TIMEOUT+1],0
 0A4B 550000            mov [_TIMEOUT],0
 0A4E                   .dbline 554
 0A4E           ;               COMP_SERIAL_CmdReset();
 0A4E 10                push X
 0A4F 7C0000            xcall _COMP_SERIAL_CmdReset
 0A52 20                pop X
 0A53                   .dbline 555
 0A53           ;       }
 0A53           L172:
 0A53                   .dbline -2
 0A53           L74:
 0A53 38F4              add SP,-12
 0A55 20                pop X
 0A56                   .dbline 0 ; func end
 0A56 7F                ret
 0A57                   .dbsym l speed 10 A[2:2]c
 0A57                   .dbsym l angle 8 A[2:2]c
 0A57                   .dbsym l tempByte 7 c
 0A57                   .dbsym l total 5 I
 0A57                   .dbsym l ID 4 c
 0A57                   .dbsym l runningTotal 2 I
 0A57                   .dbsym l param 0 pc
 0A57                   .dbend
 0A57                   .dbfunc e servoInstruction _servoInstruction fV
 0A57           ;          total -> X+1
 0A57           ;       checksum -> X+0
 0A57           ;          value -> X-8
 0A57           ;        address -> X-7
 0A57           ;    instruction -> X-6
 0A57           ;         length -> X-5
 0A57           ;             id -> X-4
 0A57           _servoInstruction::
 0A57                   .dbline -1
 0A57 10                push X
 0A58 4F                mov X,SP
 0A59 3803              add SP,3
 0A5B                   .dbline 561
 0A5B           ; }
 0A5B           ; 
 0A5B           ; // This function receives a destination, command length, instruction type, address, and value.
 0A5B           ; // With these parameters, the function sends a packet to the communication bus.
 0A5B           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0A5B           ; {
 0A5B                   .dbline 565
 0A5B           ;       char checksum;
 0A5B           ;       int total;
 0A5B           ;       
 0A5B           ;       total = id + length + instruction + address + value;
 0A5B 62D000            mov REG[0xd0],>__r0
 0A5E 52FB              mov A,[X-5]
 0A60 5300              mov [__r1],A
 0A62 550000            mov [__r0],0
 0A65 52FC              mov A,[X-4]
 0A67 0200              add A,[__r1]
 0A69 5300              mov [__r1],A
 0A6B 5000              mov A,0
 0A6D 0A00              adc A,[__r0]
 0A6F 5300              mov [__r0],A
 0A71 52FA              mov A,[X-6]
 0A73 0400              add [__r1],A
 0A75 0E0000            adc [__r0],0
 0A78 52F9              mov A,[X-7]
 0A7A 0400              add [__r1],A
 0A7C 0E0000            adc [__r0],0
 0A7F 52F8              mov A,[X-8]
 0A81 5300              mov [__r3],A
 0A83 550000            mov [__r2],0
 0A86 5100              mov A,[__r1]
 0A88 0200              add A,[__r3]
 0A8A 5402              mov [X+2],A
 0A8C 5100              mov A,[__r0]
 0A8E 0A00              adc A,[__r2]
 0A90 5401              mov [X+1],A
 0A92                   .dbline 568
 0A92           ;       
 0A92           ;       // Calculate the checksum value for our servo communication.
 0A92           ;       checksum = 255-(total%256);
 0A92 5001              mov A,1
 0A94 08                push A
 0A95 5000              mov A,0
 0A97 08                push A
 0A98 5201              mov A,[X+1]
 0A9A 08                push A
 0A9B 5202              mov A,[X+2]
 0A9D 08                push A
 0A9E 7C0000            xcall __divmod_16X16_16
 0AA1 38FE              add SP,-2
 0AA3 18                pop A
 0AA4 5300              mov [__r1],A
 0AA6 18                pop A
 0AA7 50FF              mov A,-1
 0AA9 1200              sub A,[__r1]
 0AAB 5400              mov [X+0],A
 0AAD                   .dbline 571
 0AAD           ;       
 0AAD           ;       // Talk to the servo.
 0AAD           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0AAD 10                push X
 0AAE 50FF              mov A,-1
 0AB0 7C0000            xcall _TX_REPEATER_PutChar
 0AB3 20                pop X
 0AB4                   .dbline 572
 0AB4           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0AB4 10                push X
 0AB5 50FF              mov A,-1
 0AB7 7C0000            xcall _TX_REPEATER_PutChar
 0ABA 20                pop X
 0ABB                   .dbline 573
 0ABB           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0ABB 10                push X
 0ABC 52FC              mov A,[X-4]
 0ABE 7C0000            xcall _TX_REPEATER_PutChar
 0AC1 20                pop X
 0AC2                   .dbline 574
 0AC2           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0AC2 10                push X
 0AC3 52FB              mov A,[X-5]
 0AC5 7C0000            xcall _TX_REPEATER_PutChar
 0AC8 20                pop X
 0AC9                   .dbline 575
 0AC9           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AC9 10                push X
 0ACA 52FA              mov A,[X-6]
 0ACC 7C0000            xcall _TX_REPEATER_PutChar
 0ACF 20                pop X
 0AD0                   .dbline 576
 0AD0           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AD0 10                push X
 0AD1 52F9              mov A,[X-7]
 0AD3 7C0000            xcall _TX_REPEATER_PutChar
 0AD6 20                pop X
 0AD7                   .dbline 577
 0AD7           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0AD7 10                push X
 0AD8 52F8              mov A,[X-8]
 0ADA 7C0000            xcall _TX_REPEATER_PutChar
 0ADD 20                pop X
 0ADE                   .dbline 578
 0ADE           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0ADE 10                push X
 0ADF 5200              mov A,[X+0]
 0AE1 7C0000            xcall _TX_REPEATER_PutChar
 0AE4 20                pop X
 0AE5           L174:
 0AE5                   .dbline 581
 0AE5           ;       
 0AE5           ;       // Wait for the transmission to finish.
 0AE5           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0AE5           L175:
 0AE5                   .dbline 581
 0AE5 10                push X
 0AE6 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0AE9 62D000            mov REG[0xd0],>__r0
 0AEC 20                pop X
 0AED 5300              mov [__r0],A
 0AEF 470020            tst [__r0],32
 0AF2 AFF2              jz L174
 0AF4                   .dbline 584
 0AF4           ;       
 0AF4           ;       // Make completely sure we're done.
 0AF4           ;       xmitWait();
 0AF4 9334              xcall _xmitWait
 0AF6                   .dbline -2
 0AF6           L173:
 0AF6 38FD              add SP,-3
 0AF8 20                pop X
 0AF9                   .dbline 0 ; func end
 0AF9 7F                ret
 0AFA                   .dbsym l total 1 I
 0AFA                   .dbsym l checksum 0 c
 0AFA                   .dbsym l value -8 c
 0AFA                   .dbsym l address -7 c
 0AFA                   .dbsym l instruction -6 c
 0AFA                   .dbsym l length -5 c
 0AFA                   .dbsym l id -4 c
 0AFA                   .dbend
 0AFA                   .dbfunc e longServoInstruction _longServoInstruction fV
 0AFA           ;          total -> X+1
 0AFA           ;       checksum -> X+0
 0AFA           ;         value2 -> X-9
 0AFA           ;         value1 -> X-8
 0AFA           ;        address -> X-7
 0AFA           ;    instruction -> X-6
 0AFA           ;         length -> X-5
 0AFA           ;             id -> X-4
 0AFA           _longServoInstruction::
 0AFA                   .dbline -1
 0AFA 10                push X
 0AFB 4F                mov X,SP
 0AFC 3803              add SP,3
 0AFE                   .dbline 589
 0AFE           ; }
 0AFE           ; 
 0AFE           ; // This function receives a destination, command length, instruction type, address, and two values.
 0AFE           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0AFE           ; {
 0AFE                   .dbline 593
 0AFE           ;       char checksum;
 0AFE           ;       int total;
 0AFE           ;       
 0AFE           ;       total = id + length + instruction + address + value1 + value2;
 0AFE 62D000            mov REG[0xd0],>__r0
 0B01 52FB              mov A,[X-5]
 0B03 5300              mov [__r1],A
 0B05 550000            mov [__r0],0
 0B08 52FC              mov A,[X-4]
 0B0A 0200              add A,[__r1]
 0B0C 5300              mov [__r1],A
 0B0E 5000              mov A,0
 0B10 0A00              adc A,[__r0]
 0B12 5300              mov [__r0],A
 0B14 52FA              mov A,[X-6]
 0B16 0400              add [__r1],A
 0B18 0E0000            adc [__r0],0
 0B1B 52F9              mov A,[X-7]
 0B1D 0400              add [__r1],A
 0B1F 0E0000            adc [__r0],0
 0B22 52F8              mov A,[X-8]
 0B24 0400              add [__r1],A
 0B26 0E0000            adc [__r0],0
 0B29 52F7              mov A,[X-9]
 0B2B 5300              mov [__r3],A
 0B2D 550000            mov [__r2],0
 0B30 5100              mov A,[__r1]
 0B32 0200              add A,[__r3]
 0B34 5402              mov [X+2],A
 0B36 5100              mov A,[__r0]
 0B38 0A00              adc A,[__r2]
 0B3A 5401              mov [X+1],A
 0B3C                   .dbline 596
 0B3C           ;       
 0B3C           ;       // Calculate the checksum value for our servo communication.
 0B3C           ;       checksum = 255-(total%256);
 0B3C 5001              mov A,1
 0B3E 08                push A
 0B3F 5000              mov A,0
 0B41 08                push A
 0B42 5201              mov A,[X+1]
 0B44 08                push A
 0B45 5202              mov A,[X+2]
 0B47 08                push A
 0B48 7C0000            xcall __divmod_16X16_16
 0B4B 38FE              add SP,-2
 0B4D 18                pop A
 0B4E 5300              mov [__r1],A
 0B50 18                pop A
 0B51 50FF              mov A,-1
 0B53 1200              sub A,[__r1]
 0B55 5400              mov [X+0],A
 0B57                   .dbline 599
 0B57           ;       
 0B57           ;       // Talk to the servo.
 0B57           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0B57 10                push X
 0B58 50FF              mov A,-1
 0B5A 7C0000            xcall _TX_REPEATER_PutChar
 0B5D 20                pop X
 0B5E                   .dbline 600
 0B5E           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0B5E 10                push X
 0B5F 50FF              mov A,-1
 0B61 7C0000            xcall _TX_REPEATER_PutChar
 0B64 20                pop X
 0B65                   .dbline 601
 0B65           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0B65 10                push X
 0B66 52FC              mov A,[X-4]
 0B68 7C0000            xcall _TX_REPEATER_PutChar
 0B6B 20                pop X
 0B6C                   .dbline 602
 0B6C           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0B6C 10                push X
 0B6D 52FB              mov A,[X-5]
 0B6F 7C0000            xcall _TX_REPEATER_PutChar
 0B72 20                pop X
 0B73                   .dbline 603
 0B73           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0B73 10                push X
 0B74 52FA              mov A,[X-6]
 0B76 7C0000            xcall _TX_REPEATER_PutChar
 0B79 20                pop X
 0B7A                   .dbline 604
 0B7A           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0B7A 10                push X
 0B7B 52F9              mov A,[X-7]
 0B7D 7C0000            xcall _TX_REPEATER_PutChar
 0B80 20                pop X
 0B81                   .dbline 605
 0B81           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0B81 10                push X
 0B82 52F8              mov A,[X-8]
 0B84 7C0000            xcall _TX_REPEATER_PutChar
 0B87 20                pop X
 0B88                   .dbline 606
 0B88           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0B88 10                push X
 0B89 52F7              mov A,[X-9]
 0B8B 7C0000            xcall _TX_REPEATER_PutChar
 0B8E 20                pop X
 0B8F                   .dbline 607
 0B8F           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0B8F 10                push X
 0B90 5200              mov A,[X+0]
 0B92 7C0000            xcall _TX_REPEATER_PutChar
 0B95 20                pop X
 0B96           L178:
 0B96                   .dbline 610
 0B96           ;       
 0B96           ;       // Wait for the transmission to finish.
 0B96           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0B96           L179:
 0B96                   .dbline 610
 0B96 10                push X
 0B97 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0B9A 62D000            mov REG[0xd0],>__r0
 0B9D 20                pop X
 0B9E 5300              mov [__r0],A
 0BA0 470020            tst [__r0],32
 0BA3 AFF2              jz L178
 0BA5                   .dbline 613
 0BA5           ;       
 0BA5           ;       // Make completely sure we're done.
 0BA5           ;       xmitWait();
 0BA5 9283              xcall _xmitWait
 0BA7                   .dbline -2
 0BA7           L177:
 0BA7 38FD              add SP,-3
 0BA9 20                pop X
 0BAA                   .dbline 0 ; func end
 0BAA 7F                ret
 0BAB                   .dbsym l total 1 I
 0BAB                   .dbsym l checksum 0 c
 0BAB                   .dbsym l value2 -9 c
 0BAB                   .dbsym l value1 -8 c
 0BAB                   .dbsym l address -7 c
 0BAB                   .dbsym l instruction -6 c
 0BAB                   .dbsym l length -5 c
 0BAB                   .dbsym l id -4 c
 0BAB                   .dbend
 0BAB                   .dbfunc e configToggle _configToggle fV
 0BAB           ;           mode -> X-5
 0BAB           _configToggle::
 0BAB                   .dbline -1
 0BAB 10                push X
 0BAC 4F                mov X,SP
 0BAD                   .dbline 619
 0BAD           ; }
 0BAD           ; 
 0BAD           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0BAD           ; // half duplex UART serial communication line.
 0BAD           ; void configToggle(int mode)
 0BAD           ; {
 0BAD                   .dbline 621
 0BAD           ;       // Disconnect from the global bus and leave the pin high.
 0BAD           ;       PRT0DR |= 0b11111111;
 0BAD 4300FF            or REG[0],-1
 0BB0                   .dbline 622
 0BB0           ;       PRT0GS &= 0b01000000;
 0BB0 410240            and REG[0x2],64
 0BB3                   .dbline 626
 0BB3           ; 
 0BB3           ;       // Unload the configuration of the current state.
 0BB3           ;       // If there is no state, blindly wipe all configurations.
 0BB3           ;       if(STATE)
 0BB3 62D000            mov REG[0xd0],>_STATE
 0BB6 3C0000            cmp [_STATE],0
 0BB9 B006              jnz X56
 0BBB 3C0100            cmp [_STATE+1],0
 0BBE A010              jz L182
 0BC0           X56:
 0BC0                   .dbline 627
 0BC0           ;       {
 0BC0                   .dbline 628
 0BC0           ;               unloadConfig(STATE);
 0BC0 62D000            mov REG[0xd0],>_STATE
 0BC3 5100              mov A,[_STATE]
 0BC5 08                push A
 0BC6 5101              mov A,[_STATE+1]
 0BC8 08                push A
 0BC9 90AB              xcall _unloadConfig
 0BCB 38FE              add SP,-2
 0BCD                   .dbline 629
 0BCD           ;       }
 0BCD 8003              xjmp L183
 0BCF           L182:
 0BCF                   .dbline 631
 0BCF           ;       else
 0BCF           ;       {
 0BCF                   .dbline 632
 0BCF           ;               unloadAllConfigs();
 0BCF 909B              xcall _unloadAllConfigs
 0BD1                   .dbline 633
 0BD1           ;       }
 0BD1           L183:
 0BD1                   .dbline 635
 0BD1           ;       
 0BD1           ;       if(mode == PC_MODE)
 0BD1 3DFB00            cmp [X-5],0
 0BD4 B037              jnz L184
 0BD6 3DFC01            cmp [X-4],1
 0BD9 B032              jnz L184
 0BDB           X57:
 0BDB                   .dbline 636
 0BDB           ;       {
 0BDB                   .dbline 637
 0BDB           ;               LoadConfig_pc_listener();
 0BDB 7C0000            xcall _LoadConfig_pc_listener
 0BDE                   .dbline 639
 0BDE           ; 
 0BDE           ;               COMP_SERIAL_CmdReset();                                                 // Initialize the buffer.
 0BDE 10                push X
 0BDF 7C0000            xcall _COMP_SERIAL_CmdReset
 0BE2 20                pop X
 0BE3                   .dbline 640
 0BE3           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0BE3 10                push X
 0BE4 5001              mov A,1
 0BE6 7C0000            xcall _COMP_SERIAL_IntCntl
 0BE9 20                pop X
 0BEA                   .dbline 641
 0BEA           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0BEA 10                push X
 0BEB 5000              mov A,0
 0BED 7C0000            xcall _COMP_SERIAL_Start
 0BF0 20                pop X
 0BF1                   .dbline 643
 0BF1           ;               
 0BF1           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0BF1 10                push X
 0BF2 5000              mov A,0
 0BF4 7C0000            xcall _TX_REPEATER_Start
 0BF7 20                pop X
 0BF8                   .dbline 645
 0BF8           ;               
 0BF8           ;               TIMEOUT = 0;
 0BF8 62D000            mov REG[0xd0],>_TIMEOUT
 0BFB 550100            mov [_TIMEOUT+1],0
 0BFE 550000            mov [_TIMEOUT],0
 0C01                   .dbline 646
 0C01           ;               STATE = PC_MODE;
 0C01 62D000            mov REG[0xd0],>_STATE
 0C04 550101            mov [_STATE+1],1
 0C07 550000            mov [_STATE],0
 0C0A                   .dbline 647
 0C0A           ;       }
 0C0A 805C              xjmp L185
 0C0C           L184:
 0C0C                   .dbline 648
 0C0C           ;       else if(mode == RX_MODE)
 0C0C 3DFB00            cmp [X-5],0
 0C0F B02C              jnz L186
 0C11 3DFC02            cmp [X-4],2
 0C14 B027              jnz L186
 0C16           X58:
 0C16                   .dbline 649
 0C16           ;       {
 0C16                   .dbline 650
 0C16           ;               LoadConfig_receiver_config();
 0C16 7C0000            xcall _LoadConfig_receiver_config
 0C19                   .dbline 653
 0C19           ;               
 0C19           ;               // Start the receiver.
 0C19           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0C19 10                push X
 0C1A 5000              mov A,0
 0C1C 7C0000            xcall _RECEIVE_Start
 0C1F 20                pop X
 0C20                   .dbline 656
 0C20           ;               
 0C20           ;               // Start response timeout timer and enable its interrupt routine.
 0C20           ;               TIMEOUT = 0;
 0C20 62D000            mov REG[0xd0],>_TIMEOUT
 0C23 550100            mov [_TIMEOUT+1],0
 0C26 550000            mov [_TIMEOUT],0
 0C29                   .dbline 657
 0C29           ;               RX_TIMEOUT_EnableInt();
 0C29 10                push X
 0C2A 7C0000            xcall _RX_TIMEOUT_EnableInt
 0C2D                   .dbline 658
 0C2D           ;               RX_TIMEOUT_Start();
 0C2D 7C0000            xcall _RX_TIMEOUT_Start
 0C30 20                pop X
 0C31                   .dbline 660
 0C31           ;               
 0C31           ;               STATE = RX_MODE;
 0C31 62D000            mov REG[0xd0],>_STATE
 0C34 550102            mov [_STATE+1],2
 0C37 550000            mov [_STATE],0
 0C3A                   .dbline 661
 0C3A           ;       }
 0C3A 802C              xjmp L187
 0C3C           L186:
 0C3C                   .dbline 662
 0C3C           ;       else if(mode == TX_MODE)
 0C3C 3DFB00            cmp [X-5],0
 0C3F B027              jnz L188
 0C41 3DFC03            cmp [X-4],3
 0C44 B022              jnz L188
 0C46           X59:
 0C46                   .dbline 663
 0C46           ;       {
 0C46                   .dbline 664
 0C46           ;               LoadConfig_transmitter_config();
 0C46 7C0000            xcall _LoadConfig_transmitter_config
 0C49                   .dbline 666
 0C49           ;               // Start the transmitter.
 0C49           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0C49 10                push X
 0C4A 5000              mov A,0
 0C4C 7C0000            xcall _TRANSMIT_Start
 0C4F 20                pop X
 0C50                   .dbline 668
 0C50           ;               
 0C50           ;               TIMEOUT = 0;
 0C50 62D000            mov REG[0xd0],>_TIMEOUT
 0C53 550100            mov [_TIMEOUT+1],0
 0C56 550000            mov [_TIMEOUT],0
 0C59                   .dbline 669
 0C59           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0C59 10                push X
 0C5A 7C0000            xcall _TX_TIMEOUT_EnableInt
 0C5D 20                pop X
 0C5E                   .dbline 671
 0C5E           ;               
 0C5E           ;               STATE = TX_MODE;
 0C5E 62D000            mov REG[0xd0],>_STATE
 0C61 550103            mov [_STATE+1],3
 0C64 550000            mov [_STATE],0
 0C67                   .dbline 672
 0C67           ;       }
 0C67           L188:
 0C67           L187:
 0C67           L185:
 0C67                   .dbline 675
 0C67           ;       
 0C67           ;       // Reconnect to the global bus.
 0C67           ;       PRT0GS |= 0b10111111;
 0C67 4302BF            or REG[0x2],-65
 0C6A                   .dbline -2
 0C6A           L181:
 0C6A 20                pop X
 0C6B                   .dbline 0 ; func end
 0C6B 7F                ret
 0C6C                   .dbsym l mode -5 I
 0C6C                   .dbend
 0C6C                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C6C           _unloadAllConfigs::
 0C6C                   .dbline -1
 0C6C                   .dbline 681
 0C6C           ; }
 0C6C           ; 
 0C6C           ; // This function blindly unloads all user configurations. This will be called once,
 0C6C           ; // when the system initially has no known state.
 0C6C           ; void unloadAllConfigs(void)
 0C6C           ; {
 0C6C                   .dbline 682
 0C6C           ;       UnloadConfig_pc_listener();
 0C6C 7C0000            xcall _UnloadConfig_pc_listener
 0C6F                   .dbline 683
 0C6F           ;       UnloadConfig_receiver_config();
 0C6F 7C0000            xcall _UnloadConfig_receiver_config
 0C72                   .dbline 684
 0C72           ;       UnloadConfig_transmitter_config();
 0C72 7C0000            xcall _UnloadConfig_transmitter_config
 0C75                   .dbline -2
 0C75           L190:
 0C75                   .dbline 0 ; func end
 0C75 7F                ret
 0C76                   .dbend
 0C76                   .dbfunc e unloadConfig _unloadConfig fV
 0C76           ;     config_num -> X-5
 0C76           _unloadConfig::
 0C76                   .dbline -1
 0C76 10                push X
 0C77 4F                mov X,SP
 0C78                   .dbline 690
 0C78           ; }
 0C78           ; 
 0C78           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C78           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C78           ; void unloadConfig(int config_num)
 0C78           ; {
 0C78                   .dbline 691
 0C78           ;       if(config_num == PC_MODE)
 0C78 3DFB00            cmp [X-5],0
 0C7B B00B              jnz L192
 0C7D 3DFC01            cmp [X-4],1
 0C80 B006              jnz L192
 0C82           X60:
 0C82                   .dbline 692
 0C82           ;       {
 0C82                   .dbline 693
 0C82           ;               UnloadConfig_pc_listener();
 0C82 7C0000            xcall _UnloadConfig_pc_listener
 0C85                   .dbline 694
 0C85           ;       }
 0C85 801D              xjmp L193
 0C87           L192:
 0C87                   .dbline 695
 0C87           ;       else if(config_num == RX_MODE)
 0C87 3DFB00            cmp [X-5],0
 0C8A B00B              jnz L194
 0C8C 3DFC02            cmp [X-4],2
 0C8F B006              jnz L194
 0C91           X61:
 0C91                   .dbline 696
 0C91           ;       {
 0C91                   .dbline 697
 0C91           ;               UnloadConfig_receiver_config();
 0C91 7C0000            xcall _UnloadConfig_receiver_config
 0C94                   .dbline 698
 0C94           ;       }
 0C94 800E              xjmp L195
 0C96           L194:
 0C96                   .dbline 699
 0C96           ;       else if(config_num == TX_MODE)
 0C96 3DFB00            cmp [X-5],0
 0C99 B009              jnz L196
 0C9B 3DFC03            cmp [X-4],3
 0C9E B004              jnz L196
 0CA0           X62:
 0CA0                   .dbline 700
 0CA0           ;       {
 0CA0                   .dbline 701
 0CA0           ;               UnloadConfig_transmitter_config();
 0CA0 7C0000            xcall _UnloadConfig_transmitter_config
 0CA3                   .dbline 702
 0CA3           ;       }
 0CA3           L196:
 0CA3           L195:
 0CA3           L193:
 0CA3                   .dbline -2
 0CA3           L191:
 0CA3 20                pop X
 0CA4                   .dbline 0 ; func end
 0CA4 7F                ret
 0CA5                   .dbsym l config_num -5 I
 0CA5                   .dbend
 0CA5                   .dbfunc e initializeChildren _initializeChildren fV
 0CA5           ;              i -> X+4
 0CA5           ;        currVal -> X+2
 0CA5           ;        maxPrev -> X+0
 0CA5           _initializeChildren::
 0CA5                   .dbline -1
 0CA5 10                push X
 0CA6 4F                mov X,SP
 0CA7 3806              add SP,6
 0CA9                   .dbline 706
 0CA9           ; }
 0CA9           ; 
 0CA9           ; void initializeChildren(void)
 0CA9           ; {
 0CA9                   .dbline 707
 0CA9           ;       int maxPrev = 0;        // The maximum previous value.
 0CA9 560100            mov [X+1],0
 0CAC 560000            mov [X+0],0
 0CAF                   .dbline 709
 0CAF           ;       int currVal;            // The current number of modules found.
 0CAF           ;       int i = 0;                      // An int for looping.
 0CAF 560500            mov [X+5],0
 0CB2 560400            mov [X+4],0
 0CB5 8028              xjmp L200
 0CB7           L199:
 0CB7                   .dbline 716
 0CB7           ;       
 0CB7           ;       // Do nothing while we find nothing.
 0CB7           ;       //while(!initSweep()) { }
 0CB7           ;       
 0CB7           ;       // Find the maximum value of modules found, it's our number.
 0CB7           ;       while(maxPrev < PREV_NUM_MODULES)
 0CB7           ;       {
 0CB7                   .dbline 719
 0CB7           ;               //for(i = 0; i < NUM_SWEEPS; i++)
 0CB7           ;               //{
 0CB7           ;                       currVal = initSweep();
 0CB7 9063              xcall _initSweep
 0CB9 62D000            mov REG[0xd0],>__r0
 0CBC 5100              mov A,[__r1]
 0CBE 5403              mov [X+3],A
 0CC0 5100              mov A,[__r0]
 0CC2 5402              mov [X+2],A
 0CC4                   .dbline 721
 0CC4           ;                       
 0CC4           ;                       if(currVal > maxPrev)
 0CC4 5201              mov A,[X+1]
 0CC6 1303              sub A,[X+3]
 0CC8 5202              mov A,[X+2]
 0CCA 3180              xor A,-128
 0CCC 5300              mov [__rX],A
 0CCE 5200              mov A,[X+0]
 0CD0 3180              xor A,-128
 0CD2 1A00              sbb A,[__rX]
 0CD4 D009              jnc L202
 0CD6           X63:
 0CD6                   .dbline 722
 0CD6           ;                       {
 0CD6                   .dbline 723
 0CD6           ;                               maxPrev = currVal;
 0CD6 5203              mov A,[X+3]
 0CD8 5401              mov [X+1],A
 0CDA 5202              mov A,[X+2]
 0CDC 5400              mov [X+0],A
 0CDE                   .dbline 724
 0CDE           ;                       }
 0CDE           L202:
 0CDE                   .dbline 726
 0CDE           ;               //}
 0CDE           ;       }
 0CDE           L200:
 0CDE                   .dbline 715
 0CDE 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0CE1 5201              mov A,[X+1]
 0CE3 1201              sub A,[_PREV_NUM_MODULES+1]
 0CE5 5100              mov A,[_PREV_NUM_MODULES]
 0CE7 3180              xor A,-128
 0CE9 62D000            mov REG[0xd0],>__r0
 0CEC 5300              mov [__rX],A
 0CEE 5200              mov A,[X+0]
 0CF0 3180              xor A,-128
 0CF2 1A00              sbb A,[__rX]
 0CF4 CFC2              jc L199
 0CF6           X64:
 0CF6                   .dbline 735
 0CF6           ;       
 0CF6           ;       // Sweep until we get the max number again.
 0CF6           ; //    if(currVal != maxPrev)
 0CF6           ; //    {
 0CF6           ; //            while(initSweep() != maxPrev) { }
 0CF6           ; //    }
 0CF6           ;       
 0CF6           ;       // Store the number of modules.
 0CF6           ;       NUM_MODULES = maxPrev;
 0CF6 62D000            mov REG[0xd0],>_NUM_MODULES
 0CF9 5201              mov A,[X+1]
 0CFB 5301              mov [_NUM_MODULES+1],A
 0CFD 5200              mov A,[X+0]
 0CFF 5300              mov [_NUM_MODULES],A
 0D01                   .dbline 736
 0D01           ;       PREV_NUM_MODULES = NUM_MODULES;
 0D01 5101              mov A,[_NUM_MODULES+1]
 0D03 08                push A
 0D04 5100              mov A,[_NUM_MODULES]
 0D06 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0D09 5300              mov [_PREV_NUM_MODULES],A
 0D0B 18                pop A
 0D0C 5301              mov [_PREV_NUM_MODULES+1],A
 0D0E                   .dbline 739
 0D0E           ;       
 0D0E           ;       // Switch back to PC mode.
 0D0E           ;       configToggle(PC_MODE);
 0D0E 5000              mov A,0
 0D10 08                push A
 0D11 5001              mov A,1
 0D13 08                push A
 0D14 9E95              xcall _configToggle
 0D16 38FE              add SP,-2
 0D18                   .dbline -2
 0D18           L198:
 0D18 38FA              add SP,-6
 0D1A 20                pop X
 0D1B                   .dbline 0 ; func end
 0D1B 7F                ret
 0D1C                   .dbsym l i 4 I
 0D1C                   .dbsym l currVal 2 I
 0D1C                   .dbsym l maxPrev 0 I
 0D1C                   .dbend
 0D1C                   .dbfunc e initSweep _initSweep fI
 0D1C           ;     ping_tries -> X+6
 0D1C           ;              i -> X+4
 0D1C           ;   num_timeouts -> X+2
 0D1C           ; currNumModules -> X+0
 0D1C           _initSweep::
 0D1C                   .dbline -1
 0D1C 10                push X
 0D1D 4F                mov X,SP
 0D1E 3808              add SP,8
 0D20                   .dbline 743
 0D20           ; }
 0D20           ; 
 0D20           ; int initSweep(void)
 0D20           ; {
 0D20                   .dbline 744
 0D20           ;       int i = 0;                                      // An iterator for looping.
 0D20 560500            mov [X+5],0
 0D23 560400            mov [X+4],0
 0D26                   .dbline 745
 0D26           ;       int num_timeouts = 0;           // The number of consecutive timeouts.
 0D26 560300            mov [X+3],0
 0D29 560200            mov [X+2],0
 0D2C                   .dbline 746
 0D2C           ;       int ping_tries = 5;                     // The number of times to try a ping on an unregistered module.
 0D2C 560705            mov [X+7],5
 0D2F 560600            mov [X+6],0
 0D32                   .dbline 747
 0D32           ;       int currNumModules = 0;         // The number of modules found in this current sweep.
 0D32 560100            mov [X+1],0
 0D35 560000            mov [X+0],0
 0D38                   .dbline 750
 0D38           ;       
 0D38           ;       // Clear the modules.
 0D38           ;       clearConfig();
 0D38 7C019D            xcall _clearConfig
 0D3B 8079              xjmp L206
 0D3D           L205:
 0D3D                   .dbline 755
 0D3D           ;       
 0D3D           ;       // This loop continuously probes and listens at intervals
 0D3D           ;       // set by the RX_TIMEOUT_DURATION variable.
 0D3D           ;       while(num_timeouts < MAX_TIMEOUTS)
 0D3D           ;       {
 0D3D                   .dbline 757
 0D3D           ;               // If we are not maxed out on modules, look for more.
 0D3D           ;               if(currNumModules < SUGGESTED_NUM_MODULES)
 0D3D 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0D40 5201              mov A,[X+1]
 0D42 1201              sub A,[_SUGGESTED_NUM_MODULES+1]
 0D44 5100              mov A,[_SUGGESTED_NUM_MODULES]
 0D46 3180              xor A,-128
 0D48 62D000            mov REG[0xd0],>__r0
 0D4B 5300              mov [__rX],A
 0D4D 5200              mov A,[X+0]
 0D4F 3180              xor A,-128
 0D51 1A00              sbb A,[__rX]
 0D53 D006              jnc L208
 0D55           X65:
 0D55                   .dbline 758
 0D55           ;               {
 0D55                   .dbline 759
 0D55           ;                       sayHello();
 0D55 7C0209            xcall _sayHello
 0D58                   .dbline 760
 0D58           ;               }
 0D58 8007              xjmp L209
 0D5A           L208:
 0D5A                   .dbline 762
 0D5A           ;               else
 0D5A           ;               {
 0D5A                   .dbline 763
 0D5A           ;                       num_timeouts = MAX_TIMEOUTS;
 0D5A 560332            mov [X+3],50
 0D5D 560200            mov [X+2],0
 0D60                   .dbline 764
 0D60           ;               }
 0D60           L209:
 0D60                   .dbline 766
 0D60           ;                       
 0D60           ;               if(validResponse())
 0D60 7C0266            xcall _validResponse
 0D63 62D000            mov REG[0xd0],>__r0
 0D66 3C0000            cmp [__r0],0
 0D69 B006              jnz X66
 0D6B 3C0000            cmp [__r1],0
 0D6E A041              jz L210
 0D70           X66:
 0D70                   .dbline 767
 0D70           ;               {
 0D70                   .dbline 768
 0D70           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0D70 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0D73 3C00C8            cmp [_COMMAND_TYPE],-56
 0D76 B03E              jnz L211
 0D78                   .dbline 769
 0D78           ;                       {
 0D78                   .dbline 771
 0D78           ;                               // If this is for me, assign them an ID.
 0D78           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0D78 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D7B 3C0000            cmp [_COMMAND_DESTINATION],0
 0D7E B036              jnz L211
 0D80                   .dbline 772
 0D80           ;                               {
 0D80                   .dbline 773
 0D80           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D80 560300            mov [X+3],0
 0D83 560200            mov [X+2],0
 0D86                   .dbline 775
 0D86           ;               
 0D86           ;                                       if(assignID(currNumModules+1))
 0D86 62D000            mov REG[0xd0],>__r0
 0D89 5201              mov A,[X+1]
 0D8B 0101              add A,1
 0D8D 5300              mov [__r1],A
 0D8F 5200              mov A,[X+0]
 0D91 0900              adc A,0
 0D93 08                push A
 0D94 5100              mov A,[__r1]
 0D96 08                push A
 0D97 7C00EE            xcall _assignID
 0D9A 38FE              add SP,-2
 0D9C 62D000            mov REG[0xd0],>__r0
 0D9F 3C0000            cmp [__r0],0
 0DA2 B006              jnz X67
 0DA4 3C0000            cmp [__r1],0
 0DA7 A00D              jz L211
 0DA9           X67:
 0DA9                   .dbline 776
 0DA9           ;                                       {
 0DA9                   .dbline 777
 0DA9           ;                                               currNumModules++;               // Increment the number of modules connected.
 0DA9 7701              inc [X+1]
 0DAB 0F0000            adc [X+0],0
 0DAE                   .dbline 778
 0DAE           ;                                       }
 0DAE                   .dbline 779
 0DAE           ;                               }
 0DAE                   .dbline 780
 0DAE           ;                       }
 0DAE                   .dbline 781
 0DAE           ;               }
 0DAE 8006              xjmp L211
 0DB0           L210:
 0DB0                   .dbline 783
 0DB0           ;               else
 0DB0           ;               {       
 0DB0                   .dbline 784
 0DB0           ;                       num_timeouts++;
 0DB0 7703              inc [X+3]
 0DB2 0F0200            adc [X+2],0
 0DB5                   .dbline 785
 0DB5           ;               }
 0DB5           L211:
 0DB5                   .dbline 786
 0DB5           ;       }
 0DB5           L206:
 0DB5                   .dbline 754
 0DB5 5203              mov A,[X+3]
 0DB7 1132              sub A,50
 0DB9 5202              mov A,[X+2]
 0DBB 3180              xor A,-128
 0DBD 1980              sbb A,(0 ^ 0x80)
 0DBF CF7D              jc L205
 0DC1           X68:
 0DC1                   .dbline 789
 0DC1           ;       
 0DC1           ;       // If we didn't find any new modules, check to see if some already exist.
 0DC1           ;       if(!currNumModules)
 0DC1 3D0000            cmp [X+0],0
 0DC4 B056              jnz L218
 0DC6 3D0100            cmp [X+1],0
 0DC9 B051              jnz L218
 0DCB           X69:
 0DCB                   .dbline 790
 0DCB           ;       {
 0DCB                   .dbline 792
 0DCB           ;               // Try to ping the next module up from our current number ping_tries times.
 0DCB           ;               for(i = 0; i < ping_tries; i++)
 0DCB 560500            mov [X+5],0
 0DCE 560400            mov [X+4],0
 0DD1 8034              xjmp L223
 0DD3           L220:
 0DD3                   .dbline 793
 0DD3           ;               {       
 0DD3                   .dbline 794
 0DD3           ;                       if(pingModule(currNumModules+1))
 0DD3 62D000            mov REG[0xd0],>__r0
 0DD6 5201              mov A,[X+1]
 0DD8 0101              add A,1
 0DDA 5300              mov [__r1],A
 0DDC 5200              mov A,[X+0]
 0DDE 0900              adc A,0
 0DE0 08                push A
 0DE1 5100              mov A,[__r1]
 0DE3 08                push A
 0DE4 7C0046            xcall _pingModule
 0DE7 38FE              add SP,-2
 0DE9 62D000            mov REG[0xd0],>__r0
 0DEC 3C0000            cmp [__r0],0
 0DEF B006              jnz X70
 0DF1 3C0000            cmp [__r1],0
 0DF4 A00C              jz L224
 0DF6           X70:
 0DF6                   .dbline 795
 0DF6           ;                       {
 0DF6                   .dbline 796
 0DF6           ;                               currNumModules++;
 0DF6 7701              inc [X+1]
 0DF8 0F0000            adc [X+0],0
 0DFB                   .dbline 797
 0DFB           ;                               i = 0;
 0DFB 560500            mov [X+5],0
 0DFE 560400            mov [X+4],0
 0E01                   .dbline 798
 0E01           ;                       }
 0E01           L224:
 0E01                   .dbline 799
 0E01           ;               }
 0E01           L221:
 0E01                   .dbline 792
 0E01 7705              inc [X+5]
 0E03 0F0400            adc [X+4],0
 0E06           L223:
 0E06                   .dbline 792
 0E06 5205              mov A,[X+5]
 0E08 1307              sub A,[X+7]
 0E0A 5206              mov A,[X+6]
 0E0C 3180              xor A,-128
 0E0E 62D000            mov REG[0xd0],>__r0
 0E11 5300              mov [__rX],A
 0E13 5204              mov A,[X+4]
 0E15 3180              xor A,-128
 0E17 1A00              sbb A,[__rX]
 0E19 CFB9              jc L220
 0E1B           X71:
 0E1B                   .dbline 800
 0E1B           ;       }
 0E1B           L218:
 0E1B                   .dbline 802
 0E1B           ;       
 0E1B           ;       return currNumModules;
 0E1B 62D000            mov REG[0xd0],>__r0
 0E1E 5201              mov A,[X+1]
 0E20 5300              mov [__r1],A
 0E22 5200              mov A,[X+0]
 0E24 5300              mov [__r0],A
 0E26                   .dbline -2
 0E26           L204:
 0E26 38F8              add SP,-8
 0E28 20                pop X
 0E29                   .dbline 0 ; func end
 0E29 7F                ret
 0E2A                   .dbsym l ping_tries 6 I
 0E2A                   .dbsym l i 4 I
 0E2A                   .dbsym l num_timeouts 2 I
 0E2A                   .dbsym l currNumModules 0 I
 0E2A                   .dbend
 0E2A                   .dbfunc e xmitWait _xmitWait fV
 0E2A           ;              i -> X+0
 0E2A           _xmitWait::
 0E2A                   .dbline -1
 0E2A 10                push X
 0E2B 4F                mov X,SP
 0E2C 3802              add SP,2
 0E2E                   .dbline 806
 0E2E           ; }
 0E2E           ; 
 0E2E           ; void xmitWait(void)
 0E2E           ; {
 0E2E                   .dbline 809
 0E2E           ;       int i;
 0E2E           ;       
 0E2E           ;       for(i = 0; i < 25; i++)
 0E2E 560100            mov [X+1],0
 0E31 560000            mov [X+0],0
 0E34           L227:
 0E34                   .dbline 810
 0E34           ;       {
 0E34                   .dbline 812
 0E34           ;               // Sit here and spin for about 50 microseconds.
 0E34           ;       }
 0E34           L228:
 0E34                   .dbline 809
 0E34 7701              inc [X+1]
 0E36 0F0000            adc [X+0],0
 0E39                   .dbline 809
 0E39 5201              mov A,[X+1]
 0E3B 1119              sub A,25
 0E3D 5200              mov A,[X+0]
 0E3F 3180              xor A,-128
 0E41 1980              sbb A,(0 ^ 0x80)
 0E43 CFF0              jc L227
 0E45           X72:
 0E45                   .dbline -2
 0E45           L226:
 0E45 38FE              add SP,-2
 0E47 20                pop X
 0E48                   .dbline 0 ; func end
 0E48 7F                ret
 0E49                   .dbsym l i 0 I
 0E49                   .dbend
 0E49                   .dbfunc e txConfigWait _txConfigWait fV
 0E49           _txConfigWait::
 0E49                   .dbline -1
 0E49                   .dbline 816
 0E49           ; }
 0E49           ; 
 0E49           ; void txConfigWait(void)
 0E49           ; {
 0E49                   .dbline 817
 0E49           ;       TX_TIMEOUT_Start();             // Start the timer.
 0E49 10                push X
 0E4A 7C0000            xcall _TX_TIMEOUT_Start
 0E4D 20                pop X
 0E4E           L232:
 0E4E                   .dbline 820
 0E4E           ;               
 0E4E           ;       while(!TIMEOUT)
 0E4E           ;       {
 0E4E                   .dbline 823
 0E4E           ;               // Do nothing while we wait for one timeout period.
 0E4E           ;               // This is to allow everyone to get in the right configuration.
 0E4E           ;       }
 0E4E           L233:
 0E4E                   .dbline 819
 0E4E 62D000            mov REG[0xd0],>_TIMEOUT
 0E51 3C0000            cmp [_TIMEOUT],0
 0E54 B006              jnz X73
 0E56 3C0100            cmp [_TIMEOUT+1],0
 0E59 AFF4              jz L232
 0E5B           X73:
 0E5B                   .dbline 825
 0E5B           ;       
 0E5B           ;       TX_TIMEOUT_Stop();              // Stop the timer.
 0E5B 10                push X
 0E5C 7C0000            xcall _TX_TIMEOUT_Stop
 0E5F 20                pop X
 0E60                   .dbline 826
 0E60           ;       TIMEOUT = 0;                    // Reset the timeout flag.
 0E60 62D000            mov REG[0xd0],>_TIMEOUT
 0E63 550100            mov [_TIMEOUT+1],0
 0E66 550000            mov [_TIMEOUT],0
 0E69                   .dbline -2
 0E69           L231:
 0E69                   .dbline 0 ; func end
 0E69 7F                ret
 0E6A                   .dbend
 0E6A                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0E6A           _TX_TIMEOUT_ISR::
 0E6A                   .dbline -1
 0E6A 71C0              or F,-64
 0E6C 08                push A
 0E6D 5DD0              mov A,REG[0xd0]
 0E6F 08                push A
 0E70                   .dbline 830
 0E70           ; }
 0E70           ; 
 0E70           ; void TX_TIMEOUT_ISR(void)
 0E70           ; {     
 0E70                   .dbline 831
 0E70           ;       TIMEOUT++;
 0E70 62D000            mov REG[0xd0],>_TIMEOUT
 0E73 7601              inc [_TIMEOUT+1]
 0E75 0E0000            adc [_TIMEOUT],0
 0E78                   .dbline 833
 0E78           ;       
 0E78           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0E78 62DAFD            mov REG[0xda],-3
 0E7B                   .dbline -2
 0E7B           L235:
 0E7B 18                pop A
 0E7C 60D0              mov REG[208],A
 0E7E 18                pop A
 0E7F                   .dbline 0 ; func end
 0E7F 7E                reti
 0E80                   .dbend
 0E80                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0E80           _RX_TIMEOUT_ISR::
 0E80                   .dbline -1
 0E80 71C0              or F,-64
 0E82 08                push A
 0E83 5DD0              mov A,REG[0xd0]
 0E85 08                push A
 0E86                   .dbline 837
 0E86           ; }
 0E86           ; 
 0E86           ; void RX_TIMEOUT_ISR(void)
 0E86           ; {     
 0E86                   .dbline 838
 0E86           ;       TIMEOUT++;
 0E86 62D000            mov REG[0xd0],>_TIMEOUT
 0E89 7601              inc [_TIMEOUT+1]
 0E8B 0E0000            adc [_TIMEOUT],0
 0E8E                   .dbline 840
 0E8E           ;       
 0E8E           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0E8E 62DAFD            mov REG[0xda],-3
 0E91                   .dbline -2
 0E91           L236:
 0E91 18                pop A
 0E92 60D0              mov REG[208],A
 0E94 18                pop A
 0E95                   .dbline 0 ; func end
 0E95 7E                reti
 0E96                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _SUGGESTED_NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e SUGGESTED_NUM_MODULES _SUGGESTED_NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PREV_NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e PREV_NUM_MODULES _PREV_NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
