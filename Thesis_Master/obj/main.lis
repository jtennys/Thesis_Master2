 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 100
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"
 0000           ; #include <stdlib.h>
 0000           ; #include <string.h>
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (2)
 0000           ; #define               RX_MODE                                         (1)
 0000           ; #define               TX_MODE                                         (0)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR                                           (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (3)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; #define               SERVO_FIND_TIME                         (24)    // The wait time after issuing clear config.
 0000           ; 
 0000           ; #define               MAX_TIMEOUTS                            (5)             // Number of timeouts allowed before hello mode exit.
 0000           ; #define               NUM_SWEEPS                                      (5)             // The number of module sweeps to do at init.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (9)
 0000           ; 
 0000           ; #define               SERVO_START                                     (255)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; 
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; 
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; 
 0000           ; int validTransmission(void);
 0000           ; 
 0000           ; void decodeTransmission(void);
 0000           ; 
 0000           ; 
 0000           ; void sayHello(void);
 0000           ; 
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; 
 0000           ; void clearConfig(void);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeSlaves(void);
 0000           ; int initSweep(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; 
 0000           ; // This flag is set if there is a timeout.
 0000           ; int TIMEOUT;
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; int PREV_NUM_MODULES;         // Stores the previous number of modules that has been discovered.
 0000           ; int SUGGESTED_NUM_MODULES;    // Stores the module number that is suggested from the PC.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 102
 0000           ;       // Initialize the number of modules.
 0000           ;       NUM_MODULES = 0;
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 103
 0009           ;       PREV_NUM_MODULES = 1;
 0009 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 000C 550101            mov [_PREV_NUM_MODULES+1],1
 000F 550000            mov [_PREV_NUM_MODULES],0
 0012                   .dbline 104
 0012           ;       SUGGESTED_NUM_MODULES = MAX_MODULES;
 0012 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0015 550109            mov [_SUGGESTED_NUM_MODULES+1],9
 0018 550000            mov [_SUGGESTED_NUM_MODULES],0
 001B                   .dbline 107
 001B           ;       
 001B           ;       // Activate GPIO ISR.
 001B           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 001B 43E020            or REG[0xe0],32
 001E                   .dbline 110
 001E           ;       
 001E           ;       // Turn on global interrupts for the transmission timeout timer.
 001E           ;       M8C_EnableGInt;
 001E 7101                      or  F, 01h
 0020           
 0020 8021              xjmp L3
 0022           L2:
 0022                   .dbline 113
 0022           ;       
 0022           ;       while(1)
 0022           ;       {
 0022                   .dbline 114
 0022           ;               if(!NUM_MODULES)
 0022 62D000            mov REG[0xd0],>_NUM_MODULES
 0025 3C0000            cmp [_NUM_MODULES],0
 0028 B00B              jnz L5
 002A 3C0100            cmp [_NUM_MODULES+1],0
 002D B006              jnz L5
 002F           X1:
 002F                   .dbline 115
 002F           ;               {
 002F                   .dbline 116
 002F           ;                       initializeSlaves();
 002F 7C0CBC            xcall _initializeSlaves
 0032                   .dbline 117
 0032           ;               }
 0032 800F              xjmp L6
 0034           L5:
 0034                   .dbline 118
 0034           ;               else if(COMP_SERIAL_bCmdCheck())                // If there's a computer command, read it.
 0034 10                push X
 0035 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0038 62D000            mov REG[0xd0],>__r0
 003B 20                pop X
 003C 3900              cmp A,0
 003E A003              jz L7
 0040                   .dbline 119
 0040           ;               {
 0040                   .dbline 120
 0040           ;                       decodeTransmission();
 0040 932A              xcall _decodeTransmission
 0042                   .dbline 121
 0042           ;               }
 0042           L7:
 0042           L6:
 0042                   .dbline 122
 0042           ;       }
 0042           L3:
 0042                   .dbline 112
 0042 8FDF              xjmp L2
 0044           X0:
 0044                   .dbline -2
 0044           L1:
 0044                   .dbline 0 ; func end
 0044 8FFF              jmp .
 0046                   .dbend
 0046                   .dbfunc e pingModule _pingModule fI
 0046           ;       response -> X+0
 0046           ;      module_id -> X-5
 0046           _pingModule::
 0046                   .dbline -1
 0046 10                push X
 0047 4F                mov X,SP
 0048 3802              add SP,2
 004A                   .dbline 126
 004A           ; }
 004A           ; 
 004A           ; int pingModule(int module_id)
 004A           ; {
 004A                   .dbline 127
 004A           ;       int response = 0;
 004A 560100            mov [X+1],0
 004D 560000            mov [X+0],0
 0050                   .dbline 129
 0050           ;       
 0050           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0050 5000              mov A,0
 0052 08                push A
 0053 08                push A
 0054 7C0BA4            xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 132
 0059           ;                       
 0059           ;       // Transmit a hello.
 0059           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TRANSMIT_PutChar
 005F 20                pop X
 0060                   .dbline 133
 0060           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TRANSMIT_PutChar
 0066 20                pop X
 0067                   .dbline 134
 0067           ;       TRANSMIT_PutChar(MASTER_ID);
 0067 10                push X
 0068 5000              mov A,0
 006A 7C0000            xcall _TRANSMIT_PutChar
 006D 20                pop X
 006E                   .dbline 135
 006E           ;       TRANSMIT_PutChar(module_id);
 006E 62D000            mov REG[0xd0],>__r0
 0071 52FC              mov A,[X-4]
 0073 10                push X
 0074 7C0000            xcall _TRANSMIT_PutChar
 0077 20                pop X
 0078                   .dbline 136
 0078           ;       TRANSMIT_PutChar(PING);
 0078 10                push X
 0079 50CB              mov A,-53
 007B 7C0000            xcall _TRANSMIT_PutChar
 007E 20                pop X
 007F                   .dbline 137
 007F           ;       TRANSMIT_PutChar(END_TRANSMIT);
 007F 10                push X
 0080 50FD              mov A,-3
 0082 7C0000            xcall _TRANSMIT_PutChar
 0085 20                pop X
 0086                   .dbline 138
 0086           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0086 10                push X
 0087 50FD              mov A,-3
 0089 7C0000            xcall _TRANSMIT_PutChar
 008C 20                pop X
 008D           L10:
 008D                   .dbline 141
 008D           ;       
 008D           ;       // Wait for the transmission to finish.
 008D           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 008D           L11:
 008D                   .dbline 141
 008D 10                push X
 008E 7C0000            xcall _TRANSMIT_bReadTxStatus
 0091 62D000            mov REG[0xd0],>__r0
 0094 20                pop X
 0095 5300              mov [__r0],A
 0097 470020            tst [__r0],32
 009A AFF2              jz L10
 009C                   .dbline 143
 009C           ;       
 009C           ;       xmitWait();
 009C 7C0E41            xcall _xmitWait
 009F                   .dbline 145
 009F           ; 
 009F           ;       if(validTransmission())
 009F 91BE              xcall _validTransmission
 00A1 62D000            mov REG[0xd0],>__r0
 00A4 3C0000            cmp [__r0],0
 00A7 B006              jnz X2
 00A9 3C0000            cmp [__r1],0
 00AC A02D              jz L13
 00AE           X2:
 00AE                   .dbline 146
 00AE           ;       {
 00AE                   .dbline 147
 00AE           ;               if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00AE 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00B1 3C00CB            cmp [_COMMAND_TYPE],-53
 00B4 B025              jnz L15
 00B6                   .dbline 148
 00B6           ;               {
 00B6                   .dbline 150
 00B6           ;                       // If this is for me, check who it was from.
 00B6           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 00B6 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00B9 3C0000            cmp [_COMMAND_DESTINATION],0
 00BC B01D              jnz L17
 00BE                   .dbline 151
 00BE           ;                       {
 00BE                   .dbline 152
 00BE           ;                               if(COMMAND_SOURCE == module_id)
 00BE 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00C1 5100              mov A,[_COMMAND_SOURCE]
 00C3 62D000            mov REG[0xd0],>__r0
 00C6 5300              mov [__r1],A
 00C8 5000              mov A,0
 00CA 3BFB              cmp A,[X-5]
 00CC B00D              jnz L19
 00CE 5100              mov A,[__r1]
 00D0 3BFC              cmp A,[X-4]
 00D2 B007              jnz L19
 00D4           X3:
 00D4                   .dbline 153
 00D4           ;                               {
 00D4                   .dbline 154
 00D4           ;                                       response = 1;
 00D4 560101            mov [X+1],1
 00D7 560000            mov [X+0],0
 00DA                   .dbline 155
 00DA           ;                               }
 00DA           L19:
 00DA                   .dbline 156
 00DA           ;                       }
 00DA           L17:
 00DA                   .dbline 157
 00DA           ;               }
 00DA           L15:
 00DA                   .dbline 158
 00DA           ;       }
 00DA           L13:
 00DA                   .dbline 160
 00DA           ;       
 00DA           ;       return response;
 00DA 62D000            mov REG[0xd0],>__r0
 00DD 5201              mov A,[X+1]
 00DF 5300              mov [__r1],A
 00E1 5200              mov A,[X+0]
 00E3 5300              mov [__r0],A
 00E5                   .dbline -2
 00E5           L9:
 00E5 38FE              add SP,-2
 00E7 20                pop X
 00E8                   .dbline 0 ; func end
 00E8 7F                ret
 00E9                   .dbsym l response 0 I
 00E9                   .dbsym l module_id -5 I
 00E9                   .dbend
 00E9                   .dbfunc e assignID _assignID fI
 00E9           ;        success -> X+0
 00E9           ;    assigned_ID -> X-5
 00E9           _assignID::
 00E9                   .dbline -1
 00E9 10                push X
 00EA 4F                mov X,SP
 00EB 3802              add SP,2
 00ED                   .dbline 164
 00ED           ; }
 00ED           ; 
 00ED           ; int assignID(int assigned_ID)
 00ED           ; {
 00ED                   .dbline 165
 00ED           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 00ED 560100            mov [X+1],0
 00F0 560000            mov [X+0],0
 00F3                   .dbline 167
 00F3           ;       
 00F3           ;       configToggle(TX_MODE);  // Switch to TX mode.
 00F3 5000              mov A,0
 00F5 08                push A
 00F6 08                push A
 00F7 7C0BA4            xcall _configToggle
 00FA 38FE              add SP,-2
 00FC                   .dbline 170
 00FC           ; 
 00FC           ;       // Transmit the assignment.
 00FC           ;       TRANSMIT_PutChar(START_TRANSMIT);
 00FC 10                push X
 00FD 50FC              mov A,-4
 00FF 7C0000            xcall _TRANSMIT_PutChar
 0102 20                pop X
 0103                   .dbline 171
 0103           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0103 10                push X
 0104 50FC              mov A,-4
 0106 7C0000            xcall _TRANSMIT_PutChar
 0109 20                pop X
 010A                   .dbline 172
 010A           ;       TRANSMIT_PutChar(MASTER_ID);
 010A 10                push X
 010B 5000              mov A,0
 010D 7C0000            xcall _TRANSMIT_PutChar
 0110 20                pop X
 0111                   .dbline 173
 0111           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0111 10                push X
 0112 50FB              mov A,-5
 0114 7C0000            xcall _TRANSMIT_PutChar
 0117 20                pop X
 0118                   .dbline 174
 0118           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0118 10                push X
 0119 50C9              mov A,-55
 011B 7C0000            xcall _TRANSMIT_PutChar
 011E 20                pop X
 011F                   .dbline 175
 011F           ;       TRANSMIT_PutChar(assigned_ID);
 011F 62D000            mov REG[0xd0],>__r0
 0122 52FC              mov A,[X-4]
 0124 10                push X
 0125 7C0000            xcall _TRANSMIT_PutChar
 0128 20                pop X
 0129                   .dbline 176
 0129           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0129 10                push X
 012A 50FD              mov A,-3
 012C 7C0000            xcall _TRANSMIT_PutChar
 012F 20                pop X
 0130                   .dbline 177
 0130           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0130 10                push X
 0131 50FD              mov A,-3
 0133 7C0000            xcall _TRANSMIT_PutChar
 0136 20                pop X
 0137           L22:
 0137                   .dbline 180
 0137           ;       
 0137           ;       // Wait for the transmission to finish.
 0137           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0137           L23:
 0137                   .dbline 180
 0137 10                push X
 0138 7C0000            xcall _TRANSMIT_bReadTxStatus
 013B 62D000            mov REG[0xd0],>__r0
 013E 20                pop X
 013F 5300              mov [__r0],A
 0141 470020            tst [__r0],32
 0144 AFF2              jz L22
 0146                   .dbline 182
 0146           ;       
 0146           ;       xmitWait();
 0146 7C0E41            xcall _xmitWait
 0149                   .dbline 184
 0149           ;       
 0149           ;       if(validTransmission())
 0149 9114              xcall _validTransmission
 014B 62D000            mov REG[0xd0],>__r0
 014E 3C0000            cmp [__r0],0
 0151 B006              jnz X4
 0153 3C0000            cmp [__r1],0
 0156 A02D              jz L25
 0158           X4:
 0158                   .dbline 185
 0158           ;       {
 0158                   .dbline 186
 0158           ;               if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 0158 62D000            mov REG[0xd0],>_COMMAND_TYPE
 015B 3C00CA            cmp [_COMMAND_TYPE],-54
 015E B025              jnz L27
 0160                   .dbline 187
 0160           ;               {
 0160                   .dbline 189
 0160           ;                       // If this is for me, check who it was from.
 0160           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 0160 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0163 3C0000            cmp [_COMMAND_DESTINATION],0
 0166 B01D              jnz L29
 0168                   .dbline 190
 0168           ;                       {
 0168                   .dbline 191
 0168           ;                               if(COMMAND_SOURCE == assigned_ID)
 0168 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 016B 5100              mov A,[_COMMAND_SOURCE]
 016D 62D000            mov REG[0xd0],>__r0
 0170 5300              mov [__r1],A
 0172 5000              mov A,0
 0174 3BFB              cmp A,[X-5]
 0176 B00D              jnz L31
 0178 5100              mov A,[__r1]
 017A 3BFC              cmp A,[X-4]
 017C B007              jnz L31
 017E           X5:
 017E                   .dbline 192
 017E           ;                               {
 017E                   .dbline 193
 017E           ;                                       success = 1;
 017E 560101            mov [X+1],1
 0181 560000            mov [X+0],0
 0184                   .dbline 194
 0184           ;                               }
 0184           L31:
 0184                   .dbline 195
 0184           ;                       }
 0184           L29:
 0184                   .dbline 196
 0184           ;               }
 0184           L27:
 0184                   .dbline 197
 0184           ;       }
 0184           L25:
 0184                   .dbline 199
 0184           ;       
 0184           ;       return success;
 0184 62D000            mov REG[0xd0],>__r0
 0187 5201              mov A,[X+1]
 0189 5300              mov [__r1],A
 018B 5200              mov A,[X+0]
 018D 5300              mov [__r0],A
 018F                   .dbline -2
 018F           L21:
 018F 38FE              add SP,-2
 0191 20                pop X
 0192                   .dbline 0 ; func end
 0192 7F                ret
 0193                   .dbsym l success 0 I
 0193                   .dbsym l assigned_ID -5 I
 0193                   .dbend
 0193                   .dbfunc e clearConfig _clearConfig fV
 0193           ;       response -> X+0
 0193           _clearConfig::
 0193                   .dbline -1
 0193 10                push X
 0194 4F                mov X,SP
 0195 3802              add SP,2
 0197                   .dbline 203
 0197           ; }
 0197           ; 
 0197           ; void clearConfig(void)
 0197           ; {
 0197                   .dbline 204
 0197           ;       int response = 0;
 0197 560100            mov [X+1],0
 019A 560000            mov [X+0],0
 019D                   .dbline 206
 019D           ;       
 019D           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 019D 5000              mov A,0
 019F 08                push A
 01A0 08                push A
 01A1 7C0BA4            xcall _configToggle
 01A4 38FE              add SP,-2
 01A6                   .dbline 209
 01A6           ;                       
 01A6           ;       // Transmit a clear.
 01A6           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01A6 10                push X
 01A7 50FC              mov A,-4
 01A9 7C0000            xcall _TRANSMIT_PutChar
 01AC 20                pop X
 01AD                   .dbline 210
 01AD           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01AD 10                push X
 01AE 50FC              mov A,-4
 01B0 7C0000            xcall _TRANSMIT_PutChar
 01B3 20                pop X
 01B4                   .dbline 211
 01B4           ;       TRANSMIT_PutChar(MASTER_ID);
 01B4 10                push X
 01B5 5000              mov A,0
 01B7 7C0000            xcall _TRANSMIT_PutChar
 01BA 20                pop X
 01BB                   .dbline 212
 01BB           ;       TRANSMIT_PutChar(BROADCAST);
 01BB 10                push X
 01BC 50FE              mov A,-2
 01BE 7C0000            xcall _TRANSMIT_PutChar
 01C1 20                pop X
 01C2                   .dbline 213
 01C2           ;       TRANSMIT_PutChar(CLEAR);
 01C2 10                push X
 01C3 50CC              mov A,-52
 01C5 7C0000            xcall _TRANSMIT_PutChar
 01C8 20                pop X
 01C9                   .dbline 214
 01C9           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01C9 10                push X
 01CA 50FD              mov A,-3
 01CC 7C0000            xcall _TRANSMIT_PutChar
 01CF 20                pop X
 01D0                   .dbline 215
 01D0           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01D0 10                push X
 01D1 50FD              mov A,-3
 01D3 7C0000            xcall _TRANSMIT_PutChar
 01D6 20                pop X
 01D7           L34:
 01D7                   .dbline 218
 01D7           ;       
 01D7           ;       // Wait for the transmission to finish.
 01D7           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01D7           L35:
 01D7                   .dbline 218
 01D7 10                push X
 01D8 7C0000            xcall _TRANSMIT_bReadTxStatus
 01DB 62D000            mov REG[0xd0],>__r0
 01DE 20                pop X
 01DF 5300              mov [__r0],A
 01E1 470020            tst [__r0],32
 01E4 AFF2              jz L34
 01E6                   .dbline 220
 01E6           ;       
 01E6           ;       xmitWait();
 01E6 7C0E41            xcall _xmitWait
 01E9                   .dbline 223
 01E9           ;       
 01E9           ;       // Wait for servo find time.
 01E9           ;       configToggle(RX_MODE);
 01E9 5000              mov A,0
 01EB 08                push A
 01EC 5001              mov A,1
 01EE 08                push A
 01EF 7C0BA4            xcall _configToggle
 01F2 38FE              add SP,-2
 01F4           L37:
 01F4                   .dbline 224
 01F4           ;       while(TIMEOUT < SERVO_FIND_TIME) { }
 01F4                   .dbline 224
 01F4           L38:
 01F4                   .dbline 224
 01F4 62D000            mov REG[0xd0],>_TIMEOUT
 01F7 5101              mov A,[_TIMEOUT+1]
 01F9 1118              sub A,24
 01FB 5100              mov A,[_TIMEOUT]
 01FD 3180              xor A,-128
 01FF 1980              sbb A,(0 ^ 0x80)
 0201 CFF2              jc L37
 0203           X6:
 0203                   .dbline -2
 0203           L33:
 0203 38FE              add SP,-2
 0205 20                pop X
 0206                   .dbline 0 ; func end
 0206 7F                ret
 0207                   .dbsym l response 0 I
 0207                   .dbend
 0207                   .dbfunc e sayHello _sayHello fV
 0207           _sayHello::
 0207                   .dbline -1
 0207                   .dbline 229
 0207           ; }
 0207           ; 
 0207           ; // This function transmits a hello message.
 0207           ; void sayHello(void)
 0207           ; {
 0207                   .dbline 230
 0207           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 0207 5000              mov A,0
 0209 08                push A
 020A 08                push A
 020B 7C0BA4            xcall _configToggle
 020E 38FE              add SP,-2
 0210                   .dbline 233
 0210           ;                       
 0210           ;       // Transmit a hello.
 0210           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0210 10                push X
 0211 50FC              mov A,-4
 0213 7C0000            xcall _TRANSMIT_PutChar
 0216 20                pop X
 0217                   .dbline 234
 0217           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0217 10                push X
 0218 50FC              mov A,-4
 021A 7C0000            xcall _TRANSMIT_PutChar
 021D 20                pop X
 021E                   .dbline 235
 021E           ;       TRANSMIT_PutChar(MASTER_ID);
 021E 10                push X
 021F 5000              mov A,0
 0221 7C0000            xcall _TRANSMIT_PutChar
 0224 20                pop X
 0225                   .dbline 236
 0225           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0225 10                push X
 0226 50FB              mov A,-5
 0228 7C0000            xcall _TRANSMIT_PutChar
 022B 20                pop X
 022C                   .dbline 237
 022C           ;       TRANSMIT_PutChar(HELLO_BYTE);
 022C 10                push X
 022D 50C8              mov A,-56
 022F 7C0000            xcall _TRANSMIT_PutChar
 0232 20                pop X
 0233                   .dbline 238
 0233           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0233 10                push X
 0234 50FD              mov A,-3
 0236 7C0000            xcall _TRANSMIT_PutChar
 0239 20                pop X
 023A                   .dbline 239
 023A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 023A 10                push X
 023B 50FD              mov A,-3
 023D 7C0000            xcall _TRANSMIT_PutChar
 0240 20                pop X
 0241           L41:
 0241                   .dbline 242
 0241           ;       
 0241           ;       // Wait for the transmission to finish.
 0241           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0241           L42:
 0241                   .dbline 242
 0241 10                push X
 0242 7C0000            xcall _TRANSMIT_bReadTxStatus
 0245 62D000            mov REG[0xd0],>__r0
 0248 20                pop X
 0249 5300              mov [__r0],A
 024B 470020            tst [__r0],32
 024E AFF2              jz L41
 0250                   .dbline 244
 0250           ;       
 0250           ;       xmitWait();
 0250 7C0E41            xcall _xmitWait
 0253                   .dbline 246
 0253           ;       
 0253           ;       configToggle(RX_MODE);                          // Listen for the response.
 0253 5000              mov A,0
 0255 08                push A
 0256 5001              mov A,1
 0258 08                push A
 0259 7C0BA4            xcall _configToggle
 025C 38FE              add SP,-2
 025E                   .dbline -2
 025E           L40:
 025E                   .dbline 0 ; func end
 025E 7F                ret
 025F                   .dbend
 025F                   .dbfunc e validTransmission _validTransmission fI
 025F           ; valid_transmit -> X+3
 025F           ;              i -> X+1
 025F           ;       tempByte -> X+0
 025F           _validTransmission::
 025F                   .dbline -1
 025F 10                push X
 0260 4F                mov X,SP
 0261 3805              add SP,5
 0263                   .dbline 251
 0263           ; }
 0263           ; 
 0263           ; // This function returns whether or not a valid transmission has been received.
 0263           ; int validTransmission(void)
 0263           ; {
 0263                   .dbline 252
 0263           ;       int valid_transmit = 0;
 0263 560400            mov [X+4],0
 0266 560300            mov [X+3],0
 0269                   .dbline 253
 0269           ;       int i = 0;
 0269 560200            mov [X+2],0
 026C 560100            mov [X+1],0
 026F                   .dbline 254
 026F           ;       char tempByte = 0;
 026F 560000            mov [X+0],0
 0272                   .dbline 256
 0272           ;       
 0272           ;       configToggle(RX_MODE);  // Listen for the response.
 0272 5000              mov A,0
 0274 08                push A
 0275 5001              mov A,1
 0277 08                push A
 0278 7C0BA4            xcall _configToggle
 027B 38FE              add SP,-2
 027D 80C2              xjmp L46
 027F           L45:
 027F                   .dbline 259
 027F           ;       
 027F           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 027F           ;       {
 027F                   .dbline 260
 027F           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 027F 10                push X
 0280 7C0000            xcall _RECEIVE_cReadChar
 0283 62D000            mov REG[0xd0],>__r0
 0286 20                pop X
 0287 39FC              cmp A,-4
 0289 B0B6              jnz L48
 028B                   .dbline 261
 028B           ;               {
 028B 80A5              xjmp L51
 028D           L50:
 028D                   .dbline 263
 028D           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 028D           ;                       {
 028D                   .dbline 264
 028D           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 028D 10                push X
 028E 7C0000            xcall _RECEIVE_cReadChar
 0291 62D000            mov REG[0xd0],>__r0
 0294 20                pop X
 0295 39FC              cmp A,-4
 0297 B099              jnz L53
 0299                   .dbline 265
 0299           ;                               {
 0299 8088              xjmp L56
 029B           L55:
 029B                   .dbline 267
 029B           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 029B           ;                                       {
 029B                   .dbline 268
 029B           ;                                               if(tempByte = RECEIVE_cReadChar())
 029B 10                push X
 029C 7C0000            xcall _RECEIVE_cReadChar
 029F 20                pop X
 02A0 5400              mov [X+0],A
 02A2 3900              cmp A,0
 02A4 A07D              jz L58
 02A6                   .dbline 269
 02A6           ;                                               {
 02A6                   .dbline 270
 02A6           ;                                                       COMMAND_SOURCE = tempByte;
 02A6 5200              mov A,[X+0]
 02A8 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02AB 5300              mov [_COMMAND_SOURCE],A
 02AD 8065              xjmp L61
 02AF           L60:
 02AF                   .dbline 273
 02AF           ;                                                       
 02AF           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02AF           ;                                                       {
 02AF                   .dbline 274
 02AF           ;                                                               if(tempByte = RECEIVE_cReadChar())
 02AF 10                push X
 02B0 7C0000            xcall _RECEIVE_cReadChar
 02B3 62D000            mov REG[0xd0],>__r0
 02B6 20                pop X
 02B7 5400              mov [X+0],A
 02B9 3900              cmp A,0
 02BB A057              jz L63
 02BD                   .dbline 275
 02BD           ;                                                               {
 02BD                   .dbline 276
 02BD           ;                                                                       if(tempByte >= HELLO_BYTE)
 02BD 3D00C8            cmp [X+0],-56
 02C0 C052              jc L65
 02C2           X7:
 02C2                   .dbline 277
 02C2           ;                                                                       {
 02C2                   .dbline 278
 02C2           ;                                                                               COMMAND_TYPE = tempByte;
 02C2 5200              mov A,[X+0]
 02C4 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02C7 5300              mov [_COMMAND_TYPE],A
 02C9 803A              xjmp L68
 02CB           L67:
 02CB                   .dbline 281
 02CB           ;                                                                               
 02CB           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 02CB           ;                                                                               {
 02CB                   .dbline 282
 02CB           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 02CB 10                push X
 02CC 7C0000            xcall _RECEIVE_cReadChar
 02CF 62D000            mov REG[0xd0],>__r0
 02D2 20                pop X
 02D3 5400              mov [X+0],A
 02D5 3900              cmp A,0
 02D7 A02C              jz L70
 02D9                   .dbline 283
 02D9           ;                                                                                       {
 02D9                   .dbline 284
 02D9           ;                                                                                               if(tempByte != END_TRANSMIT)
 02D9 3D00FD            cmp [X+0],-3
 02DC A018              jz L72
 02DE                   .dbline 285
 02DE           ;                                                                                               {
 02DE                   .dbline 286
 02DE           ;                                                                                                       PARAM[i] = tempByte;
 02DE 5202              mov A,[X+2]
 02E0 0100              add A,<_PARAM
 02E2 5300              mov [__r1],A
 02E4 5201              mov A,[X+1]
 02E6 0900              adc A,>_PARAM
 02E8 60D5              mov REG[0xd5],A
 02EA 5200              mov A,[X+0]
 02EC 3F00              mvi [__r1],A
 02EE                   .dbline 287
 02EE           ;                                                                                                       i++;
 02EE 7702              inc [X+2]
 02F0 0F0100            adc [X+1],0
 02F3                   .dbline 288
 02F3           ;                                                                                               }
 02F3 8010              xjmp L73
 02F5           L72:
 02F5                   .dbline 290
 02F5           ;                                                                                               else
 02F5           ;                                                                                               {
 02F5                   .dbline 291
 02F5           ;                                                                                                       valid_transmit = 1;
 02F5 560401            mov [X+4],1
 02F8 560300            mov [X+3],0
 02FB                   .dbline 292
 02FB           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 02FB 62D000            mov REG[0xd0],>_TIMEOUT
 02FE 550103            mov [_TIMEOUT+1],3
 0301 550000            mov [_TIMEOUT],0
 0304                   .dbline 293
 0304           ;                                                                                               }
 0304           L73:
 0304                   .dbline 294
 0304           ;                                                                                       }
 0304           L70:
 0304                   .dbline 295
 0304           ;                                                                               }
 0304           L68:
 0304                   .dbline 280
 0304 62D000            mov REG[0xd0],>_TIMEOUT
 0307 5101              mov A,[_TIMEOUT+1]
 0309 1103              sub A,3
 030B 5100              mov A,[_TIMEOUT]
 030D 3180              xor A,-128
 030F 1980              sbb A,(0 ^ 0x80)
 0311 CFB9              jc L67
 0313           X8:
 0313                   .dbline 296
 0313           ;                                                                       }
 0313           L65:
 0313                   .dbline 297
 0313           ;                                                               }
 0313           L63:
 0313                   .dbline 298
 0313           ;                                                       }
 0313           L61:
 0313                   .dbline 272
 0313 62D000            mov REG[0xd0],>_TIMEOUT
 0316 5101              mov A,[_TIMEOUT+1]
 0318 1103              sub A,3
 031A 5100              mov A,[_TIMEOUT]
 031C 3180              xor A,-128
 031E 1980              sbb A,(0 ^ 0x80)
 0320 CF8E              jc L60
 0322           X9:
 0322                   .dbline 299
 0322           ;                                               }
 0322           L58:
 0322                   .dbline 300
 0322           ;                                       }
 0322           L56:
 0322                   .dbline 266
 0322 62D000            mov REG[0xd0],>_TIMEOUT
 0325 5101              mov A,[_TIMEOUT+1]
 0327 1103              sub A,3
 0329 5100              mov A,[_TIMEOUT]
 032B 3180              xor A,-128
 032D 1980              sbb A,(0 ^ 0x80)
 032F CF6B              jc L55
 0331           X10:
 0331                   .dbline 301
 0331           ;                               }
 0331           L53:
 0331                   .dbline 302
 0331           ;                       }
 0331           L51:
 0331                   .dbline 262
 0331 62D000            mov REG[0xd0],>_TIMEOUT
 0334 5101              mov A,[_TIMEOUT+1]
 0336 1103              sub A,3
 0338 5100              mov A,[_TIMEOUT]
 033A 3180              xor A,-128
 033C 1980              sbb A,(0 ^ 0x80)
 033E CF4E              jc L50
 0340           X11:
 0340                   .dbline 303
 0340           ;               }
 0340           L48:
 0340                   .dbline 304
 0340           ;       }
 0340           L46:
 0340                   .dbline 258
 0340 62D000            mov REG[0xd0],>_TIMEOUT
 0343 5101              mov A,[_TIMEOUT+1]
 0345 1103              sub A,3
 0347 5100              mov A,[_TIMEOUT]
 0349 3180              xor A,-128
 034B 1980              sbb A,(0 ^ 0x80)
 034D CF31              jc L45
 034F           X12:
 034F                   .dbline 306
 034F           ;       
 034F           ;       RX_TIMEOUT_Stop();
 034F 10                push X
 0350 7C0000            xcall _RX_TIMEOUT_Stop
 0353 20                pop X
 0354                   .dbline 307
 0354           ;       TIMEOUT = 0;
 0354 62D000            mov REG[0xd0],>_TIMEOUT
 0357 550100            mov [_TIMEOUT+1],0
 035A 550000            mov [_TIMEOUT],0
 035D                   .dbline 309
 035D           ;       
 035D           ;       return valid_transmit;
 035D 62D000            mov REG[0xd0],>__r0
 0360 5204              mov A,[X+4]
 0362 5300              mov [__r1],A
 0364 5203              mov A,[X+3]
 0366 5300              mov [__r0],A
 0368                   .dbline -2
 0368           L44:
 0368 38FB              add SP,-5
 036A 20                pop X
 036B                   .dbline 0 ; func end
 036B 7F                ret
 036C                   .dbsym l valid_transmit 3 I
 036C                   .dbsym l i 1 I
 036C                   .dbsym l tempByte 0 c
 036C                   .dbend
 036C                   .dbfunc e decodeTransmission _decodeTransmission fV
 036C           ;          speed -> X+10
 036C           ;          angle -> X+8
 036C           ;       tempByte -> X+7
 036C           ;          total -> X+5
 036C           ;             ID -> X+4
 036C           ;   runningTotal -> X+2
 036C           ;          param -> X+0
 036C           _decodeTransmission::
 036C                   .dbline -1
 036C 10                push X
 036D 4F                mov X,SP
 036E 380C              add SP,12
 0370                   .dbline 314
 0370           ; }
 0370           ; 
 0370           ; // This function decodes the transmission and takes the correct action.
 0370           ; void decodeTransmission(void)
 0370           ; {
 0370                   .dbline 316
 0370           ;       char* param;
 0370           ;       char ID = 0;
 0370 560400            mov [X+4],0
 0373                   .dbline 320
 0373           ;       char tempByte;
 0373           ;       char angle[2];
 0373           ;       char speed[2];
 0373           ;       int total = 0;
 0373 560600            mov [X+6],0
 0376 560500            mov [X+5],0
 0379                   .dbline 321
 0379           ;       int runningTotal = 0;
 0379 560300            mov [X+3],0
 037C 560200            mov [X+2],0
 037F                   .dbline 323
 037F           ;       
 037F           ;       if(param = COMP_SERIAL_szGetParam())
 037F 10                push X
 0380 7C0000            xcall _COMP_SERIAL_szGetParam
 0383 62D000            mov REG[0xd0],>__r0
 0386 5300              mov [__r0],A
 0388 5A00              mov [__r1],X
 038A 20                pop X
 038B 5100              mov A,[__r1]
 038D 5401              mov [X+1],A
 038F 5100              mov A,[__r0]
 0391 5400              mov [X+0],A
 0393 3C0000            cmp [__r0],0
 0396 B006              jnz X13
 0398 3C0000            cmp [__r1],0
 039B A689              jz L75
 039D           X13:
 039D                   .dbline 324
 039D           ;       {
 039D                   .dbline 325
 039D           ;               if((param[0] == 'x') || (param[0] == 'X'))
 039D 62D000            mov REG[0xd0],>__r0
 03A0 5201              mov A,[X+1]
 03A2 5300              mov [__r1],A
 03A4 5200              mov A,[X+0]
 03A6 60D4              mov REG[0xd4],A
 03A8 3E00              mvi A,[__r1]
 03AA 5300              mov [__r1],A
 03AC 550000            mov [__r0],0
 03AF 3C0000            cmp [__r0],0
 03B2 B005              jnz X14
 03B4 3978              cmp A,120
 03B6 A00E              jz L79
 03B8           X14:
 03B8 62D000            mov REG[0xd0],>__r0
 03BB 3C0000            cmp [__r0],0
 03BE B099              jnz L77
 03C0 3C0058            cmp [__r1],88
 03C3 B094              jnz L77
 03C5           X15:
 03C5           L79:
 03C5                   .dbline 326
 03C5           ;               {
 03C5                   .dbline 328
 03C5           ;                       // Reset
 03C5           ;                       NUM_MODULES = 0;
 03C5 62D000            mov REG[0xd0],>_NUM_MODULES
 03C8 550100            mov [_NUM_MODULES+1],0
 03CB 550000            mov [_NUM_MODULES],0
 03CE                   .dbline 329
 03CE           ;                       if(param = COMP_SERIAL_szGetParam())
 03CE 10                push X
 03CF 7C0000            xcall _COMP_SERIAL_szGetParam
 03D2 62D000            mov REG[0xd0],>__r0
 03D5 5300              mov [__r0],A
 03D7 5A00              mov [__r1],X
 03D9 20                pop X
 03DA 5100              mov A,[__r1]
 03DC 5401              mov [X+1],A
 03DE 5100              mov A,[__r0]
 03E0 5400              mov [X+0],A
 03E2 3C0000            cmp [__r0],0
 03E5 B006              jnz X16
 03E7 3C0000            cmp [__r1],0
 03EA A059              jz L80
 03EC           X16:
 03EC                   .dbline 330
 03EC           ;                       {
 03EC                   .dbline 331
 03EC           ;                               if((param[0] >= '1') && (param[0] <= '9'))
 03EC 62D000            mov REG[0xd0],>__r0
 03EF 5201              mov A,[X+1]
 03F1 5300              mov [__r1],A
 03F3 5200              mov A,[X+0]
 03F5 60D4              mov REG[0xd4],A
 03F7 3E00              mvi A,[__r1]
 03F9 5300              mov [__r1],A
 03FB 550000            mov [__r0],0
 03FE 1131              sub A,49
 0400 5000              mov A,0
 0402 3180              xor A,-128
 0404 1980              sbb A,(0 ^ 0x80)
 0406 C61E              jc L78
 0408           X17:
 0408 62D000            mov REG[0xd0],>__r0
 040B 5039              mov A,57
 040D 1200              sub A,[__r1]
 040F 5100              mov A,[__r0]
 0411 3180              xor A,-128
 0413 5300              mov [__rX],A
 0415 5080              mov A,(0 ^ 0x80)
 0417 1A00              sbb A,[__rX]
 0419 C60B              jc L78
 041B           X18:
 041B                   .dbline 332
 041B           ;                               {
 041B                   .dbline 333
 041B           ;                                       PREV_NUM_MODULES = param[0] - 48;
 041B 62D000            mov REG[0xd0],>__r0
 041E 5201              mov A,[X+1]
 0420 5300              mov [__r1],A
 0422 5200              mov A,[X+0]
 0424 60D4              mov REG[0xd4],A
 0426 3E00              mvi A,[__r1]
 0428 1130              sub A,48
 042A 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 042D 5301              mov [_PREV_NUM_MODULES+1],A
 042F 5000              mov A,0
 0431 1900              sbb A,0
 0433 5300              mov [_PREV_NUM_MODULES],A
 0435                   .dbline 334
 0435           ;                                       SUGGESTED_NUM_MODULES = PREV_NUM_MODULES;
 0435 5101              mov A,[_PREV_NUM_MODULES+1]
 0437 08                push A
 0438 5100              mov A,[_PREV_NUM_MODULES]
 043A 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 043D 5300              mov [_SUGGESTED_NUM_MODULES],A
 043F 18                pop A
 0440 5301              mov [_SUGGESTED_NUM_MODULES+1],A
 0442                   .dbline 335
 0442           ;                               }
 0442                   .dbline 336
 0442           ;                       }
 0442 85E2              xjmp L78
 0444           L80:
 0444                   .dbline 338
 0444           ;                       else
 0444           ;                       {
 0444                   .dbline 339
 0444           ;                               PREV_NUM_MODULES = 1;
 0444 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0447 550101            mov [_PREV_NUM_MODULES+1],1
 044A 550000            mov [_PREV_NUM_MODULES],0
 044D                   .dbline 340
 044D           ;                               SUGGESTED_NUM_MODULES = MAX_MODULES;
 044D 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0450 550109            mov [_SUGGESTED_NUM_MODULES+1],9
 0453 550000            mov [_SUGGESTED_NUM_MODULES],0
 0456                   .dbline 341
 0456           ;                       }
 0456                   .dbline 342
 0456           ;               }
 0456 85CE              xjmp L78
 0458           L77:
 0458                   .dbline 343
 0458           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 0458 62D000            mov REG[0xd0],>__r0
 045B 5201              mov A,[X+1]
 045D 5300              mov [__r1],A
 045F 5200              mov A,[X+0]
 0461 60D4              mov REG[0xd4],A
 0463 3E00              mvi A,[__r1]
 0465 5300              mov [__r1],A
 0467 550000            mov [__r0],0
 046A 3C0000            cmp [__r0],0
 046D B005              jnz X19
 046F 396E              cmp A,110
 0471 A00E              jz L86
 0473           X19:
 0473 62D000            mov REG[0xd0],>__r0
 0476 3C0000            cmp [__r0],0
 0479 B035              jnz L84
 047B 3C004E            cmp [__r1],78
 047E B030              jnz L84
 0480           X20:
 0480           L86:
 0480                   .dbline 344
 0480           ;               {
 0480                   .dbline 345
 0480           ;                       itoa(param,NUM_MODULES,10);
 0480 5000              mov A,0
 0482 08                push A
 0483 500A              mov A,10
 0485 08                push A
 0486 62D000            mov REG[0xd0],>_NUM_MODULES
 0489 5100              mov A,[_NUM_MODULES]
 048B 08                push A
 048C 5101              mov A,[_NUM_MODULES+1]
 048E 08                push A
 048F 5200              mov A,[X+0]
 0491 08                push A
 0492 5201              mov A,[X+1]
 0494 08                push A
 0495 7C0000            xcall _itoa
 0498 38FA              add SP,-6
 049A                   .dbline 346
 049A           ;                       COMP_SERIAL_PutString(param);
 049A 10                push X
 049B 5200              mov A,[X+0]
 049D 08                push A
 049E 5201              mov A,[X+1]
 04A0 5C                mov X,A
 04A1 18                pop A
 04A2 7C0000            xcall _COMP_SERIAL_PutString
 04A5 20                pop X
 04A6                   .dbline 347
 04A6           ;                       COMP_SERIAL_PutChar('\n');
 04A6 10                push X
 04A7 500A              mov A,10
 04A9 7C0000            xcall _COMP_SERIAL_PutChar
 04AC 20                pop X
 04AD                   .dbline 348
 04AD           ;               }
 04AD 8577              xjmp L85
 04AF           L84:
 04AF                   .dbline 349
 04AF           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04AF 62D000            mov REG[0xd0],>__r0
 04B2 5201              mov A,[X+1]
 04B4 5300              mov [__r1],A
 04B6 5200              mov A,[X+0]
 04B8 60D4              mov REG[0xd4],A
 04BA 3E00              mvi A,[__r1]
 04BC 5300              mov [__r1],A
 04BE 550000            mov [__r0],0
 04C1 3C0000            cmp [__r0],0
 04C4 B005              jnz X21
 04C6 3977              cmp A,119
 04C8 A00E              jz L89
 04CA           X21:
 04CA 62D000            mov REG[0xd0],>__r0
 04CD 3C0000            cmp [__r0],0
 04D0 B214              jnz L87
 04D2 3C0057            cmp [__r1],87
 04D5 B20F              jnz L87
 04D7           X22:
 04D7           L89:
 04D7                   .dbline 350
 04D7           ;               {
 04D7                   .dbline 351
 04D7           ;                       if(param = COMP_SERIAL_szGetParam())
 04D7 10                push X
 04D8 7C0000            xcall _COMP_SERIAL_szGetParam
 04DB 62D000            mov REG[0xd0],>__r0
 04DE 5300              mov [__r0],A
 04E0 5A00              mov [__r1],X
 04E2 20                pop X
 04E3 5100              mov A,[__r1]
 04E5 5401              mov [X+1],A
 04E7 5100              mov A,[__r0]
 04E9 5400              mov [X+0],A
 04EB 3C0000            cmp [__r0],0
 04EE B006              jnz X23
 04F0 3C0000            cmp [__r1],0
 04F3 A531              jz L88
 04F5           X23:
 04F5                   .dbline 352
 04F5           ;                       {
 04F5                   .dbline 353
 04F5           ;                               ID = atoi(param);
 04F5 5200              mov A,[X+0]
 04F7 08                push A
 04F8 5201              mov A,[X+1]
 04FA 08                push A
 04FB 7C0000            xcall _atoi
 04FE 38FE              add SP,-2
 0500 62D000            mov REG[0xd0],>__r0
 0503 5100              mov A,[__r1]
 0505 5404              mov [X+4],A
 0507                   .dbline 355
 0507           ;                               
 0507           ;                               if(param = COMP_SERIAL_szGetParam())
 0507 10                push X
 0508 7C0000            xcall _COMP_SERIAL_szGetParam
 050B 62D000            mov REG[0xd0],>__r0
 050E 5300              mov [__r0],A
 0510 5A00              mov [__r1],X
 0512 20                pop X
 0513 5100              mov A,[__r1]
 0515 5401              mov [X+1],A
 0517 5100              mov A,[__r0]
 0519 5400              mov [X+0],A
 051B 3C0000            cmp [__r0],0
 051E B006              jnz X24
 0520 3C0000            cmp [__r1],0
 0523 A501              jz L88
 0525           X24:
 0525                   .dbline 356
 0525           ;                               {
 0525                   .dbline 357
 0525           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0525 62D000            mov REG[0xd0],>__r0
 0528 5201              mov A,[X+1]
 052A 5300              mov [__r1],A
 052C 5200              mov A,[X+0]
 052E 60D4              mov REG[0xd4],A
 0530 3E00              mvi A,[__r1]
 0532 5300              mov [__r1],A
 0534 550000            mov [__r0],0
 0537 3C0000            cmp [__r0],0
 053A B005              jnz X25
 053C 3961              cmp A,97
 053E A00E              jz L96
 0540           X25:
 0540 62D000            mov REG[0xd0],>__r0
 0543 3C0000            cmp [__r0],0
 0546 B084              jnz L94
 0548 3C0041            cmp [__r1],65
 054B B07F              jnz L94
 054D           X26:
 054D           L96:
 054D                   .dbline 358
 054D           ;                                       {
 054D                   .dbline 359
 054D           ;                                               if(param = COMP_SERIAL_szGetParam())
 054D 10                push X
 054E 7C0000            xcall _COMP_SERIAL_szGetParam
 0551 62D000            mov REG[0xd0],>__r0
 0554 5300              mov [__r0],A
 0556 5A00              mov [__r1],X
 0558 20                pop X
 0559 5100              mov A,[__r1]
 055B 5401              mov [X+1],A
 055D 5100              mov A,[__r0]
 055F 5400              mov [X+0],A
 0561 3C0000            cmp [__r0],0
 0564 B006              jnz X27
 0566 3C0000            cmp [__r1],0
 0569 A4BB              jz L88
 056B           X27:
 056B                   .dbline 360
 056B           ;                                               {
 056B                   .dbline 361
 056B           ;                                                       total = atoi(param);
 056B 5200              mov A,[X+0]
 056D 08                push A
 056E 5201              mov A,[X+1]
 0570 08                push A
 0571 7C0000            xcall _atoi
 0574 38FE              add SP,-2
 0576 62D000            mov REG[0xd0],>__r0
 0579 5100              mov A,[__r1]
 057B 5406              mov [X+6],A
 057D 5100              mov A,[__r0]
 057F 5405              mov [X+5],A
 0581                   .dbline 362
 0581           ;                                                       angle[0] = total%256;
 0581 5001              mov A,1
 0583 08                push A
 0584 5000              mov A,0
 0586 08                push A
 0587 5205              mov A,[X+5]
 0589 08                push A
 058A 5206              mov A,[X+6]
 058C 08                push A
 058D 7C0000            xcall __divmod_16X16_16
 0590 38FE              add SP,-2
 0592 18                pop A
 0593 5300              mov [__r1],A
 0595 18                pop A
 0596 5100              mov A,[__r1]
 0598 5408              mov [X+8],A
 059A                   .dbline 363
 059A           ;                                                       angle[1] = total/256;
 059A 5001              mov A,1
 059C 08                push A
 059D 5000              mov A,0
 059F 08                push A
 05A0 5205              mov A,[X+5]
 05A2 08                push A
 05A3 5206              mov A,[X+6]
 05A5 08                push A
 05A6 7C0000            xcall __divmod_16X16_16
 05A9 18                pop A
 05AA 5300              mov [__r1],A
 05AC 18                pop A
 05AD 38FE              add SP,-2
 05AF 5100              mov A,[__r1]
 05B1 5409              mov [X+9],A
 05B3                   .dbline 364
 05B3           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05B3 5209              mov A,[X+9]
 05B5 08                push A
 05B6 5208              mov A,[X+8]
 05B8 08                push A
 05B9 501E              mov A,30
 05BB 08                push A
 05BC 5003              mov A,3
 05BE 08                push A
 05BF 5005              mov A,5
 05C1 08                push A
 05C2 5204              mov A,[X+4]
 05C4 08                push A
 05C5 952C              xcall _longServoInstruction
 05C7 38FA              add SP,-6
 05C9                   .dbline 365
 05C9           ;                                               }
 05C9                   .dbline 366
 05C9           ;                                       }
 05C9 845B              xjmp L88
 05CB           L94:
 05CB                   .dbline 367
 05CB           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 05CB 62D000            mov REG[0xd0],>__r0
 05CE 5201              mov A,[X+1]
 05D0 5300              mov [__r1],A
 05D2 5200              mov A,[X+0]
 05D4 60D4              mov REG[0xd4],A
 05D6 3E00              mvi A,[__r1]
 05D8 5300              mov [__r1],A
 05DA 550000            mov [__r0],0
 05DD 3C0000            cmp [__r0],0
 05E0 B005              jnz X28
 05E2 3970              cmp A,112
 05E4 A00E              jz L103
 05E6           X28:
 05E6 62D000            mov REG[0xd0],>__r0
 05E9 3C0000            cmp [__r0],0
 05EC B045              jnz L101
 05EE 3C0050            cmp [__r1],80
 05F1 B040              jnz L101
 05F3           X29:
 05F3           L103:
 05F3                   .dbline 368
 05F3           ;                                       {
 05F3                   .dbline 369
 05F3           ;                                               if(param = COMP_SERIAL_szGetParam())
 05F3 10                push X
 05F4 7C0000            xcall _COMP_SERIAL_szGetParam
 05F7 62D000            mov REG[0xd0],>__r0
 05FA 5300              mov [__r0],A
 05FC 5A00              mov [__r1],X
 05FE 20                pop X
 05FF 5100              mov A,[__r1]
 0601 5401              mov [X+1],A
 0603 5100              mov A,[__r0]
 0605 5400              mov [X+0],A
 0607 3C0000            cmp [__r0],0
 060A B006              jnz X30
 060C 3C0000            cmp [__r1],0
 060F A415              jz L88
 0611           X30:
 0611                   .dbline 370
 0611           ;                                               {
 0611                   .dbline 371
 0611           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0611 5200              mov A,[X+0]
 0613 08                push A
 0614 5201              mov A,[X+1]
 0616 08                push A
 0617 7C0000            xcall _atoi
 061A 62D000            mov REG[0xd0],>__r0
 061D 5100              mov A,[__r1]
 061F 08                push A
 0620 5018              mov A,24
 0622 08                push A
 0623 5003              mov A,3
 0625 08                push A
 0626 5004              mov A,4
 0628 08                push A
 0629 5204              mov A,[X+4]
 062B 08                push A
 062C 9422              xcall _servoInstruction
 062E 38F9              add SP,-7
 0630                   .dbline 372
 0630           ;                                               }
 0630                   .dbline 373
 0630           ;                                       }
 0630 83F4              xjmp L88
 0632           L101:
 0632                   .dbline 374
 0632           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 0632 62D000            mov REG[0xd0],>__r0
 0635 5201              mov A,[X+1]
 0637 5300              mov [__r1],A
 0639 5200              mov A,[X+0]
 063B 60D4              mov REG[0xd4],A
 063D 3E00              mvi A,[__r1]
 063F 5300              mov [__r1],A
 0641 550000            mov [__r0],0
 0644 3C0000            cmp [__r0],0
 0647 B005              jnz X31
 0649 3973              cmp A,115
 064B A00E              jz L108
 064D           X31:
 064D 62D000            mov REG[0xd0],>__r0
 0650 3C0000            cmp [__r0],0
 0653 B3D1              jnz L88
 0655 3C0053            cmp [__r1],83
 0658 B3CC              jnz L88
 065A           X32:
 065A           L108:
 065A                   .dbline 375
 065A           ;                                       {
 065A                   .dbline 376
 065A           ;                                               if(param = COMP_SERIAL_szGetParam())
 065A 10                push X
 065B 7C0000            xcall _COMP_SERIAL_szGetParam
 065E 62D000            mov REG[0xd0],>__r0
 0661 5300              mov [__r0],A
 0663 5A00              mov [__r1],X
 0665 20                pop X
 0666 5100              mov A,[__r1]
 0668 5401              mov [X+1],A
 066A 5100              mov A,[__r0]
 066C 5400              mov [X+0],A
 066E 3C0000            cmp [__r0],0
 0671 B006              jnz X33
 0673 3C0000            cmp [__r1],0
 0676 A3AE              jz L88
 0678           X33:
 0678                   .dbline 377
 0678           ;                                               {
 0678                   .dbline 378
 0678           ;                                                       total = atoi(param);
 0678 5200              mov A,[X+0]
 067A 08                push A
 067B 5201              mov A,[X+1]
 067D 08                push A
 067E 7C0000            xcall _atoi
 0681 38FE              add SP,-2
 0683 62D000            mov REG[0xd0],>__r0
 0686 5100              mov A,[__r1]
 0688 5406              mov [X+6],A
 068A 5100              mov A,[__r0]
 068C 5405              mov [X+5],A
 068E                   .dbline 381
 068E           ;                                                       
 068E           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 068E           ;                                                       if(total)
 068E 3D0500            cmp [X+5],0
 0691 B006              jnz X34
 0693 3D0600            cmp [X+6],0
 0696 A38E              jz L88
 0698           X34:
 0698                   .dbline 382
 0698           ;                                                       {
 0698                   .dbline 383
 0698           ;                                                               speed[0] = total%256;
 0698 62D000            mov REG[0xd0],>__r0
 069B 5001              mov A,1
 069D 08                push A
 069E 5000              mov A,0
 06A0 08                push A
 06A1 5205              mov A,[X+5]
 06A3 08                push A
 06A4 5206              mov A,[X+6]
 06A6 08                push A
 06A7 7C0000            xcall __divmod_16X16_16
 06AA 38FE              add SP,-2
 06AC 18                pop A
 06AD 5300              mov [__r1],A
 06AF 18                pop A
 06B0 5100              mov A,[__r1]
 06B2 540A              mov [X+10],A
 06B4                   .dbline 384
 06B4           ;                                                               speed[1] = total/256;
 06B4 5001              mov A,1
 06B6 08                push A
 06B7 5000              mov A,0
 06B9 08                push A
 06BA 5205              mov A,[X+5]
 06BC 08                push A
 06BD 5206              mov A,[X+6]
 06BF 08                push A
 06C0 7C0000            xcall __divmod_16X16_16
 06C3 18                pop A
 06C4 5300              mov [__r1],A
 06C6 18                pop A
 06C7 38FE              add SP,-2
 06C9 5100              mov A,[__r1]
 06CB 540B              mov [X+11],A
 06CD                   .dbline 385
 06CD           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 06CD 520B              mov A,[X+11]
 06CF 08                push A
 06D0 520A              mov A,[X+10]
 06D2 08                push A
 06D3 5020              mov A,32
 06D5 08                push A
 06D6 5003              mov A,3
 06D8 08                push A
 06D9 5005              mov A,5
 06DB 08                push A
 06DC 5204              mov A,[X+4]
 06DE 08                push A
 06DF 9412              xcall _longServoInstruction
 06E1 38FA              add SP,-6
 06E3                   .dbline 386
 06E3           ;                                                       }
 06E3                   .dbline 387
 06E3           ;                                               }
 06E3                   .dbline 388
 06E3           ;                                       }
 06E3                   .dbline 389
 06E3           ;                               }
 06E3                   .dbline 390
 06E3           ;                       }
 06E3                   .dbline 391
 06E3           ;               }
 06E3 8341              xjmp L88
 06E5           L87:
 06E5                   .dbline 392
 06E5           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 06E5 62D000            mov REG[0xd0],>__r0
 06E8 5201              mov A,[X+1]
 06EA 5300              mov [__r1],A
 06EC 5200              mov A,[X+0]
 06EE 60D4              mov REG[0xd4],A
 06F0 3E00              mvi A,[__r1]
 06F2 5300              mov [__r1],A
 06F4 550000            mov [__r0],0
 06F7 3C0000            cmp [__r0],0
 06FA B005              jnz X35
 06FC 3972              cmp A,114
 06FE A00E              jz L117
 0700           X35:
 0700 62D000            mov REG[0xd0],>__r0
 0703 3C0000            cmp [__r0],0
 0706 B31E              jnz L115
 0708 3C0052            cmp [__r1],82
 070B B319              jnz L115
 070D           X36:
 070D           L117:
 070D                   .dbline 393
 070D           ;               {                       
 070D                   .dbline 394
 070D           ;                       if(param = COMP_SERIAL_szGetParam())
 070D 10                push X
 070E 7C0000            xcall _COMP_SERIAL_szGetParam
 0711 62D000            mov REG[0xd0],>__r0
 0714 5300              mov [__r0],A
 0716 5A00              mov [__r1],X
 0718 20                pop X
 0719 5100              mov A,[__r1]
 071B 5401              mov [X+1],A
 071D 5100              mov A,[__r0]
 071F 5400              mov [X+0],A
 0721 3C0000            cmp [__r0],0
 0724 B006              jnz X37
 0726 3C0000            cmp [__r1],0
 0729 A2FB              jz L118
 072B           X37:
 072B                   .dbline 395
 072B           ;                       {
 072B                   .dbline 396
 072B           ;                               ID = atoi(param);
 072B 5200              mov A,[X+0]
 072D 08                push A
 072E 5201              mov A,[X+1]
 0730 08                push A
 0731 7C0000            xcall _atoi
 0734 38FE              add SP,-2
 0736 62D000            mov REG[0xd0],>__r0
 0739 5100              mov A,[__r1]
 073B 5404              mov [X+4],A
 073D                   .dbline 397
 073D           ;                               if(param = COMP_SERIAL_szGetParam())
 073D 10                push X
 073E 7C0000            xcall _COMP_SERIAL_szGetParam
 0741 62D000            mov REG[0xd0],>__r0
 0744 5300              mov [__r0],A
 0746 5A00              mov [__r1],X
 0748 20                pop X
 0749 5100              mov A,[__r1]
 074B 5401              mov [X+1],A
 074D 5100              mov A,[__r0]
 074F 5400              mov [X+0],A
 0751 3C0000            cmp [__r0],0
 0754 B006              jnz X38
 0756 3C0000            cmp [__r1],0
 0759 A2CB              jz L120
 075B           X38:
 075B                   .dbline 398
 075B           ;                               {
 075B                   .dbline 399
 075B           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 075B 62D000            mov REG[0xd0],>__r0
 075E 5201              mov A,[X+1]
 0760 5300              mov [__r1],A
 0762 5200              mov A,[X+0]
 0764 60D4              mov REG[0xd4],A
 0766 3E00              mvi A,[__r1]
 0768 5300              mov [__r1],A
 076A 550000            mov [__r0],0
 076D 3C0000            cmp [__r0],0
 0770 B005              jnz X39
 0772 3961              cmp A,97
 0774 A00E              jz L124
 0776           X39:
 0776 62D000            mov REG[0xd0],>__r0
 0779 3C0000            cmp [__r0],0
 077C B0D1              jnz L122
 077E 3C0041            cmp [__r1],65
 0781 B0CC              jnz L122
 0783           X40:
 0783           L124:
 0783                   .dbline 400
 0783           ;                                       {
 0783                   .dbline 401
 0783           ;                                               angle[0] = 0;
 0783 560800            mov [X+8],0
 0786                   .dbline 402
 0786           ;                                               angle[1] = 0;
 0786 560900            mov [X+9],0
 0789                   .dbline 404
 0789           ;                                               
 0789           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 0789 5002              mov A,2
 078B 08                push A
 078C 5024              mov A,36
 078E 08                push A
 078F 5002              mov A,2
 0791 08                push A
 0792 5004              mov A,4
 0794 08                push A
 0795 5204              mov A,[X+4]
 0797 08                push A
 0798 92B6              xcall _servoInstruction
 079A                   .dbline 405
 079A           ;                                               configToggle(RX_MODE);
 079A 5000              mov A,0
 079C 08                push A
 079D 5001              mov A,1
 079F 08                push A
 07A0 9402              xcall _configToggle
 07A2 38F9              add SP,-7
 07A4 8098              xjmp L127
 07A6           L126:
 07A6                   .dbline 409
 07A6           ;                                                       
 07A6           ;                                               // Loop until we read a response or time out.
 07A6           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07A6           ;                                               {
 07A6                   .dbline 410
 07A6           ;                                                       if(RECEIVE_cReadChar() == ID)
 07A6 10                push X
 07A7 7C0000            xcall _RECEIVE_cReadChar
 07AA 62D000            mov REG[0xd0],>__r0
 07AD 20                pop X
 07AE 3B04              cmp A,[X+4]
 07B0 B08C              jnz L129
 07B2                   .dbline 411
 07B2           ;                                                       {
 07B2 807B              xjmp L132
 07B4           L131:
 07B4                   .dbline 413
 07B4           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07B4           ;                                                               {
 07B4                   .dbline 414
 07B4           ;                                                                       if(RECEIVE_cReadChar() == 4)
 07B4 10                push X
 07B5 7C0000            xcall _RECEIVE_cReadChar
 07B8 62D000            mov REG[0xd0],>__r0
 07BB 20                pop X
 07BC 3904              cmp A,4
 07BE B06F              jnz L134
 07C0                   .dbline 415
 07C0           ;                                                                       {
 07C0                   .dbline 416
 07C0           ;                                                                               if(RECEIVE_cGetChar() == 0)
 07C0 10                push X
 07C1 7C0000            xcall _RECEIVE_cGetChar
 07C4 62D000            mov REG[0xd0],>__r0
 07C7 20                pop X
 07C8 3900              cmp A,0
 07CA B05A              jnz L136
 07CC                   .dbline 417
 07CC           ;                                                                               {
 07CC                   .dbline 418
 07CC           ;                                                                                       angle[0] = RECEIVE_cGetChar();
 07CC 10                push X
 07CD 7C0000            xcall _RECEIVE_cGetChar
 07D0 62D000            mov REG[0xd0],>__r0
 07D3 20                pop X
 07D4 5408              mov [X+8],A
 07D6                   .dbline 419
 07D6           ;                                                                                       angle[1] = RECEIVE_cGetChar();
 07D6 10                push X
 07D7 7C0000            xcall _RECEIVE_cGetChar
 07DA 62D000            mov REG[0xd0],>__r0
 07DD 20                pop X
 07DE 5409              mov [X+9],A
 07E0                   .dbline 421
 07E0           ;                                                                                       
 07E0           ;                                                                                       configToggle(PC_MODE);
 07E0 5000              mov A,0
 07E2 08                push A
 07E3 5002              mov A,2
 07E5 08                push A
 07E6 93BC              xcall _configToggle
 07E8                   .dbline 423
 07E8           ;                                                                                       
 07E8           ;                                                                                       total = ((angle[1])*256) + angle[0];
 07E8 5208              mov A,[X+8]
 07EA 5406              mov [X+6],A
 07EC 5209              mov A,[X+9]
 07EE 5405              mov [X+5],A
 07F0                   .dbline 424
 07F0           ;                                                                                       itoa(param,total,10);
 07F0 5000              mov A,0
 07F2 08                push A
 07F3 500A              mov A,10
 07F5 08                push A
 07F6 5205              mov A,[X+5]
 07F8 08                push A
 07F9 5206              mov A,[X+6]
 07FB 08                push A
 07FC 5200              mov A,[X+0]
 07FE 08                push A
 07FF 5201              mov A,[X+1]
 0801 08                push A
 0802 7C0000            xcall _itoa
 0805 38F8              add SP,-8
 0807                   .dbline 425
 0807           ;                                                                                       COMP_SERIAL_PutString(param);
 0807 10                push X
 0808 5200              mov A,[X+0]
 080A 08                push A
 080B 5201              mov A,[X+1]
 080D 5C                mov X,A
 080E 18                pop A
 080F 7C0000            xcall _COMP_SERIAL_PutString
 0812 20                pop X
 0813                   .dbline 426
 0813           ;                                                                                       COMP_SERIAL_PutChar('\n');
 0813 10                push X
 0814 500A              mov A,10
 0816 7C0000            xcall _COMP_SERIAL_PutChar
 0819 20                pop X
 081A                   .dbline 428
 081A           ; 
 081A           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 081A 62D000            mov REG[0xd0],>_TIMEOUT
 081D 550103            mov [_TIMEOUT+1],3
 0820 550000            mov [_TIMEOUT],0
 0823                   .dbline 429
 0823           ;                                                                               }
 0823 800A              xjmp L137
 0825           L136:
 0825                   .dbline 431
 0825           ;                                                                               else
 0825           ;                                                                               {
 0825                   .dbline 432
 0825           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0825 62D000            mov REG[0xd0],>_TIMEOUT
 0828 550103            mov [_TIMEOUT+1],3
 082B 550000            mov [_TIMEOUT],0
 082E                   .dbline 433
 082E           ;                                                                               }
 082E           L137:
 082E                   .dbline 434
 082E           ;                                                                       }
 082E           L134:
 082E                   .dbline 435
 082E           ;                                                               }
 082E           L132:
 082E                   .dbline 412
 082E 62D000            mov REG[0xd0],>_TIMEOUT
 0831 5101              mov A,[_TIMEOUT+1]
 0833 1103              sub A,3
 0835 5100              mov A,[_TIMEOUT]
 0837 3180              xor A,-128
 0839 1980              sbb A,(0 ^ 0x80)
 083B CF78              jc L131
 083D           X41:
 083D                   .dbline 436
 083D           ;                                                       }
 083D           L129:
 083D                   .dbline 437
 083D           ;                                               }
 083D           L127:
 083D                   .dbline 408
 083D 62D000            mov REG[0xd0],>_TIMEOUT
 0840 5101              mov A,[_TIMEOUT+1]
 0842 1103              sub A,3
 0844 5100              mov A,[_TIMEOUT]
 0846 3180              xor A,-128
 0848 1980              sbb A,(0 ^ 0x80)
 084A CF5B              jc L126
 084C           X42:
 084C                   .dbline 438
 084C           ;                                       }
 084C 81D8              xjmp L123
 084E           L122:
 084E                   .dbline 439
 084E           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 084E 62D000            mov REG[0xd0],>__r0
 0851 5201              mov A,[X+1]
 0853 5300              mov [__r1],A
 0855 5200              mov A,[X+0]
 0857 60D4              mov REG[0xd4],A
 0859 3E00              mvi A,[__r1]
 085B 5300              mov [__r1],A
 085D 550000            mov [__r0],0
 0860 3C0000            cmp [__r0],0
 0863 B005              jnz X43
 0865 3970              cmp A,112
 0867 A00E              jz L142
 0869           X43:
 0869 62D000            mov REG[0xd0],>__r0
 086C 3C0000            cmp [__r0],0
 086F B0EF              jnz L140
 0871 3C0050            cmp [__r1],80
 0874 B0EA              jnz L140
 0876           X44:
 0876           L142:
 0876                   .dbline 440
 0876           ;                                       {
 0876                   .dbline 441
 0876           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 0876 5001              mov A,1
 0878 08                push A
 0879 5018              mov A,24
 087B 08                push A
 087C 5002              mov A,2
 087E 08                push A
 087F 5004              mov A,4
 0881 08                push A
 0882 5204              mov A,[X+4]
 0884 08                push A
 0885 91C9              xcall _servoInstruction
 0887                   .dbline 442
 0887           ;                                               configToggle(RX_MODE);
 0887 5000              mov A,0
 0889 08                push A
 088A 5001              mov A,1
 088C 08                push A
 088D 9315              xcall _configToggle
 088F 38F9              add SP,-7
 0891 80BC              xjmp L144
 0893           L143:
 0893                   .dbline 446
 0893           ;                                               
 0893           ;                                               // Loop until we read a response or time out.
 0893           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0893           ;                                               {
 0893                   .dbline 447
 0893           ;                                                       if(RECEIVE_cReadChar() == ID)
 0893 10                push X
 0894 7C0000            xcall _RECEIVE_cReadChar
 0897 62D000            mov REG[0xd0],>__r0
 089A 20                pop X
 089B 3B04              cmp A,[X+4]
 089D B0B0              jnz L146
 089F                   .dbline 448
 089F           ;                                                       {
 089F                   .dbline 449
 089F           ;                                                               runningTotal = ID;
 089F 5204              mov A,[X+4]
 08A1 5403              mov [X+3],A
 08A3 560200            mov [X+2],0
 08A6 8098              xjmp L149
 08A8           L148:
 08A8                   .dbline 452
 08A8           ;                                                               // Loop until we read a response or time out.
 08A8           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 08A8           ;                                                               {
 08A8                   .dbline 454
 08A8           ;                                                                       // Check the length of the packet.
 08A8           ;                                                                       if(RECEIVE_cReadChar() == 3)
 08A8 10                push X
 08A9 7C0000            xcall _RECEIVE_cReadChar
 08AC 62D000            mov REG[0xd0],>__r0
 08AF 20                pop X
 08B0 3903              cmp A,3
 08B2 B08C              jnz L151
 08B4                   .dbline 455
 08B4           ;                                                                       {
 08B4                   .dbline 456
 08B4           ;                                                                               runningTotal += 3;
 08B4 070303            add [X+3],3
 08B7 0F0200            adc [X+2],0
 08BA 8075              xjmp L154
 08BC           L153:
 08BC                   .dbline 459
 08BC           ;                                                                               // Loop until we read a response or time out.
 08BC           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 08BC           ;                                                                               {
 08BC                   .dbline 461
 08BC           ;                                                                                       // Check for the checksum or 1.
 08BC           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 08BC 10                push X
 08BD 7C0000            xcall _RECEIVE_cReadChar
 08C0 62D000            mov REG[0xd0],>__r0
 08C3 20                pop X
 08C4 5407              mov [X+7],A
 08C6 3900              cmp A,0
 08C8 A067              jz L156
 08CA                   .dbline 462
 08CA           ;                                                                                       {
 08CA                   .dbline 463
 08CA           ;                                                                                               configToggle(PC_MODE);
 08CA 5000              mov A,0
 08CC 08                push A
 08CD 5002              mov A,2
 08CF 08                push A
 08D0 92D2              xcall _configToggle
 08D2 38FE              add SP,-2
 08D4                   .dbline 465
 08D4           ;                                                                                               
 08D4           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 08D4 62D000            mov REG[0xd0],>__r0
 08D7 5207              mov A,[X+7]
 08D9 5300              mov [__r1],A
 08DB 550000            mov [__r0],0
 08DE 50FF              mov A,-1
 08E0 1200              sub A,[__r1]
 08E2 5300              mov [__r1],A
 08E4 5000              mov A,0
 08E6 1A00              sbb A,[__r0]
 08E8 5300              mov [__r0],A
 08EA 5001              mov A,1
 08EC 08                push A
 08ED 5000              mov A,0
 08EF 08                push A
 08F0 5202              mov A,[X+2]
 08F2 08                push A
 08F3 5203              mov A,[X+3]
 08F5 08                push A
 08F6 7C0000            xcall __divmod_16X16_16
 08F9 38FE              add SP,-2
 08FB 18                pop A
 08FC 5300              mov [__r3],A
 08FE 18                pop A
 08FF 3A00              cmp A,[__r0]
 0901 B017              jnz L158
 0903 5100              mov A,[__r3]
 0905 3A00              cmp A,[__r1]
 0907 B011              jnz L158
 0909           X45:
 0909                   .dbline 466
 0909           ;                                                                                               {
 0909                   .dbline 468
 0909           ;                                                                                                       // Send a 0 if we hit the checksum.
 0909           ;                                                                                                       COMP_SERIAL_PutChar('0');
 0909 10                push X
 090A 5030              mov A,48
 090C 7C0000            xcall _COMP_SERIAL_PutChar
 090F 20                pop X
 0910                   .dbline 469
 0910           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0910 10                push X
 0911 500A              mov A,10
 0913 7C0000            xcall _COMP_SERIAL_PutChar
 0916 20                pop X
 0917                   .dbline 470
 0917           ;                                                                                               }
 0917 800F              xjmp L159
 0919           L158:
 0919                   .dbline 472
 0919           ;                                                                                               else
 0919           ;                                                                                               {
 0919                   .dbline 474
 0919           ;                                                                                                       // Send a 1.
 0919           ;                                                                                                       COMP_SERIAL_PutChar('1');
 0919 10                push X
 091A 5031              mov A,49
 091C 7C0000            xcall _COMP_SERIAL_PutChar
 091F 20                pop X
 0920                   .dbline 475
 0920           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0920 10                push X
 0921 500A              mov A,10
 0923 7C0000            xcall _COMP_SERIAL_PutChar
 0926 20                pop X
 0927                   .dbline 476
 0927           ;                                                                                               }
 0927           L159:
 0927                   .dbline 478
 0927           ;               
 0927           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0927 62D000            mov REG[0xd0],>_TIMEOUT
 092A 550103            mov [_TIMEOUT+1],3
 092D 550000            mov [_TIMEOUT],0
 0930                   .dbline 479
 0930           ;                                                                                       }
 0930           L156:
 0930                   .dbline 480
 0930           ;                                                                               }
 0930           L154:
 0930                   .dbline 458
 0930 62D000            mov REG[0xd0],>_TIMEOUT
 0933 5101              mov A,[_TIMEOUT+1]
 0935 1103              sub A,3
 0937 5100              mov A,[_TIMEOUT]
 0939 3180              xor A,-128
 093B 1980              sbb A,(0 ^ 0x80)
 093D CF7E              jc L153
 093F           X46:
 093F                   .dbline 481
 093F           ;                                                                       }
 093F           L151:
 093F                   .dbline 482
 093F           ;                                                               }
 093F           L149:
 093F                   .dbline 451
 093F 62D000            mov REG[0xd0],>_TIMEOUT
 0942 5101              mov A,[_TIMEOUT+1]
 0944 1103              sub A,3
 0946 5100              mov A,[_TIMEOUT]
 0948 3180              xor A,-128
 094A 1980              sbb A,(0 ^ 0x80)
 094C CF5B              jc L148
 094E           X47:
 094E                   .dbline 483
 094E           ;                                                       }
 094E           L146:
 094E                   .dbline 484
 094E           ;                                               }
 094E           L144:
 094E                   .dbline 445
 094E 62D000            mov REG[0xd0],>_TIMEOUT
 0951 5101              mov A,[_TIMEOUT+1]
 0953 1103              sub A,3
 0955 5100              mov A,[_TIMEOUT]
 0957 3180              xor A,-128
 0959 1980              sbb A,(0 ^ 0x80)
 095B CF37              jc L143
 095D           X48:
 095D                   .dbline 485
 095D           ;                                       }
 095D 80C7              xjmp L141
 095F           L140:
 095F                   .dbline 486
 095F           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 095F 62D000            mov REG[0xd0],>__r0
 0962 5201              mov A,[X+1]
 0964 5300              mov [__r1],A
 0966 5200              mov A,[X+0]
 0968 60D4              mov REG[0xd4],A
 096A 3E00              mvi A,[__r1]
 096C 5300              mov [__r1],A
 096E 550000            mov [__r0],0
 0971 3C0000            cmp [__r0],0
 0974 B005              jnz X49
 0976 3974              cmp A,116
 0978 A00E              jz L162
 097A           X49:
 097A 62D000            mov REG[0xd0],>__r0
 097D 3C0000            cmp [__r0],0
 0980 B042              jnz L160
 0982 3C0054            cmp [__r1],84
 0985 B03D              jnz L160
 0987           X50:
 0987           L162:
 0987                   .dbline 487
 0987           ;                                       {
 0987                   .dbline 488
 0987           ;                                               if(pingModule(ID))
 0987 62D000            mov REG[0xd0],>__r0
 098A 5204              mov A,[X+4]
 098C 5300              mov [__r1],A
 098E 5000              mov A,0
 0990 08                push A
 0991 5100              mov A,[__r1]
 0993 08                push A
 0994 7C0046            xcall _pingModule
 0997 38FE              add SP,-2
 0999 62D000            mov REG[0xd0],>__r0
 099C 3C0000            cmp [__r0],0
 099F B006              jnz X51
 09A1 3C0000            cmp [__r1],0
 09A4 A080              jz L161
 09A6           X51:
 09A6                   .dbline 489
 09A6           ;                                               {
 09A6                   .dbline 490
 09A6           ;                                                       configToggle(PC_MODE);
 09A6 5000              mov A,0
 09A8 08                push A
 09A9 5002              mov A,2
 09AB 08                push A
 09AC 91F6              xcall _configToggle
 09AE 38FE              add SP,-2
 09B0                   .dbline 492
 09B0           ;                                                                                               
 09B0           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 09B0 10                push X
 09B1 62D000            mov REG[0xd0],>_PARAM
 09B4 5100              mov A,[_PARAM]
 09B6 7C0000            xcall _COMP_SERIAL_PutChar
 09B9 20                pop X
 09BA                   .dbline 493
 09BA           ;                                                       COMP_SERIAL_PutChar('\n');
 09BA 10                push X
 09BB 500A              mov A,10
 09BD 7C0000            xcall _COMP_SERIAL_PutChar
 09C0 20                pop X
 09C1                   .dbline 494
 09C1           ;                                               }
 09C1                   .dbline 495
 09C1           ;                                       }
 09C1 8063              xjmp L161
 09C3           L160:
 09C3                   .dbline 496
 09C3           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 09C3 62D000            mov REG[0xd0],>__r0
 09C6 5201              mov A,[X+1]
 09C8 5300              mov [__r1],A
 09CA 5200              mov A,[X+0]
 09CC 60D4              mov REG[0xd4],A
 09CE 3E00              mvi A,[__r1]
 09D0 5300              mov [__r1],A
 09D2 550000            mov [__r0],0
 09D5 3C0000            cmp [__r0],0
 09D8 B005              jnz X52
 09DA 3963              cmp A,99
 09DC A00E              jz L167
 09DE           X52:
 09DE 62D000            mov REG[0xd0],>__r0
 09E1 3C0000            cmp [__r0],0
 09E4 B040              jnz L165
 09E6 3C0043            cmp [__r1],67
 09E9 B03B              jnz L165
 09EB           X53:
 09EB           L167:
 09EB                   .dbline 497
 09EB           ;                                       {
 09EB                   .dbline 498
 09EB           ;                                               if(pingModule(ID))
 09EB 62D000            mov REG[0xd0],>__r0
 09EE 5204              mov A,[X+4]
 09F0 5300              mov [__r1],A
 09F2 5000              mov A,0
 09F4 08                push A
 09F5 5100              mov A,[__r1]
 09F7 08                push A
 09F8 7C0046            xcall _pingModule
 09FB 38FE              add SP,-2
 09FD 62D000            mov REG[0xd0],>__r0
 0A00 3C0000            cmp [__r0],0
 0A03 B006              jnz X54
 0A05 3C0000            cmp [__r1],0
 0A08 A01C              jz L168
 0A0A           X54:
 0A0A                   .dbline 499
 0A0A           ;                                               {       
 0A0A                   .dbline 500
 0A0A           ;                                                       configToggle(PC_MODE);
 0A0A 5000              mov A,0
 0A0C 08                push A
 0A0D 5002              mov A,2
 0A0F 08                push A
 0A10 9192              xcall _configToggle
 0A12 38FE              add SP,-2
 0A14                   .dbline 502
 0A14           ;                                                       
 0A14           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 0A14 10                push X
 0A15 62D000            mov REG[0xd0],>_PARAM
 0A18 5101              mov A,[_PARAM+1]
 0A1A 7C0000            xcall _COMP_SERIAL_PutChar
 0A1D 20                pop X
 0A1E                   .dbline 503
 0A1E           ;                                                       COMP_SERIAL_PutChar('\n');
 0A1E 10                push X
 0A1F 500A              mov A,10
 0A21 7C0000            xcall _COMP_SERIAL_PutChar
 0A24 20                pop X
 0A25                   .dbline 504
 0A25           ;                                               }
 0A25           L168:
 0A25                   .dbline 505
 0A25           ;                                       }
 0A25           L165:
 0A25           L161:
 0A25           L141:
 0A25           L123:
 0A25                   .dbline 506
 0A25           ;                               }
 0A25           L120:
 0A25                   .dbline 507
 0A25           ;                       }
 0A25           L118:
 0A25                   .dbline 508
 0A25           ;               }
 0A25           L115:
 0A25           L88:
 0A25           L85:
 0A25           L78:
 0A25                   .dbline 509
 0A25           ;       }
 0A25           L75:
 0A25                   .dbline 511
 0A25           ;       
 0A25           ;       if(STATE != PC_MODE)
 0A25 62D000            mov REG[0xd0],>_STATE
 0A28 3C0000            cmp [_STATE],0
 0A2B B006              jnz X55
 0A2D 3C0102            cmp [_STATE+1],2
 0A30 A00D              jz L171
 0A32           X55:
 0A32                   .dbline 512
 0A32           ;       {
 0A32                   .dbline 513
 0A32           ;               configToggle(PC_MODE);
 0A32 5000              mov A,0
 0A34 08                push A
 0A35 5002              mov A,2
 0A37 08                push A
 0A38 916A              xcall _configToggle
 0A3A 38FE              add SP,-2
 0A3C                   .dbline 514
 0A3C           ;       }
 0A3C 800F              xjmp L172
 0A3E           L171:
 0A3E                   .dbline 516
 0A3E           ;       else
 0A3E           ;       {
 0A3E                   .dbline 517
 0A3E           ;               TIMEOUT = 0;
 0A3E 62D000            mov REG[0xd0],>_TIMEOUT
 0A41 550100            mov [_TIMEOUT+1],0
 0A44 550000            mov [_TIMEOUT],0
 0A47                   .dbline 518
 0A47           ;               COMP_SERIAL_CmdReset();
 0A47 10                push X
 0A48 7C0000            xcall _COMP_SERIAL_CmdReset
 0A4B 20                pop X
 0A4C                   .dbline 519
 0A4C           ;       }
 0A4C           L172:
 0A4C                   .dbline -2
 0A4C           L74:
 0A4C 38F4              add SP,-12
 0A4E 20                pop X
 0A4F                   .dbline 0 ; func end
 0A4F 7F                ret
 0A50                   .dbsym l speed 10 A[2:2]c
 0A50                   .dbsym l angle 8 A[2:2]c
 0A50                   .dbsym l tempByte 7 c
 0A50                   .dbsym l total 5 I
 0A50                   .dbsym l ID 4 c
 0A50                   .dbsym l runningTotal 2 I
 0A50                   .dbsym l param 0 pc
 0A50                   .dbend
 0A50                   .dbfunc e servoInstruction _servoInstruction fV
 0A50           ;          total -> X+1
 0A50           ;       checksum -> X+0
 0A50           ;          value -> X-8
 0A50           ;        address -> X-7
 0A50           ;    instruction -> X-6
 0A50           ;         length -> X-5
 0A50           ;             id -> X-4
 0A50           _servoInstruction::
 0A50                   .dbline -1
 0A50 10                push X
 0A51 4F                mov X,SP
 0A52 3803              add SP,3
 0A54                   .dbline 525
 0A54           ; }
 0A54           ; 
 0A54           ; // This function receives a destination, command length, instruction type, address, and value.
 0A54           ; // With these parameters, the function sends a packet to the communication bus.
 0A54           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0A54           ; {
 0A54                   .dbline 529
 0A54           ;       char checksum;
 0A54           ;       int total;
 0A54           ;       
 0A54           ;       total = id + length + instruction + address + value;
 0A54 62D000            mov REG[0xd0],>__r0
 0A57 52FB              mov A,[X-5]
 0A59 5300              mov [__r1],A
 0A5B 550000            mov [__r0],0
 0A5E 52FC              mov A,[X-4]
 0A60 0200              add A,[__r1]
 0A62 5300              mov [__r1],A
 0A64 5000              mov A,0
 0A66 0A00              adc A,[__r0]
 0A68 5300              mov [__r0],A
 0A6A 52FA              mov A,[X-6]
 0A6C 0400              add [__r1],A
 0A6E 0E0000            adc [__r0],0
 0A71 52F9              mov A,[X-7]
 0A73 0400              add [__r1],A
 0A75 0E0000            adc [__r0],0
 0A78 52F8              mov A,[X-8]
 0A7A 5300              mov [__r3],A
 0A7C 550000            mov [__r2],0
 0A7F 5100              mov A,[__r1]
 0A81 0200              add A,[__r3]
 0A83 5402              mov [X+2],A
 0A85 5100              mov A,[__r0]
 0A87 0A00              adc A,[__r2]
 0A89 5401              mov [X+1],A
 0A8B                   .dbline 532
 0A8B           ;       
 0A8B           ;       // Calculate the checksum value for our servo communication.
 0A8B           ;       checksum = 255-(total%256);
 0A8B 5001              mov A,1
 0A8D 08                push A
 0A8E 5000              mov A,0
 0A90 08                push A
 0A91 5201              mov A,[X+1]
 0A93 08                push A
 0A94 5202              mov A,[X+2]
 0A96 08                push A
 0A97 7C0000            xcall __divmod_16X16_16
 0A9A 38FE              add SP,-2
 0A9C 18                pop A
 0A9D 5300              mov [__r1],A
 0A9F 18                pop A
 0AA0 50FF              mov A,-1
 0AA2 1200              sub A,[__r1]
 0AA4 5400              mov [X+0],A
 0AA6                   .dbline 535
 0AA6           ;       
 0AA6           ;       // Talk to the servo.
 0AA6           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0AA6 10                push X
 0AA7 50FF              mov A,-1
 0AA9 7C0000            xcall _TX_REPEATER_PutChar
 0AAC 20                pop X
 0AAD                   .dbline 536
 0AAD           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0AAD 10                push X
 0AAE 50FF              mov A,-1
 0AB0 7C0000            xcall _TX_REPEATER_PutChar
 0AB3 20                pop X
 0AB4                   .dbline 537
 0AB4           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0AB4 10                push X
 0AB5 52FC              mov A,[X-4]
 0AB7 7C0000            xcall _TX_REPEATER_PutChar
 0ABA 20                pop X
 0ABB                   .dbline 538
 0ABB           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0ABB 10                push X
 0ABC 52FB              mov A,[X-5]
 0ABE 7C0000            xcall _TX_REPEATER_PutChar
 0AC1 20                pop X
 0AC2                   .dbline 539
 0AC2           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AC2 10                push X
 0AC3 52FA              mov A,[X-6]
 0AC5 7C0000            xcall _TX_REPEATER_PutChar
 0AC8 20                pop X
 0AC9                   .dbline 540
 0AC9           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AC9 10                push X
 0ACA 52F9              mov A,[X-7]
 0ACC 7C0000            xcall _TX_REPEATER_PutChar
 0ACF 20                pop X
 0AD0                   .dbline 541
 0AD0           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0AD0 10                push X
 0AD1 52F8              mov A,[X-8]
 0AD3 7C0000            xcall _TX_REPEATER_PutChar
 0AD6 20                pop X
 0AD7                   .dbline 542
 0AD7           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0AD7 10                push X
 0AD8 5200              mov A,[X+0]
 0ADA 7C0000            xcall _TX_REPEATER_PutChar
 0ADD 20                pop X
 0ADE           L174:
 0ADE                   .dbline 545
 0ADE           ;       
 0ADE           ;       // Wait for the transmission to finish.
 0ADE           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0ADE           L175:
 0ADE                   .dbline 545
 0ADE 10                push X
 0ADF 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0AE2 62D000            mov REG[0xd0],>__r0
 0AE5 20                pop X
 0AE6 5300              mov [__r0],A
 0AE8 470020            tst [__r0],32
 0AEB AFF2              jz L174
 0AED                   .dbline 548
 0AED           ;       
 0AED           ;       // Make completely sure we're done.
 0AED           ;       xmitWait();
 0AED 9352              xcall _xmitWait
 0AEF                   .dbline -2
 0AEF           L173:
 0AEF 38FD              add SP,-3
 0AF1 20                pop X
 0AF2                   .dbline 0 ; func end
 0AF2 7F                ret
 0AF3                   .dbsym l total 1 I
 0AF3                   .dbsym l checksum 0 c
 0AF3                   .dbsym l value -8 c
 0AF3                   .dbsym l address -7 c
 0AF3                   .dbsym l instruction -6 c
 0AF3                   .dbsym l length -5 c
 0AF3                   .dbsym l id -4 c
 0AF3                   .dbend
 0AF3                   .dbfunc e longServoInstruction _longServoInstruction fV
 0AF3           ;          total -> X+1
 0AF3           ;       checksum -> X+0
 0AF3           ;         value2 -> X-9
 0AF3           ;         value1 -> X-8
 0AF3           ;        address -> X-7
 0AF3           ;    instruction -> X-6
 0AF3           ;         length -> X-5
 0AF3           ;             id -> X-4
 0AF3           _longServoInstruction::
 0AF3                   .dbline -1
 0AF3 10                push X
 0AF4 4F                mov X,SP
 0AF5 3803              add SP,3
 0AF7                   .dbline 553
 0AF7           ; }
 0AF7           ; 
 0AF7           ; // This function receives a destination, command length, instruction type, address, and two values.
 0AF7           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0AF7           ; {
 0AF7                   .dbline 557
 0AF7           ;       char checksum;
 0AF7           ;       int total;
 0AF7           ;       
 0AF7           ;       total = id + length + instruction + address + value1 + value2;
 0AF7 62D000            mov REG[0xd0],>__r0
 0AFA 52FB              mov A,[X-5]
 0AFC 5300              mov [__r1],A
 0AFE 550000            mov [__r0],0
 0B01 52FC              mov A,[X-4]
 0B03 0200              add A,[__r1]
 0B05 5300              mov [__r1],A
 0B07 5000              mov A,0
 0B09 0A00              adc A,[__r0]
 0B0B 5300              mov [__r0],A
 0B0D 52FA              mov A,[X-6]
 0B0F 0400              add [__r1],A
 0B11 0E0000            adc [__r0],0
 0B14 52F9              mov A,[X-7]
 0B16 0400              add [__r1],A
 0B18 0E0000            adc [__r0],0
 0B1B 52F8              mov A,[X-8]
 0B1D 0400              add [__r1],A
 0B1F 0E0000            adc [__r0],0
 0B22 52F7              mov A,[X-9]
 0B24 5300              mov [__r3],A
 0B26 550000            mov [__r2],0
 0B29 5100              mov A,[__r1]
 0B2B 0200              add A,[__r3]
 0B2D 5402              mov [X+2],A
 0B2F 5100              mov A,[__r0]
 0B31 0A00              adc A,[__r2]
 0B33 5401              mov [X+1],A
 0B35                   .dbline 560
 0B35           ;       
 0B35           ;       // Calculate the checksum value for our servo communication.
 0B35           ;       checksum = 255-(total%256);
 0B35 5001              mov A,1
 0B37 08                push A
 0B38 5000              mov A,0
 0B3A 08                push A
 0B3B 5201              mov A,[X+1]
 0B3D 08                push A
 0B3E 5202              mov A,[X+2]
 0B40 08                push A
 0B41 7C0000            xcall __divmod_16X16_16
 0B44 38FE              add SP,-2
 0B46 18                pop A
 0B47 5300              mov [__r1],A
 0B49 18                pop A
 0B4A 50FF              mov A,-1
 0B4C 1200              sub A,[__r1]
 0B4E 5400              mov [X+0],A
 0B50                   .dbline 563
 0B50           ;       
 0B50           ;       // Talk to the servo.
 0B50           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0B50 10                push X
 0B51 50FF              mov A,-1
 0B53 7C0000            xcall _TX_REPEATER_PutChar
 0B56 20                pop X
 0B57                   .dbline 564
 0B57           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0B57 10                push X
 0B58 50FF              mov A,-1
 0B5A 7C0000            xcall _TX_REPEATER_PutChar
 0B5D 20                pop X
 0B5E                   .dbline 565
 0B5E           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0B5E 10                push X
 0B5F 52FC              mov A,[X-4]
 0B61 7C0000            xcall _TX_REPEATER_PutChar
 0B64 20                pop X
 0B65                   .dbline 566
 0B65           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0B65 10                push X
 0B66 52FB              mov A,[X-5]
 0B68 7C0000            xcall _TX_REPEATER_PutChar
 0B6B 20                pop X
 0B6C                   .dbline 567
 0B6C           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0B6C 10                push X
 0B6D 52FA              mov A,[X-6]
 0B6F 7C0000            xcall _TX_REPEATER_PutChar
 0B72 20                pop X
 0B73                   .dbline 568
 0B73           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0B73 10                push X
 0B74 52F9              mov A,[X-7]
 0B76 7C0000            xcall _TX_REPEATER_PutChar
 0B79 20                pop X
 0B7A                   .dbline 569
 0B7A           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0B7A 10                push X
 0B7B 52F8              mov A,[X-8]
 0B7D 7C0000            xcall _TX_REPEATER_PutChar
 0B80 20                pop X
 0B81                   .dbline 570
 0B81           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0B81 10                push X
 0B82 52F7              mov A,[X-9]
 0B84 7C0000            xcall _TX_REPEATER_PutChar
 0B87 20                pop X
 0B88                   .dbline 571
 0B88           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0B88 10                push X
 0B89 5200              mov A,[X+0]
 0B8B 7C0000            xcall _TX_REPEATER_PutChar
 0B8E 20                pop X
 0B8F           L178:
 0B8F                   .dbline 574
 0B8F           ;       
 0B8F           ;       // Wait for the transmission to finish.
 0B8F           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0B8F           L179:
 0B8F                   .dbline 574
 0B8F 10                push X
 0B90 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0B93 62D000            mov REG[0xd0],>__r0
 0B96 20                pop X
 0B97 5300              mov [__r0],A
 0B99 470020            tst [__r0],32
 0B9C AFF2              jz L178
 0B9E                   .dbline 577
 0B9E           ;       
 0B9E           ;       // Make completely sure we're done.
 0B9E           ;       xmitWait();
 0B9E 92A1              xcall _xmitWait
 0BA0                   .dbline -2
 0BA0           L177:
 0BA0 38FD              add SP,-3
 0BA2 20                pop X
 0BA3                   .dbline 0 ; func end
 0BA3 7F                ret
 0BA4                   .dbsym l total 1 I
 0BA4                   .dbsym l checksum 0 c
 0BA4                   .dbsym l value2 -9 c
 0BA4                   .dbsym l value1 -8 c
 0BA4                   .dbsym l address -7 c
 0BA4                   .dbsym l instruction -6 c
 0BA4                   .dbsym l length -5 c
 0BA4                   .dbsym l id -4 c
 0BA4                   .dbend
 0BA4                   .dbfunc e configToggle _configToggle fV
 0BA4           ;           mode -> X-5
 0BA4           _configToggle::
 0BA4                   .dbline -1
 0BA4 10                push X
 0BA5 4F                mov X,SP
 0BA6                   .dbline 583
 0BA6           ; }
 0BA6           ; 
 0BA6           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0BA6           ; // half duplex UART serial communication line.
 0BA6           ; void configToggle(int mode)
 0BA6           ; {
 0BA6                   .dbline 585
 0BA6           ;       // Disconnect from the global bus and leave the pin high.
 0BA6           ;       PRT0DR |= 0b11111111;
 0BA6 4300FF            or REG[0],-1
 0BA9                   .dbline 586
 0BA9           ;       PRT0GS &= 0b01000000;
 0BA9 410240            and REG[0x2],64
 0BAC                   .dbline 590
 0BAC           ; 
 0BAC           ;       // Unload the configuration of the current state.
 0BAC           ;       // If there is no state, blindly wipe all configurations.
 0BAC           ;       if(STATE)
 0BAC 62D000            mov REG[0xd0],>_STATE
 0BAF 3C0000            cmp [_STATE],0
 0BB2 B006              jnz X56
 0BB4 3C0100            cmp [_STATE+1],0
 0BB7 A010              jz L182
 0BB9           X56:
 0BB9                   .dbline 591
 0BB9           ;       {
 0BB9                   .dbline 592
 0BB9           ;               unloadConfig(STATE);
 0BB9 62D000            mov REG[0xd0],>_STATE
 0BBC 5100              mov A,[_STATE]
 0BBE 08                push A
 0BBF 5101              mov A,[_STATE+1]
 0BC1 08                push A
 0BC2 90C9              xcall _unloadConfig
 0BC4 38FE              add SP,-2
 0BC6                   .dbline 593
 0BC6           ;       }
 0BC6 8003              xjmp L183
 0BC8           L182:
 0BC8                   .dbline 595
 0BC8           ;       else
 0BC8           ;       {
 0BC8                   .dbline 596
 0BC8           ;               unloadAllConfigs();
 0BC8 90B9              xcall _unloadAllConfigs
 0BCA                   .dbline 597
 0BCA           ;       }
 0BCA           L183:
 0BCA                   .dbline 599
 0BCA           ;       
 0BCA           ;       if(mode == PC_MODE)
 0BCA 3DFB00            cmp [X-5],0
 0BCD B037              jnz L184
 0BCF 3DFC02            cmp [X-4],2
 0BD2 B032              jnz L184
 0BD4           X57:
 0BD4                   .dbline 600
 0BD4           ;       {
 0BD4                   .dbline 601
 0BD4           ;               LoadConfig_pc_listener();
 0BD4 7C0000            xcall _LoadConfig_pc_listener
 0BD7                   .dbline 603
 0BD7           ; 
 0BD7           ;               COMP_SERIAL_CmdReset();                                                 // Initialize the buffer.
 0BD7 10                push X
 0BD8 7C0000            xcall _COMP_SERIAL_CmdReset
 0BDB 20                pop X
 0BDC                   .dbline 604
 0BDC           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0BDC 10                push X
 0BDD 5001              mov A,1
 0BDF 7C0000            xcall _COMP_SERIAL_IntCntl
 0BE2 20                pop X
 0BE3                   .dbline 605
 0BE3           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0BE3 10                push X
 0BE4 5000              mov A,0
 0BE6 7C0000            xcall _COMP_SERIAL_Start
 0BE9 20                pop X
 0BEA                   .dbline 607
 0BEA           ;               
 0BEA           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0BEA 10                push X
 0BEB 5000              mov A,0
 0BED 7C0000            xcall _TX_REPEATER_Start
 0BF0 20                pop X
 0BF1                   .dbline 609
 0BF1           ;               
 0BF1           ;               TIMEOUT = 0;
 0BF1 62D000            mov REG[0xd0],>_TIMEOUT
 0BF4 550100            mov [_TIMEOUT+1],0
 0BF7 550000            mov [_TIMEOUT],0
 0BFA                   .dbline 610
 0BFA           ;               STATE = PC_MODE;
 0BFA 62D000            mov REG[0xd0],>_STATE
 0BFD 550102            mov [_STATE+1],2
 0C00 550000            mov [_STATE],0
 0C03                   .dbline 611
 0C03           ;       }
 0C03 807A              xjmp L185
 0C05           L184:
 0C05                   .dbline 612
 0C05           ;       else if(mode == RX_MODE)
 0C05 3DFB00            cmp [X-5],0
 0C08 B02C              jnz L186
 0C0A 3DFC01            cmp [X-4],1
 0C0D B027              jnz L186
 0C0F           X58:
 0C0F                   .dbline 613
 0C0F           ;       {
 0C0F                   .dbline 614
 0C0F           ;               LoadConfig_receiver_config();
 0C0F 7C0000            xcall _LoadConfig_receiver_config
 0C12                   .dbline 617
 0C12           ;               
 0C12           ;               // Start the receiver.
 0C12           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0C12 10                push X
 0C13 5000              mov A,0
 0C15 7C0000            xcall _RECEIVE_Start
 0C18 20                pop X
 0C19                   .dbline 620
 0C19           ;               
 0C19           ;               // Start response timeout timer and enable its interrupt routine.
 0C19           ;               TIMEOUT = 0;
 0C19 62D000            mov REG[0xd0],>_TIMEOUT
 0C1C 550100            mov [_TIMEOUT+1],0
 0C1F 550000            mov [_TIMEOUT],0
 0C22                   .dbline 621
 0C22           ;               RX_TIMEOUT_EnableInt();
 0C22 10                push X
 0C23 7C0000            xcall _RX_TIMEOUT_EnableInt
 0C26                   .dbline 622
 0C26           ;               RX_TIMEOUT_Start();
 0C26 7C0000            xcall _RX_TIMEOUT_Start
 0C29 20                pop X
 0C2A                   .dbline 624
 0C2A           ;               
 0C2A           ;               STATE = RX_MODE;
 0C2A 62D000            mov REG[0xd0],>_STATE
 0C2D 550101            mov [_STATE+1],1
 0C30 550000            mov [_STATE],0
 0C33                   .dbline 625
 0C33           ;       }
 0C33 804A              xjmp L187
 0C35           L186:
 0C35                   .dbline 626
 0C35           ;       else if(mode == TX_MODE)
 0C35 3DFB00            cmp [X-5],0
 0C38 B045              jnz L188
 0C3A 3DFC00            cmp [X-4],0
 0C3D B040              jnz L188
 0C3F           X59:
 0C3F                   .dbline 627
 0C3F           ;       {
 0C3F                   .dbline 628
 0C3F           ;               LoadConfig_transmitter_config();
 0C3F 7C0000            xcall _LoadConfig_transmitter_config
 0C42                   .dbline 630
 0C42           ;               // Start the transmitter.
 0C42           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0C42 10                push X
 0C43 5000              mov A,0
 0C45 7C0000            xcall _TRANSMIT_Start
 0C48 20                pop X
 0C49                   .dbline 632
 0C49           ;               
 0C49           ;               TIMEOUT = 0;
 0C49 62D000            mov REG[0xd0],>_TIMEOUT
 0C4C 550100            mov [_TIMEOUT+1],0
 0C4F 550000            mov [_TIMEOUT],0
 0C52                   .dbline 633
 0C52           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0C52 10                push X
 0C53 7C0000            xcall _TX_TIMEOUT_EnableInt
 0C56                   .dbline 634
 0C56           ;               TX_TIMEOUT_Start();             // Start the timer.
 0C56 7C0000            xcall _TX_TIMEOUT_Start
 0C59 20                pop X
 0C5A           L190:
 0C5A                   .dbline 637
 0C5A           ;               
 0C5A           ;               while(!TIMEOUT)
 0C5A           ;               {
 0C5A                   .dbline 640
 0C5A           ;                       // Do nothing while we wait for one timeout period.
 0C5A           ;                       // This is to allow everyone to get in the right configuration.
 0C5A           ;               }
 0C5A           L191:
 0C5A                   .dbline 636
 0C5A 62D000            mov REG[0xd0],>_TIMEOUT
 0C5D 3C0000            cmp [_TIMEOUT],0
 0C60 B006              jnz X60
 0C62 3C0100            cmp [_TIMEOUT+1],0
 0C65 AFF4              jz L190
 0C67           X60:
 0C67                   .dbline 642
 0C67           ;               
 0C67           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0C67 10                push X
 0C68 7C0000            xcall _TX_TIMEOUT_Stop
 0C6B 20                pop X
 0C6C                   .dbline 643
 0C6C           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0C6C 62D000            mov REG[0xd0],>_TIMEOUT
 0C6F 550100            mov [_TIMEOUT+1],0
 0C72 550000            mov [_TIMEOUT],0
 0C75                   .dbline 645
 0C75           ;               
 0C75           ;               STATE = TX_MODE;
 0C75 62D000            mov REG[0xd0],>_STATE
 0C78 550100            mov [_STATE+1],0
 0C7B 550000            mov [_STATE],0
 0C7E                   .dbline 646
 0C7E           ;       }
 0C7E           L188:
 0C7E           L187:
 0C7E           L185:
 0C7E                   .dbline 649
 0C7E           ;       
 0C7E           ;       // Reconnect to the global bus.
 0C7E           ;       PRT0GS |= 0b10111111;
 0C7E 4302BF            or REG[0x2],-65
 0C81                   .dbline -2
 0C81           L181:
 0C81 20                pop X
 0C82                   .dbline 0 ; func end
 0C82 7F                ret
 0C83                   .dbsym l mode -5 I
 0C83                   .dbend
 0C83                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C83           _unloadAllConfigs::
 0C83                   .dbline -1
 0C83                   .dbline 655
 0C83           ; }
 0C83           ; 
 0C83           ; // This function blindly unloads all user configurations. This will be called once,
 0C83           ; // when the system initially has no known state.
 0C83           ; void unloadAllConfigs(void)
 0C83           ; {
 0C83                   .dbline 656
 0C83           ;       UnloadConfig_pc_listener();
 0C83 7C0000            xcall _UnloadConfig_pc_listener
 0C86                   .dbline 657
 0C86           ;       UnloadConfig_receiver_config();
 0C86 7C0000            xcall _UnloadConfig_receiver_config
 0C89                   .dbline 658
 0C89           ;       UnloadConfig_transmitter_config();
 0C89 7C0000            xcall _UnloadConfig_transmitter_config
 0C8C                   .dbline -2
 0C8C           L193:
 0C8C                   .dbline 0 ; func end
 0C8C 7F                ret
 0C8D                   .dbend
 0C8D                   .dbfunc e unloadConfig _unloadConfig fV
 0C8D           ;     config_num -> X-5
 0C8D           _unloadConfig::
 0C8D                   .dbline -1
 0C8D 10                push X
 0C8E 4F                mov X,SP
 0C8F                   .dbline 664
 0C8F           ; }
 0C8F           ; 
 0C8F           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C8F           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C8F           ; void unloadConfig(int config_num)
 0C8F           ; {
 0C8F                   .dbline 665
 0C8F           ;       if(config_num == PC_MODE)
 0C8F 3DFB00            cmp [X-5],0
 0C92 B00B              jnz L195
 0C94 3DFC02            cmp [X-4],2
 0C97 B006              jnz L195
 0C99           X61:
 0C99                   .dbline 666
 0C99           ;       {
 0C99                   .dbline 667
 0C99           ;               UnloadConfig_pc_listener();
 0C99 7C0000            xcall _UnloadConfig_pc_listener
 0C9C                   .dbline 668
 0C9C           ;       }
 0C9C 801D              xjmp L196
 0C9E           L195:
 0C9E                   .dbline 669
 0C9E           ;       else if(config_num == RX_MODE)
 0C9E 3DFB00            cmp [X-5],0
 0CA1 B00B              jnz L197
 0CA3 3DFC01            cmp [X-4],1
 0CA6 B006              jnz L197
 0CA8           X62:
 0CA8                   .dbline 670
 0CA8           ;       {
 0CA8                   .dbline 671
 0CA8           ;               UnloadConfig_receiver_config();
 0CA8 7C0000            xcall _UnloadConfig_receiver_config
 0CAB                   .dbline 672
 0CAB           ;       }
 0CAB 800E              xjmp L198
 0CAD           L197:
 0CAD                   .dbline 673
 0CAD           ;       else if(config_num == TX_MODE)
 0CAD 3DFB00            cmp [X-5],0
 0CB0 B009              jnz L199
 0CB2 3DFC00            cmp [X-4],0
 0CB5 B004              jnz L199
 0CB7           X63:
 0CB7                   .dbline 674
 0CB7           ;       {
 0CB7                   .dbline 675
 0CB7           ;               UnloadConfig_transmitter_config();
 0CB7 7C0000            xcall _UnloadConfig_transmitter_config
 0CBA                   .dbline 676
 0CBA           ;       }
 0CBA           L199:
 0CBA           L198:
 0CBA           L196:
 0CBA                   .dbline -2
 0CBA           L194:
 0CBA 20                pop X
 0CBB                   .dbline 0 ; func end
 0CBB 7F                ret
 0CBC                   .dbsym l config_num -5 I
 0CBC                   .dbend
 0CBC                   .dbfunc e initializeSlaves _initializeSlaves fV
 0CBC           ;              i -> X+4
 0CBC           ;        currVal -> X+2
 0CBC           ;        maxPrev -> X+0
 0CBC           _initializeSlaves::
 0CBC                   .dbline -1
 0CBC 10                push X
 0CBD 4F                mov X,SP
 0CBE 3806              add SP,6
 0CC0                   .dbline 680
 0CC0           ; }
 0CC0           ; 
 0CC0           ; void initializeSlaves(void)
 0CC0           ; {
 0CC0                   .dbline 681
 0CC0           ;       int maxPrev = 0;        // The maximum previous value.
 0CC0 560100            mov [X+1],0
 0CC3 560000            mov [X+0],0
 0CC6                   .dbline 683
 0CC6           ;       int currVal;            // The current number of modules found.
 0CC6           ;       int i = 0;                      // An int for looping.
 0CC6 560500            mov [X+5],0
 0CC9 560400            mov [X+4],0
 0CCC 8028              xjmp L203
 0CCE           L202:
 0CCE                   .dbline 690
 0CCE           ;       
 0CCE           ;       // Do nothing while we find nothing.
 0CCE           ;       //while(!initSweep()) { }
 0CCE           ;       
 0CCE           ;       // Find the maximum value of modules found, it's our number.
 0CCE           ;       while(maxPrev < PREV_NUM_MODULES)
 0CCE           ;       {
 0CCE                   .dbline 693
 0CCE           ;               //for(i = 0; i < NUM_SWEEPS; i++)
 0CCE           ;               //{
 0CCE           ;                       currVal = initSweep();
 0CCE 9063              xcall _initSweep
 0CD0 62D000            mov REG[0xd0],>__r0
 0CD3 5100              mov A,[__r1]
 0CD5 5403              mov [X+3],A
 0CD7 5100              mov A,[__r0]
 0CD9 5402              mov [X+2],A
 0CDB                   .dbline 695
 0CDB           ;                       
 0CDB           ;                       if(currVal > maxPrev)
 0CDB 5201              mov A,[X+1]
 0CDD 1303              sub A,[X+3]
 0CDF 5202              mov A,[X+2]
 0CE1 3180              xor A,-128
 0CE3 5300              mov [__rX],A
 0CE5 5200              mov A,[X+0]
 0CE7 3180              xor A,-128
 0CE9 1A00              sbb A,[__rX]
 0CEB D009              jnc L205
 0CED           X64:
 0CED                   .dbline 696
 0CED           ;                       {
 0CED                   .dbline 697
 0CED           ;                               maxPrev = currVal;
 0CED 5203              mov A,[X+3]
 0CEF 5401              mov [X+1],A
 0CF1 5202              mov A,[X+2]
 0CF3 5400              mov [X+0],A
 0CF5                   .dbline 698
 0CF5           ;                       }
 0CF5           L205:
 0CF5                   .dbline 700
 0CF5           ;               //}
 0CF5           ;       }
 0CF5           L203:
 0CF5                   .dbline 689
 0CF5 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0CF8 5201              mov A,[X+1]
 0CFA 1201              sub A,[_PREV_NUM_MODULES+1]
 0CFC 5100              mov A,[_PREV_NUM_MODULES]
 0CFE 3180              xor A,-128
 0D00 62D000            mov REG[0xd0],>__r0
 0D03 5300              mov [__rX],A
 0D05 5200              mov A,[X+0]
 0D07 3180              xor A,-128
 0D09 1A00              sbb A,[__rX]
 0D0B CFC2              jc L202
 0D0D           X65:
 0D0D                   .dbline 709
 0D0D           ;       
 0D0D           ;       // Sweep until we get the max number again.
 0D0D           ; //    if(currVal != maxPrev)
 0D0D           ; //    {
 0D0D           ; //            while(initSweep() != maxPrev) { }
 0D0D           ; //    }
 0D0D           ;       
 0D0D           ;       // Store the number of modules.
 0D0D           ;       NUM_MODULES = maxPrev;
 0D0D 62D000            mov REG[0xd0],>_NUM_MODULES
 0D10 5201              mov A,[X+1]
 0D12 5301              mov [_NUM_MODULES+1],A
 0D14 5200              mov A,[X+0]
 0D16 5300              mov [_NUM_MODULES],A
 0D18                   .dbline 710
 0D18           ;       PREV_NUM_MODULES = NUM_MODULES;
 0D18 5101              mov A,[_NUM_MODULES+1]
 0D1A 08                push A
 0D1B 5100              mov A,[_NUM_MODULES]
 0D1D 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0D20 5300              mov [_PREV_NUM_MODULES],A
 0D22 18                pop A
 0D23 5301              mov [_PREV_NUM_MODULES+1],A
 0D25                   .dbline 713
 0D25           ;       
 0D25           ;       // Switch back to PC mode.
 0D25           ;       configToggle(PC_MODE);
 0D25 5000              mov A,0
 0D27 08                push A
 0D28 5002              mov A,2
 0D2A 08                push A
 0D2B 9E77              xcall _configToggle
 0D2D 38FE              add SP,-2
 0D2F                   .dbline -2
 0D2F           L201:
 0D2F 38FA              add SP,-6
 0D31 20                pop X
 0D32                   .dbline 0 ; func end
 0D32 7F                ret
 0D33                   .dbsym l i 4 I
 0D33                   .dbsym l currVal 2 I
 0D33                   .dbsym l maxPrev 0 I
 0D33                   .dbend
 0D33                   .dbfunc e initSweep _initSweep fI
 0D33           ;     ping_tries -> X+6
 0D33           ;              i -> X+4
 0D33           ;   num_timeouts -> X+2
 0D33           ; currNumModules -> X+0
 0D33           _initSweep::
 0D33                   .dbline -1
 0D33 10                push X
 0D34 4F                mov X,SP
 0D35 3808              add SP,8
 0D37                   .dbline 717
 0D37           ; }
 0D37           ; 
 0D37           ; int initSweep(void)
 0D37           ; {
 0D37                   .dbline 718
 0D37           ;       int i = 0;                                      // An iterator for looping.
 0D37 560500            mov [X+5],0
 0D3A 560400            mov [X+4],0
 0D3D                   .dbline 719
 0D3D           ;       int num_timeouts = 0;           // The number of consecutive timeouts.
 0D3D 560300            mov [X+3],0
 0D40 560200            mov [X+2],0
 0D43                   .dbline 720
 0D43           ;       int ping_tries = 5;                     // The number of times to try a ping on an unregistered module.
 0D43 560705            mov [X+7],5
 0D46 560600            mov [X+6],0
 0D49                   .dbline 721
 0D49           ;       int currNumModules = 0;         // The number of modules found in this current sweep.
 0D49 560100            mov [X+1],0
 0D4C 560000            mov [X+0],0
 0D4F                   .dbline 724
 0D4F           ;       
 0D4F           ;       // Clear the modules.
 0D4F           ;       clearConfig();
 0D4F 7C0193            xcall _clearConfig
 0D52 8079              xjmp L209
 0D54           L208:
 0D54                   .dbline 729
 0D54           ;       
 0D54           ;       // This loop continuously probes and listens at intervals
 0D54           ;       // set by the RX_TIMEOUT_DURATION variable.
 0D54           ;       while(num_timeouts < MAX_TIMEOUTS)
 0D54           ;       {
 0D54                   .dbline 731
 0D54           ;               // If we are not maxed out on modules, look for more.
 0D54           ;               if(currNumModules < SUGGESTED_NUM_MODULES)
 0D54 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0D57 5201              mov A,[X+1]
 0D59 1201              sub A,[_SUGGESTED_NUM_MODULES+1]
 0D5B 5100              mov A,[_SUGGESTED_NUM_MODULES]
 0D5D 3180              xor A,-128
 0D5F 62D000            mov REG[0xd0],>__r0
 0D62 5300              mov [__rX],A
 0D64 5200              mov A,[X+0]
 0D66 3180              xor A,-128
 0D68 1A00              sbb A,[__rX]
 0D6A D006              jnc L211
 0D6C           X66:
 0D6C                   .dbline 732
 0D6C           ;               {
 0D6C                   .dbline 733
 0D6C           ;                       sayHello();
 0D6C 7C0207            xcall _sayHello
 0D6F                   .dbline 734
 0D6F           ;               }
 0D6F 8007              xjmp L212
 0D71           L211:
 0D71                   .dbline 736
 0D71           ;               else
 0D71           ;               {
 0D71                   .dbline 737
 0D71           ;                       num_timeouts = MAX_TIMEOUTS;
 0D71 560305            mov [X+3],5
 0D74 560200            mov [X+2],0
 0D77                   .dbline 738
 0D77           ;               }
 0D77           L212:
 0D77                   .dbline 740
 0D77           ;                       
 0D77           ;               if(validTransmission())
 0D77 7C025F            xcall _validTransmission
 0D7A 62D000            mov REG[0xd0],>__r0
 0D7D 3C0000            cmp [__r0],0
 0D80 B006              jnz X67
 0D82 3C0000            cmp [__r1],0
 0D85 A041              jz L213
 0D87           X67:
 0D87                   .dbline 741
 0D87           ;               {
 0D87                   .dbline 742
 0D87           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0D87 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0D8A 3C00C8            cmp [_COMMAND_TYPE],-56
 0D8D B03E              jnz L214
 0D8F                   .dbline 743
 0D8F           ;                       {
 0D8F                   .dbline 745
 0D8F           ;                               // If this is for me, assign them an ID.
 0D8F           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0D8F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D92 3C0000            cmp [_COMMAND_DESTINATION],0
 0D95 B036              jnz L214
 0D97                   .dbline 746
 0D97           ;                               {
 0D97                   .dbline 747
 0D97           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D97 560300            mov [X+3],0
 0D9A 560200            mov [X+2],0
 0D9D                   .dbline 749
 0D9D           ;               
 0D9D           ;                                       if(assignID(currNumModules+1))
 0D9D 62D000            mov REG[0xd0],>__r0
 0DA0 5201              mov A,[X+1]
 0DA2 0101              add A,1
 0DA4 5300              mov [__r1],A
 0DA6 5200              mov A,[X+0]
 0DA8 0900              adc A,0
 0DAA 08                push A
 0DAB 5100              mov A,[__r1]
 0DAD 08                push A
 0DAE 7C00E9            xcall _assignID
 0DB1 38FE              add SP,-2
 0DB3 62D000            mov REG[0xd0],>__r0
 0DB6 3C0000            cmp [__r0],0
 0DB9 B006              jnz X68
 0DBB 3C0000            cmp [__r1],0
 0DBE A00D              jz L214
 0DC0           X68:
 0DC0                   .dbline 750
 0DC0           ;                                       {
 0DC0                   .dbline 751
 0DC0           ;                                               currNumModules++;               // Increment the number of modules connected.
 0DC0 7701              inc [X+1]
 0DC2 0F0000            adc [X+0],0
 0DC5                   .dbline 752
 0DC5           ;                                       }
 0DC5                   .dbline 753
 0DC5           ;                               }
 0DC5                   .dbline 754
 0DC5           ;                       }
 0DC5                   .dbline 755
 0DC5           ;               }
 0DC5 8006              xjmp L214
 0DC7           L213:
 0DC7                   .dbline 757
 0DC7           ;               else
 0DC7           ;               {       
 0DC7                   .dbline 758
 0DC7           ;                       num_timeouts++;
 0DC7 7703              inc [X+3]
 0DC9 0F0200            adc [X+2],0
 0DCC                   .dbline 759
 0DCC           ;               }
 0DCC           L214:
 0DCC                   .dbline 760
 0DCC           ;       }
 0DCC           L209:
 0DCC                   .dbline 728
 0DCC 5203              mov A,[X+3]
 0DCE 1105              sub A,5
 0DD0 5202              mov A,[X+2]
 0DD2 3180              xor A,-128
 0DD4 1980              sbb A,(0 ^ 0x80)
 0DD6 CF7D              jc L208
 0DD8           X69:
 0DD8                   .dbline 763
 0DD8           ;       
 0DD8           ;       // If we didn't find any new modules, check to see if some already exist.
 0DD8           ;       if(!currNumModules)
 0DD8 3D0000            cmp [X+0],0
 0DDB B056              jnz L221
 0DDD 3D0100            cmp [X+1],0
 0DE0 B051              jnz L221
 0DE2           X70:
 0DE2                   .dbline 764
 0DE2           ;       {
 0DE2                   .dbline 766
 0DE2           ;               // Try to ping the next module up from our current number ping_tries times.
 0DE2           ;               for(i = 0; i < ping_tries; i++)
 0DE2 560500            mov [X+5],0
 0DE5 560400            mov [X+4],0
 0DE8 8034              xjmp L226
 0DEA           L223:
 0DEA                   .dbline 767
 0DEA           ;               {       
 0DEA                   .dbline 768
 0DEA           ;                       if(pingModule(currNumModules+1))
 0DEA 62D000            mov REG[0xd0],>__r0
 0DED 5201              mov A,[X+1]
 0DEF 0101              add A,1
 0DF1 5300              mov [__r1],A
 0DF3 5200              mov A,[X+0]
 0DF5 0900              adc A,0
 0DF7 08                push A
 0DF8 5100              mov A,[__r1]
 0DFA 08                push A
 0DFB 7C0046            xcall _pingModule
 0DFE 38FE              add SP,-2
 0E00 62D000            mov REG[0xd0],>__r0
 0E03 3C0000            cmp [__r0],0
 0E06 B006              jnz X71
 0E08 3C0000            cmp [__r1],0
 0E0B A00C              jz L227
 0E0D           X71:
 0E0D                   .dbline 769
 0E0D           ;                       {
 0E0D                   .dbline 770
 0E0D           ;                               currNumModules++;
 0E0D 7701              inc [X+1]
 0E0F 0F0000            adc [X+0],0
 0E12                   .dbline 771
 0E12           ;                               i = 0;
 0E12 560500            mov [X+5],0
 0E15 560400            mov [X+4],0
 0E18                   .dbline 772
 0E18           ;                       }
 0E18           L227:
 0E18                   .dbline 773
 0E18           ;               }
 0E18           L224:
 0E18                   .dbline 766
 0E18 7705              inc [X+5]
 0E1A 0F0400            adc [X+4],0
 0E1D           L226:
 0E1D                   .dbline 766
 0E1D 5205              mov A,[X+5]
 0E1F 1307              sub A,[X+7]
 0E21 5206              mov A,[X+6]
 0E23 3180              xor A,-128
 0E25 62D000            mov REG[0xd0],>__r0
 0E28 5300              mov [__rX],A
 0E2A 5204              mov A,[X+4]
 0E2C 3180              xor A,-128
 0E2E 1A00              sbb A,[__rX]
 0E30 CFB9              jc L223
 0E32           X72:
 0E32                   .dbline 774
 0E32           ;       }
 0E32           L221:
 0E32                   .dbline 776
 0E32           ;       
 0E32           ;       return currNumModules;
 0E32 62D000            mov REG[0xd0],>__r0
 0E35 5201              mov A,[X+1]
 0E37 5300              mov [__r1],A
 0E39 5200              mov A,[X+0]
 0E3B 5300              mov [__r0],A
 0E3D                   .dbline -2
 0E3D           L207:
 0E3D 38F8              add SP,-8
 0E3F 20                pop X
 0E40                   .dbline 0 ; func end
 0E40 7F                ret
 0E41                   .dbsym l ping_tries 6 I
 0E41                   .dbsym l i 4 I
 0E41                   .dbsym l num_timeouts 2 I
 0E41                   .dbsym l currNumModules 0 I
 0E41                   .dbend
 0E41                   .dbfunc e xmitWait _xmitWait fV
 0E41           ;              i -> X+0
 0E41           _xmitWait::
 0E41                   .dbline -1
 0E41 10                push X
 0E42 4F                mov X,SP
 0E43 3802              add SP,2
 0E45                   .dbline 780
 0E45           ; }
 0E45           ; 
 0E45           ; void xmitWait(void)
 0E45           ; {
 0E45                   .dbline 783
 0E45           ;       int i;
 0E45           ;       
 0E45           ;       for(i = 0; i < 25; i++)
 0E45 560100            mov [X+1],0
 0E48 560000            mov [X+0],0
 0E4B           L230:
 0E4B                   .dbline 784
 0E4B           ;       {
 0E4B                   .dbline 786
 0E4B           ;               // Sit here and spin for about 50 microseconds.
 0E4B           ;       }
 0E4B           L231:
 0E4B                   .dbline 783
 0E4B 7701              inc [X+1]
 0E4D 0F0000            adc [X+0],0
 0E50                   .dbline 783
 0E50 5201              mov A,[X+1]
 0E52 1119              sub A,25
 0E54 5200              mov A,[X+0]
 0E56 3180              xor A,-128
 0E58 1980              sbb A,(0 ^ 0x80)
 0E5A CFF0              jc L230
 0E5C           X73:
 0E5C                   .dbline -2
 0E5C           L229:
 0E5C 38FE              add SP,-2
 0E5E 20                pop X
 0E5F                   .dbline 0 ; func end
 0E5F 7F                ret
 0E60                   .dbsym l i 0 I
 0E60                   .dbend
 0E60                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0E60           _TX_TIMEOUT_ISR::
 0E60                   .dbline -1
 0E60 71C0              or F,-64
 0E62 08                push A
 0E63 5DD0              mov A,REG[0xd0]
 0E65 08                push A
 0E66                   .dbline 790
 0E66           ; }
 0E66           ; 
 0E66           ; void TX_TIMEOUT_ISR(void)
 0E66           ; {     
 0E66                   .dbline 791
 0E66           ;       TIMEOUT++;
 0E66 62D000            mov REG[0xd0],>_TIMEOUT
 0E69 7601              inc [_TIMEOUT+1]
 0E6B 0E0000            adc [_TIMEOUT],0
 0E6E                   .dbline 793
 0E6E           ;       
 0E6E           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0E6E 62DAFD            mov REG[0xda],-3
 0E71                   .dbline -2
 0E71           L234:
 0E71 18                pop A
 0E72 60D0              mov REG[208],A
 0E74 18                pop A
 0E75                   .dbline 0 ; func end
 0E75 7E                reti
 0E76                   .dbend
 0E76                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0E76           _RX_TIMEOUT_ISR::
 0E76                   .dbline -1
 0E76 71C0              or F,-64
 0E78 08                push A
 0E79 5DD0              mov A,REG[0xd0]
 0E7B 08                push A
 0E7C                   .dbline 797
 0E7C           ; }
 0E7C           ; 
 0E7C           ; void RX_TIMEOUT_ISR(void)
 0E7C           ; {     
 0E7C                   .dbline 798
 0E7C           ;       TIMEOUT++;
 0E7C 62D000            mov REG[0xd0],>_TIMEOUT
 0E7F 7601              inc [_TIMEOUT+1]
 0E81 0E0000            adc [_TIMEOUT],0
 0E84                   .dbline 800
 0E84           ;       
 0E84           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0E84 62DAFD            mov REG[0xda],-3
 0E87                   .dbline -2
 0E87           L235:
 0E87 18                pop A
 0E88 60D0              mov REG[208],A
 0E8A 18                pop A
 0E8B                   .dbline 0 ; func end
 0E8B 7E                reti
 0E8C                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _SUGGESTED_NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e SUGGESTED_NUM_MODULES _SUGGESTED_NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PREV_NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e PREV_NUM_MODULES _PREV_NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
