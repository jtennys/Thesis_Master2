 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 98
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"
 0000           ; #include <stdlib.h>
 0000           ; #include <string.h>
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (2)
 0000           ; #define               RX_MODE                                         (1)
 0000           ; #define               TX_MODE                                         (0)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR                                           (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (3)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; #define               SERVO_FIND_TIME                         (50)    // The wait time after issuing clear config.
 0000           ; 
 0000           ; #define               MAX_TIMEOUTS                            (5)             // Number of timeouts allowed before hello mode exit.
 0000           ; #define               NUM_SWEEPS                                      (5)             // The number of module sweeps to do at init.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; #define               SERVO_START                                     (255)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; 
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; 
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; 
 0000           ; int validTransmission(void);
 0000           ; 
 0000           ; void decodeTransmission(void);
 0000           ; 
 0000           ; 
 0000           ; void sayHello(void);
 0000           ; 
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; 
 0000           ; void clearConfig(void);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeSlaves(void);
 0000           ; int initSweep(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; 
 0000           ; // This flag is set if there is a timeout.
 0000           ; int TIMEOUT;
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 100
 0000           ;       // Initialize the number of modules.
 0000           ;       NUM_MODULES = 0;
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 103
 0009           ;       
 0009           ;       // Activate GPIO ISR.
 0009           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0009 43E020            or REG[0xe0],32
 000C                   .dbline 106
 000C           ;       
 000C           ;       // Turn on global interrupts for the transmission timeout timer.
 000C           ;       M8C_EnableGInt;
 000C 7101                      or  F, 01h
 000E           
 000E 8021              xjmp L3
 0010           L2:
 0010                   .dbline 109
 0010           ;       
 0010           ;       while(1)
 0010           ;       {
 0010                   .dbline 110
 0010           ;               if(!NUM_MODULES)
 0010 62D000            mov REG[0xd0],>_NUM_MODULES
 0013 3C0000            cmp [_NUM_MODULES],0
 0016 B00B              jnz L5
 0018 3C0100            cmp [_NUM_MODULES+1],0
 001B B006              jnz L5
 001D           X1:
 001D                   .dbline 111
 001D           ;               {
 001D                   .dbline 112
 001D           ;                       initializeSlaves();
 001D 7C0C22            xcall _initializeSlaves
 0020                   .dbline 113
 0020           ;               }
 0020 800F              xjmp L6
 0022           L5:
 0022                   .dbline 114
 0022           ;               else if(COMP_SERIAL_bCmdCheck())                // If there's a computer command, read it.
 0022 10                push X
 0023 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0026 62D000            mov REG[0xd0],>__r0
 0029 20                pop X
 002A 3900              cmp A,0
 002C A003              jz L7
 002E                   .dbline 115
 002E           ;               {
 002E                   .dbline 116
 002E           ;                       decodeTransmission();
 002E 932A              xcall _decodeTransmission
 0030                   .dbline 117
 0030           ;               }
 0030           L7:
 0030           L6:
 0030                   .dbline 118
 0030           ;       }
 0030           L3:
 0030                   .dbline 108
 0030 8FDF              xjmp L2
 0032           X0:
 0032                   .dbline -2
 0032           L1:
 0032                   .dbline 0 ; func end
 0032 8FFF              jmp .
 0034                   .dbend
 0034                   .dbfunc e pingModule _pingModule fI
 0034           ;       response -> X+0
 0034           ;      module_id -> X-5
 0034           _pingModule::
 0034                   .dbline -1
 0034 10                push X
 0035 4F                mov X,SP
 0036 3802              add SP,2
 0038                   .dbline 122
 0038           ; }
 0038           ; 
 0038           ; int pingModule(int module_id)
 0038           ; {
 0038                   .dbline 123
 0038           ;       int response = 0;
 0038 560100            mov [X+1],0
 003B 560000            mov [X+0],0
 003E                   .dbline 125
 003E           ;       
 003E           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 003E 5000              mov A,0
 0040 08                push A
 0041 08                push A
 0042 7C0B0A            xcall _configToggle
 0045 38FE              add SP,-2
 0047                   .dbline 128
 0047           ;                       
 0047           ;       // Transmit a hello.
 0047           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0047 10                push X
 0048 50FC              mov A,-4
 004A 7C0000            xcall _TRANSMIT_PutChar
 004D 20                pop X
 004E                   .dbline 129
 004E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 004E 10                push X
 004F 50FC              mov A,-4
 0051 7C0000            xcall _TRANSMIT_PutChar
 0054 20                pop X
 0055                   .dbline 130
 0055           ;       TRANSMIT_PutChar(MASTER_ID);
 0055 10                push X
 0056 5000              mov A,0
 0058 7C0000            xcall _TRANSMIT_PutChar
 005B 20                pop X
 005C                   .dbline 131
 005C           ;       TRANSMIT_PutChar(module_id);
 005C 62D000            mov REG[0xd0],>__r0
 005F 52FC              mov A,[X-4]
 0061 10                push X
 0062 7C0000            xcall _TRANSMIT_PutChar
 0065 20                pop X
 0066                   .dbline 132
 0066           ;       TRANSMIT_PutChar(PING);
 0066 10                push X
 0067 50CB              mov A,-53
 0069 7C0000            xcall _TRANSMIT_PutChar
 006C 20                pop X
 006D                   .dbline 133
 006D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 006D 10                push X
 006E 50FD              mov A,-3
 0070 7C0000            xcall _TRANSMIT_PutChar
 0073 20                pop X
 0074                   .dbline 134
 0074           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0074 10                push X
 0075 50FD              mov A,-3
 0077 7C0000            xcall _TRANSMIT_PutChar
 007A 20                pop X
 007B           L10:
 007B                   .dbline 137
 007B           ;       
 007B           ;       // Wait for the transmission to finish.
 007B           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 007B           L11:
 007B                   .dbline 137
 007B 10                push X
 007C 7C0000            xcall _TRANSMIT_bReadTxStatus
 007F 62D000            mov REG[0xd0],>__r0
 0082 20                pop X
 0083 5300              mov [__r0],A
 0085 470020            tst [__r0],32
 0088 AFF2              jz L10
 008A                   .dbline 139
 008A           ;       
 008A           ;       xmitWait();
 008A 7C0DAF            xcall _xmitWait
 008D                   .dbline 141
 008D           ; 
 008D           ;       if(validTransmission())
 008D 91BE              xcall _validTransmission
 008F 62D000            mov REG[0xd0],>__r0
 0092 3C0000            cmp [__r0],0
 0095 B006              jnz X2
 0097 3C0000            cmp [__r1],0
 009A A02D              jz L13
 009C           X2:
 009C                   .dbline 142
 009C           ;       {
 009C                   .dbline 143
 009C           ;               if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 009C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 009F 3C00CB            cmp [_COMMAND_TYPE],-53
 00A2 B025              jnz L15
 00A4                   .dbline 144
 00A4           ;               {
 00A4                   .dbline 146
 00A4           ;                       // If this is for me, check who it was from.
 00A4           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 00A4 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00A7 3C0000            cmp [_COMMAND_DESTINATION],0
 00AA B01D              jnz L17
 00AC                   .dbline 147
 00AC           ;                       {
 00AC                   .dbline 148
 00AC           ;                               if(COMMAND_SOURCE == module_id)
 00AC 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00AF 5100              mov A,[_COMMAND_SOURCE]
 00B1 62D000            mov REG[0xd0],>__r0
 00B4 5300              mov [__r1],A
 00B6 5000              mov A,0
 00B8 3BFB              cmp A,[X-5]
 00BA B00D              jnz L19
 00BC 5100              mov A,[__r1]
 00BE 3BFC              cmp A,[X-4]
 00C0 B007              jnz L19
 00C2           X3:
 00C2                   .dbline 149
 00C2           ;                               {
 00C2                   .dbline 150
 00C2           ;                                       response = 1;
 00C2 560101            mov [X+1],1
 00C5 560000            mov [X+0],0
 00C8                   .dbline 151
 00C8           ;                               }
 00C8           L19:
 00C8                   .dbline 152
 00C8           ;                       }
 00C8           L17:
 00C8                   .dbline 153
 00C8           ;               }
 00C8           L15:
 00C8                   .dbline 154
 00C8           ;       }
 00C8           L13:
 00C8                   .dbline 156
 00C8           ;       
 00C8           ;       return response;
 00C8 62D000            mov REG[0xd0],>__r0
 00CB 5201              mov A,[X+1]
 00CD 5300              mov [__r1],A
 00CF 5200              mov A,[X+0]
 00D1 5300              mov [__r0],A
 00D3                   .dbline -2
 00D3           L9:
 00D3 38FE              add SP,-2
 00D5 20                pop X
 00D6                   .dbline 0 ; func end
 00D6 7F                ret
 00D7                   .dbsym l response 0 I
 00D7                   .dbsym l module_id -5 I
 00D7                   .dbend
 00D7                   .dbfunc e assignID _assignID fI
 00D7           ;        success -> X+0
 00D7           ;    assigned_ID -> X-5
 00D7           _assignID::
 00D7                   .dbline -1
 00D7 10                push X
 00D8 4F                mov X,SP
 00D9 3802              add SP,2
 00DB                   .dbline 160
 00DB           ; }
 00DB           ; 
 00DB           ; int assignID(int assigned_ID)
 00DB           ; {
 00DB                   .dbline 161
 00DB           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 00DB 560100            mov [X+1],0
 00DE 560000            mov [X+0],0
 00E1                   .dbline 163
 00E1           ;       
 00E1           ;       configToggle(TX_MODE);  // Switch to TX mode.
 00E1 5000              mov A,0
 00E3 08                push A
 00E4 08                push A
 00E5 7C0B0A            xcall _configToggle
 00E8 38FE              add SP,-2
 00EA                   .dbline 166
 00EA           ; 
 00EA           ;       // Transmit the assignment.
 00EA           ;       TRANSMIT_PutChar(START_TRANSMIT);
 00EA 10                push X
 00EB 50FC              mov A,-4
 00ED 7C0000            xcall _TRANSMIT_PutChar
 00F0 20                pop X
 00F1                   .dbline 167
 00F1           ;       TRANSMIT_PutChar(START_TRANSMIT);
 00F1 10                push X
 00F2 50FC              mov A,-4
 00F4 7C0000            xcall _TRANSMIT_PutChar
 00F7 20                pop X
 00F8                   .dbline 168
 00F8           ;       TRANSMIT_PutChar(MASTER_ID);
 00F8 10                push X
 00F9 5000              mov A,0
 00FB 7C0000            xcall _TRANSMIT_PutChar
 00FE 20                pop X
 00FF                   .dbline 169
 00FF           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 00FF 10                push X
 0100 50FB              mov A,-5
 0102 7C0000            xcall _TRANSMIT_PutChar
 0105 20                pop X
 0106                   .dbline 170
 0106           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0106 10                push X
 0107 50C9              mov A,-55
 0109 7C0000            xcall _TRANSMIT_PutChar
 010C 20                pop X
 010D                   .dbline 171
 010D           ;       TRANSMIT_PutChar(assigned_ID);
 010D 62D000            mov REG[0xd0],>__r0
 0110 52FC              mov A,[X-4]
 0112 10                push X
 0113 7C0000            xcall _TRANSMIT_PutChar
 0116 20                pop X
 0117                   .dbline 172
 0117           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0117 10                push X
 0118 50FD              mov A,-3
 011A 7C0000            xcall _TRANSMIT_PutChar
 011D 20                pop X
 011E                   .dbline 173
 011E           ;       TRANSMIT_PutChar(END_TRANSMIT);
 011E 10                push X
 011F 50FD              mov A,-3
 0121 7C0000            xcall _TRANSMIT_PutChar
 0124 20                pop X
 0125           L22:
 0125                   .dbline 176
 0125           ;       
 0125           ;       // Wait for the transmission to finish.
 0125           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0125           L23:
 0125                   .dbline 176
 0125 10                push X
 0126 7C0000            xcall _TRANSMIT_bReadTxStatus
 0129 62D000            mov REG[0xd0],>__r0
 012C 20                pop X
 012D 5300              mov [__r0],A
 012F 470020            tst [__r0],32
 0132 AFF2              jz L22
 0134                   .dbline 178
 0134           ;       
 0134           ;       xmitWait();
 0134 7C0DAF            xcall _xmitWait
 0137                   .dbline 180
 0137           ;       
 0137           ;       if(validTransmission())
 0137 9114              xcall _validTransmission
 0139 62D000            mov REG[0xd0],>__r0
 013C 3C0000            cmp [__r0],0
 013F B006              jnz X4
 0141 3C0000            cmp [__r1],0
 0144 A02D              jz L25
 0146           X4:
 0146                   .dbline 181
 0146           ;       {
 0146                   .dbline 182
 0146           ;               if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 0146 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0149 3C00CA            cmp [_COMMAND_TYPE],-54
 014C B025              jnz L27
 014E                   .dbline 183
 014E           ;               {
 014E                   .dbline 185
 014E           ;                       // If this is for me, check who it was from.
 014E           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 014E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0151 3C0000            cmp [_COMMAND_DESTINATION],0
 0154 B01D              jnz L29
 0156                   .dbline 186
 0156           ;                       {
 0156                   .dbline 187
 0156           ;                               if(COMMAND_SOURCE == assigned_ID)
 0156 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0159 5100              mov A,[_COMMAND_SOURCE]
 015B 62D000            mov REG[0xd0],>__r0
 015E 5300              mov [__r1],A
 0160 5000              mov A,0
 0162 3BFB              cmp A,[X-5]
 0164 B00D              jnz L31
 0166 5100              mov A,[__r1]
 0168 3BFC              cmp A,[X-4]
 016A B007              jnz L31
 016C           X5:
 016C                   .dbline 188
 016C           ;                               {
 016C                   .dbline 189
 016C           ;                                       success = 1;
 016C 560101            mov [X+1],1
 016F 560000            mov [X+0],0
 0172                   .dbline 190
 0172           ;                               }
 0172           L31:
 0172                   .dbline 191
 0172           ;                       }
 0172           L29:
 0172                   .dbline 192
 0172           ;               }
 0172           L27:
 0172                   .dbline 193
 0172           ;       }
 0172           L25:
 0172                   .dbline 195
 0172           ;       
 0172           ;       return success;
 0172 62D000            mov REG[0xd0],>__r0
 0175 5201              mov A,[X+1]
 0177 5300              mov [__r1],A
 0179 5200              mov A,[X+0]
 017B 5300              mov [__r0],A
 017D                   .dbline -2
 017D           L21:
 017D 38FE              add SP,-2
 017F 20                pop X
 0180                   .dbline 0 ; func end
 0180 7F                ret
 0181                   .dbsym l success 0 I
 0181                   .dbsym l assigned_ID -5 I
 0181                   .dbend
 0181                   .dbfunc e clearConfig _clearConfig fV
 0181           ;       response -> X+0
 0181           _clearConfig::
 0181                   .dbline -1
 0181 10                push X
 0182 4F                mov X,SP
 0183 3802              add SP,2
 0185                   .dbline 199
 0185           ; }
 0185           ; 
 0185           ; void clearConfig(void)
 0185           ; {
 0185                   .dbline 200
 0185           ;       int response = 0;
 0185 560100            mov [X+1],0
 0188 560000            mov [X+0],0
 018B                   .dbline 202
 018B           ;       
 018B           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 018B 5000              mov A,0
 018D 08                push A
 018E 08                push A
 018F 7C0B0A            xcall _configToggle
 0192 38FE              add SP,-2
 0194                   .dbline 205
 0194           ;                       
 0194           ;       // Transmit a clear.
 0194           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0194 10                push X
 0195 50FC              mov A,-4
 0197 7C0000            xcall _TRANSMIT_PutChar
 019A 20                pop X
 019B                   .dbline 206
 019B           ;       TRANSMIT_PutChar(START_TRANSMIT);
 019B 10                push X
 019C 50FC              mov A,-4
 019E 7C0000            xcall _TRANSMIT_PutChar
 01A1 20                pop X
 01A2                   .dbline 207
 01A2           ;       TRANSMIT_PutChar(MASTER_ID);
 01A2 10                push X
 01A3 5000              mov A,0
 01A5 7C0000            xcall _TRANSMIT_PutChar
 01A8 20                pop X
 01A9                   .dbline 208
 01A9           ;       TRANSMIT_PutChar(BROADCAST);
 01A9 10                push X
 01AA 50FE              mov A,-2
 01AC 7C0000            xcall _TRANSMIT_PutChar
 01AF 20                pop X
 01B0                   .dbline 209
 01B0           ;       TRANSMIT_PutChar(CLEAR);
 01B0 10                push X
 01B1 50CC              mov A,-52
 01B3 7C0000            xcall _TRANSMIT_PutChar
 01B6 20                pop X
 01B7                   .dbline 210
 01B7           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01B7 10                push X
 01B8 50FD              mov A,-3
 01BA 7C0000            xcall _TRANSMIT_PutChar
 01BD 20                pop X
 01BE                   .dbline 211
 01BE           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01BE 10                push X
 01BF 50FD              mov A,-3
 01C1 7C0000            xcall _TRANSMIT_PutChar
 01C4 20                pop X
 01C5           L34:
 01C5                   .dbline 214
 01C5           ;       
 01C5           ;       // Wait for the transmission to finish.
 01C5           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01C5           L35:
 01C5                   .dbline 214
 01C5 10                push X
 01C6 7C0000            xcall _TRANSMIT_bReadTxStatus
 01C9 62D000            mov REG[0xd0],>__r0
 01CC 20                pop X
 01CD 5300              mov [__r0],A
 01CF 470020            tst [__r0],32
 01D2 AFF2              jz L34
 01D4                   .dbline 216
 01D4           ;       
 01D4           ;       xmitWait();
 01D4 7C0DAF            xcall _xmitWait
 01D7                   .dbline 219
 01D7           ;       
 01D7           ;       // Wait for servo find time.
 01D7           ;       configToggle(RX_MODE);
 01D7 5000              mov A,0
 01D9 08                push A
 01DA 5001              mov A,1
 01DC 08                push A
 01DD 7C0B0A            xcall _configToggle
 01E0 38FE              add SP,-2
 01E2           L37:
 01E2                   .dbline 220
 01E2           ;       while(TIMEOUT < SERVO_FIND_TIME) { }
 01E2                   .dbline 220
 01E2           L38:
 01E2                   .dbline 220
 01E2 62D000            mov REG[0xd0],>_TIMEOUT
 01E5 5101              mov A,[_TIMEOUT+1]
 01E7 1132              sub A,50
 01E9 5100              mov A,[_TIMEOUT]
 01EB 3180              xor A,-128
 01ED 1980              sbb A,(0 ^ 0x80)
 01EF CFF2              jc L37
 01F1           X6:
 01F1                   .dbline -2
 01F1           L33:
 01F1 38FE              add SP,-2
 01F3 20                pop X
 01F4                   .dbline 0 ; func end
 01F4 7F                ret
 01F5                   .dbsym l response 0 I
 01F5                   .dbend
 01F5                   .dbfunc e sayHello _sayHello fV
 01F5           _sayHello::
 01F5                   .dbline -1
 01F5                   .dbline 225
 01F5           ; }
 01F5           ; 
 01F5           ; // This function transmits a hello message.
 01F5           ; void sayHello(void)
 01F5           ; {
 01F5                   .dbline 226
 01F5           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 01F5 5000              mov A,0
 01F7 08                push A
 01F8 08                push A
 01F9 7C0B0A            xcall _configToggle
 01FC 38FE              add SP,-2
 01FE                   .dbline 229
 01FE           ;                       
 01FE           ;       // Transmit a hello.
 01FE           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01FE 10                push X
 01FF 50FC              mov A,-4
 0201 7C0000            xcall _TRANSMIT_PutChar
 0204 20                pop X
 0205                   .dbline 230
 0205           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0205 10                push X
 0206 50FC              mov A,-4
 0208 7C0000            xcall _TRANSMIT_PutChar
 020B 20                pop X
 020C                   .dbline 231
 020C           ;       TRANSMIT_PutChar(MASTER_ID);
 020C 10                push X
 020D 5000              mov A,0
 020F 7C0000            xcall _TRANSMIT_PutChar
 0212 20                pop X
 0213                   .dbline 232
 0213           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0213 10                push X
 0214 50FB              mov A,-5
 0216 7C0000            xcall _TRANSMIT_PutChar
 0219 20                pop X
 021A                   .dbline 233
 021A           ;       TRANSMIT_PutChar(HELLO_BYTE);
 021A 10                push X
 021B 50C8              mov A,-56
 021D 7C0000            xcall _TRANSMIT_PutChar
 0220 20                pop X
 0221                   .dbline 234
 0221           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0221 10                push X
 0222 50FD              mov A,-3
 0224 7C0000            xcall _TRANSMIT_PutChar
 0227 20                pop X
 0228                   .dbline 235
 0228           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0228 10                push X
 0229 50FD              mov A,-3
 022B 7C0000            xcall _TRANSMIT_PutChar
 022E 20                pop X
 022F           L41:
 022F                   .dbline 238
 022F           ;       
 022F           ;       // Wait for the transmission to finish.
 022F           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 022F           L42:
 022F                   .dbline 238
 022F 10                push X
 0230 7C0000            xcall _TRANSMIT_bReadTxStatus
 0233 62D000            mov REG[0xd0],>__r0
 0236 20                pop X
 0237 5300              mov [__r0],A
 0239 470020            tst [__r0],32
 023C AFF2              jz L41
 023E                   .dbline 240
 023E           ;       
 023E           ;       xmitWait();
 023E 7C0DAF            xcall _xmitWait
 0241                   .dbline 242
 0241           ;       
 0241           ;       configToggle(RX_MODE);                          // Listen for the response.
 0241 5000              mov A,0
 0243 08                push A
 0244 5001              mov A,1
 0246 08                push A
 0247 7C0B0A            xcall _configToggle
 024A 38FE              add SP,-2
 024C                   .dbline -2
 024C           L40:
 024C                   .dbline 0 ; func end
 024C 7F                ret
 024D                   .dbend
 024D                   .dbfunc e validTransmission _validTransmission fI
 024D           ; valid_transmit -> X+3
 024D           ;              i -> X+1
 024D           ;       tempByte -> X+0
 024D           _validTransmission::
 024D                   .dbline -1
 024D 10                push X
 024E 4F                mov X,SP
 024F 3805              add SP,5
 0251                   .dbline 247
 0251           ; }
 0251           ; 
 0251           ; // This function returns whether or not a valid transmission has been received.
 0251           ; int validTransmission(void)
 0251           ; {
 0251                   .dbline 248
 0251           ;       int valid_transmit = 0;
 0251 560400            mov [X+4],0
 0254 560300            mov [X+3],0
 0257                   .dbline 249
 0257           ;       int i = 0;
 0257 560200            mov [X+2],0
 025A 560100            mov [X+1],0
 025D                   .dbline 250
 025D           ;       char tempByte = 0;
 025D 560000            mov [X+0],0
 0260                   .dbline 252
 0260           ;       
 0260           ;       configToggle(RX_MODE);  // Listen for the response.
 0260 5000              mov A,0
 0262 08                push A
 0263 5001              mov A,1
 0265 08                push A
 0266 7C0B0A            xcall _configToggle
 0269 38FE              add SP,-2
 026B 80C2              xjmp L46
 026D           L45:
 026D                   .dbline 255
 026D           ;       
 026D           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 026D           ;       {
 026D                   .dbline 256
 026D           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 026D 10                push X
 026E 7C0000            xcall _RECEIVE_cReadChar
 0271 62D000            mov REG[0xd0],>__r0
 0274 20                pop X
 0275 39FC              cmp A,-4
 0277 B0B6              jnz L48
 0279                   .dbline 257
 0279           ;               {
 0279 80A5              xjmp L51
 027B           L50:
 027B                   .dbline 259
 027B           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 027B           ;                       {
 027B                   .dbline 260
 027B           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 027B 10                push X
 027C 7C0000            xcall _RECEIVE_cReadChar
 027F 62D000            mov REG[0xd0],>__r0
 0282 20                pop X
 0283 39FC              cmp A,-4
 0285 B099              jnz L53
 0287                   .dbline 261
 0287           ;                               {
 0287 8088              xjmp L56
 0289           L55:
 0289                   .dbline 263
 0289           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0289           ;                                       {
 0289                   .dbline 264
 0289           ;                                               if(tempByte = RECEIVE_cReadChar())
 0289 10                push X
 028A 7C0000            xcall _RECEIVE_cReadChar
 028D 20                pop X
 028E 5400              mov [X+0],A
 0290 3900              cmp A,0
 0292 A07D              jz L58
 0294                   .dbline 265
 0294           ;                                               {
 0294                   .dbline 266
 0294           ;                                                       COMMAND_SOURCE = tempByte;
 0294 5200              mov A,[X+0]
 0296 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0299 5300              mov [_COMMAND_SOURCE],A
 029B 8065              xjmp L61
 029D           L60:
 029D                   .dbline 269
 029D           ;                                                       
 029D           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 029D           ;                                                       {
 029D                   .dbline 270
 029D           ;                                                               if(tempByte = RECEIVE_cReadChar())
 029D 10                push X
 029E 7C0000            xcall _RECEIVE_cReadChar
 02A1 62D000            mov REG[0xd0],>__r0
 02A4 20                pop X
 02A5 5400              mov [X+0],A
 02A7 3900              cmp A,0
 02A9 A057              jz L63
 02AB                   .dbline 271
 02AB           ;                                                               {
 02AB                   .dbline 272
 02AB           ;                                                                       if(tempByte >= HELLO_BYTE)
 02AB 3D00C8            cmp [X+0],-56
 02AE C052              jc L65
 02B0           X7:
 02B0                   .dbline 273
 02B0           ;                                                                       {
 02B0                   .dbline 274
 02B0           ;                                                                               COMMAND_TYPE = tempByte;
 02B0 5200              mov A,[X+0]
 02B2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02B5 5300              mov [_COMMAND_TYPE],A
 02B7 803A              xjmp L68
 02B9           L67:
 02B9                   .dbline 277
 02B9           ;                                                                               
 02B9           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 02B9           ;                                                                               {
 02B9                   .dbline 278
 02B9           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 02B9 10                push X
 02BA 7C0000            xcall _RECEIVE_cReadChar
 02BD 62D000            mov REG[0xd0],>__r0
 02C0 20                pop X
 02C1 5400              mov [X+0],A
 02C3 3900              cmp A,0
 02C5 A02C              jz L70
 02C7                   .dbline 279
 02C7           ;                                                                                       {
 02C7                   .dbline 280
 02C7           ;                                                                                               if(tempByte != END_TRANSMIT)
 02C7 3D00FD            cmp [X+0],-3
 02CA A018              jz L72
 02CC                   .dbline 281
 02CC           ;                                                                                               {
 02CC                   .dbline 282
 02CC           ;                                                                                                       PARAM[i] = tempByte;
 02CC 5202              mov A,[X+2]
 02CE 0100              add A,<_PARAM
 02D0 5300              mov [__r1],A
 02D2 5201              mov A,[X+1]
 02D4 0900              adc A,>_PARAM
 02D6 60D5              mov REG[0xd5],A
 02D8 5200              mov A,[X+0]
 02DA 3F00              mvi [__r1],A
 02DC                   .dbline 283
 02DC           ;                                                                                                       i++;
 02DC 7702              inc [X+2]
 02DE 0F0100            adc [X+1],0
 02E1                   .dbline 284
 02E1           ;                                                                                               }
 02E1 8010              xjmp L73
 02E3           L72:
 02E3                   .dbline 286
 02E3           ;                                                                                               else
 02E3           ;                                                                                               {
 02E3                   .dbline 287
 02E3           ;                                                                                                       valid_transmit = 1;
 02E3 560401            mov [X+4],1
 02E6 560300            mov [X+3],0
 02E9                   .dbline 288
 02E9           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 02E9 62D000            mov REG[0xd0],>_TIMEOUT
 02EC 550103            mov [_TIMEOUT+1],3
 02EF 550000            mov [_TIMEOUT],0
 02F2                   .dbline 289
 02F2           ;                                                                                               }
 02F2           L73:
 02F2                   .dbline 290
 02F2           ;                                                                                       }
 02F2           L70:
 02F2                   .dbline 291
 02F2           ;                                                                               }
 02F2           L68:
 02F2                   .dbline 276
 02F2 62D000            mov REG[0xd0],>_TIMEOUT
 02F5 5101              mov A,[_TIMEOUT+1]
 02F7 1103              sub A,3
 02F9 5100              mov A,[_TIMEOUT]
 02FB 3180              xor A,-128
 02FD 1980              sbb A,(0 ^ 0x80)
 02FF CFB9              jc L67
 0301           X8:
 0301                   .dbline 292
 0301           ;                                                                       }
 0301           L65:
 0301                   .dbline 293
 0301           ;                                                               }
 0301           L63:
 0301                   .dbline 294
 0301           ;                                                       }
 0301           L61:
 0301                   .dbline 268
 0301 62D000            mov REG[0xd0],>_TIMEOUT
 0304 5101              mov A,[_TIMEOUT+1]
 0306 1103              sub A,3
 0308 5100              mov A,[_TIMEOUT]
 030A 3180              xor A,-128
 030C 1980              sbb A,(0 ^ 0x80)
 030E CF8E              jc L60
 0310           X9:
 0310                   .dbline 295
 0310           ;                                               }
 0310           L58:
 0310                   .dbline 296
 0310           ;                                       }
 0310           L56:
 0310                   .dbline 262
 0310 62D000            mov REG[0xd0],>_TIMEOUT
 0313 5101              mov A,[_TIMEOUT+1]
 0315 1103              sub A,3
 0317 5100              mov A,[_TIMEOUT]
 0319 3180              xor A,-128
 031B 1980              sbb A,(0 ^ 0x80)
 031D CF6B              jc L55
 031F           X10:
 031F                   .dbline 297
 031F           ;                               }
 031F           L53:
 031F                   .dbline 298
 031F           ;                       }
 031F           L51:
 031F                   .dbline 258
 031F 62D000            mov REG[0xd0],>_TIMEOUT
 0322 5101              mov A,[_TIMEOUT+1]
 0324 1103              sub A,3
 0326 5100              mov A,[_TIMEOUT]
 0328 3180              xor A,-128
 032A 1980              sbb A,(0 ^ 0x80)
 032C CF4E              jc L50
 032E           X11:
 032E                   .dbline 299
 032E           ;               }
 032E           L48:
 032E                   .dbline 300
 032E           ;       }
 032E           L46:
 032E                   .dbline 254
 032E 62D000            mov REG[0xd0],>_TIMEOUT
 0331 5101              mov A,[_TIMEOUT+1]
 0333 1103              sub A,3
 0335 5100              mov A,[_TIMEOUT]
 0337 3180              xor A,-128
 0339 1980              sbb A,(0 ^ 0x80)
 033B CF31              jc L45
 033D           X12:
 033D                   .dbline 302
 033D           ;       
 033D           ;       RX_TIMEOUT_Stop();
 033D 10                push X
 033E 7C0000            xcall _RX_TIMEOUT_Stop
 0341 20                pop X
 0342                   .dbline 303
 0342           ;       TIMEOUT = 0;
 0342 62D000            mov REG[0xd0],>_TIMEOUT
 0345 550100            mov [_TIMEOUT+1],0
 0348 550000            mov [_TIMEOUT],0
 034B                   .dbline 305
 034B           ;       
 034B           ;       return valid_transmit;
 034B 62D000            mov REG[0xd0],>__r0
 034E 5204              mov A,[X+4]
 0350 5300              mov [__r1],A
 0352 5203              mov A,[X+3]
 0354 5300              mov [__r0],A
 0356                   .dbline -2
 0356           L44:
 0356 38FB              add SP,-5
 0358 20                pop X
 0359                   .dbline 0 ; func end
 0359 7F                ret
 035A                   .dbsym l valid_transmit 3 I
 035A                   .dbsym l i 1 I
 035A                   .dbsym l tempByte 0 c
 035A                   .dbend
 035A                   .dbfunc e decodeTransmission _decodeTransmission fV
 035A           ;          speed -> X+10
 035A           ;          angle -> X+8
 035A           ;       tempByte -> X+7
 035A           ;          total -> X+5
 035A           ;             ID -> X+4
 035A           ;   runningTotal -> X+2
 035A           ;          param -> X+0
 035A           _decodeTransmission::
 035A                   .dbline -1
 035A 10                push X
 035B 4F                mov X,SP
 035C 380C              add SP,12
 035E                   .dbline 310
 035E           ; }
 035E           ; 
 035E           ; // This function decodes the transmission and takes the correct action.
 035E           ; void decodeTransmission(void)
 035E           ; {
 035E                   .dbline 312
 035E           ;       char* param;
 035E           ;       char ID = 0;
 035E 560400            mov [X+4],0
 0361                   .dbline 316
 0361           ;       char tempByte;
 0361           ;       char angle[2];
 0361           ;       char speed[2];
 0361           ;       int total = 0;
 0361 560600            mov [X+6],0
 0364 560500            mov [X+5],0
 0367                   .dbline 317
 0367           ;       int runningTotal = 0;
 0367 560300            mov [X+3],0
 036A 560200            mov [X+2],0
 036D                   .dbline 319
 036D           ;       
 036D           ;       if(param = COMP_SERIAL_szGetParam())
 036D 10                push X
 036E 7C0000            xcall _COMP_SERIAL_szGetParam
 0371 62D000            mov REG[0xd0],>__r0
 0374 5300              mov [__r0],A
 0376 5A00              mov [__r1],X
 0378 20                pop X
 0379 5100              mov A,[__r1]
 037B 5401              mov [X+1],A
 037D 5100              mov A,[__r0]
 037F 5400              mov [X+0],A
 0381 3C0000            cmp [__r0],0
 0384 B006              jnz X13
 0386 3C0000            cmp [__r1],0
 0389 A601              jz L75
 038B           X13:
 038B                   .dbline 320
 038B           ;       {
 038B                   .dbline 321
 038B           ;               if((param[0] == 'x') || (param[0] == 'X'))
 038B 62D000            mov REG[0xd0],>__r0
 038E 5201              mov A,[X+1]
 0390 5300              mov [__r1],A
 0392 5200              mov A,[X+0]
 0394 60D4              mov REG[0xd4],A
 0396 3E00              mvi A,[__r1]
 0398 5300              mov [__r1],A
 039A 550000            mov [__r0],0
 039D 3C0000            cmp [__r0],0
 03A0 B005              jnz X14
 03A2 3978              cmp A,120
 03A4 A00E              jz L79
 03A6           X14:
 03A6 62D000            mov REG[0xd0],>__r0
 03A9 3C0000            cmp [__r0],0
 03AC B011              jnz L77
 03AE 3C0058            cmp [__r1],88
 03B1 B00C              jnz L77
 03B3           X15:
 03B3           L79:
 03B3                   .dbline 322
 03B3           ;               {
 03B3                   .dbline 324
 03B3           ;                       // Reset
 03B3           ;                       NUM_MODULES = 0;
 03B3 62D000            mov REG[0xd0],>_NUM_MODULES
 03B6 550100            mov [_NUM_MODULES+1],0
 03B9 550000            mov [_NUM_MODULES],0
 03BC                   .dbline 325
 03BC           ;               }
 03BC 85CE              xjmp L78
 03BE           L77:
 03BE                   .dbline 326
 03BE           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 03BE 62D000            mov REG[0xd0],>__r0
 03C1 5201              mov A,[X+1]
 03C3 5300              mov [__r1],A
 03C5 5200              mov A,[X+0]
 03C7 60D4              mov REG[0xd4],A
 03C9 3E00              mvi A,[__r1]
 03CB 5300              mov [__r1],A
 03CD 550000            mov [__r0],0
 03D0 3C0000            cmp [__r0],0
 03D3 B005              jnz X16
 03D5 396E              cmp A,110
 03D7 A00E              jz L82
 03D9           X16:
 03D9 62D000            mov REG[0xd0],>__r0
 03DC 3C0000            cmp [__r0],0
 03DF B035              jnz L80
 03E1 3C004E            cmp [__r1],78
 03E4 B030              jnz L80
 03E6           X17:
 03E6           L82:
 03E6                   .dbline 327
 03E6           ;               {
 03E6                   .dbline 328
 03E6           ;                       itoa(param,NUM_MODULES,10);
 03E6 5000              mov A,0
 03E8 08                push A
 03E9 500A              mov A,10
 03EB 08                push A
 03EC 62D000            mov REG[0xd0],>_NUM_MODULES
 03EF 5100              mov A,[_NUM_MODULES]
 03F1 08                push A
 03F2 5101              mov A,[_NUM_MODULES+1]
 03F4 08                push A
 03F5 5200              mov A,[X+0]
 03F7 08                push A
 03F8 5201              mov A,[X+1]
 03FA 08                push A
 03FB 7C0000            xcall _itoa
 03FE 38FA              add SP,-6
 0400                   .dbline 329
 0400           ;                       COMP_SERIAL_PutString(param);
 0400 10                push X
 0401 5200              mov A,[X+0]
 0403 08                push A
 0404 5201              mov A,[X+1]
 0406 5C                mov X,A
 0407 18                pop A
 0408 7C0000            xcall _COMP_SERIAL_PutString
 040B 20                pop X
 040C                   .dbline 330
 040C           ;                       COMP_SERIAL_PutChar('\n');
 040C 10                push X
 040D 500A              mov A,10
 040F 7C0000            xcall _COMP_SERIAL_PutChar
 0412 20                pop X
 0413                   .dbline 331
 0413           ;               }
 0413 8577              xjmp L81
 0415           L80:
 0415                   .dbline 332
 0415           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 0415 62D000            mov REG[0xd0],>__r0
 0418 5201              mov A,[X+1]
 041A 5300              mov [__r1],A
 041C 5200              mov A,[X+0]
 041E 60D4              mov REG[0xd4],A
 0420 3E00              mvi A,[__r1]
 0422 5300              mov [__r1],A
 0424 550000            mov [__r0],0
 0427 3C0000            cmp [__r0],0
 042A B005              jnz X18
 042C 3977              cmp A,119
 042E A00E              jz L85
 0430           X18:
 0430 62D000            mov REG[0xd0],>__r0
 0433 3C0000            cmp [__r0],0
 0436 B214              jnz L83
 0438 3C0057            cmp [__r1],87
 043B B20F              jnz L83
 043D           X19:
 043D           L85:
 043D                   .dbline 333
 043D           ;               {
 043D                   .dbline 334
 043D           ;                       if(param = COMP_SERIAL_szGetParam())
 043D 10                push X
 043E 7C0000            xcall _COMP_SERIAL_szGetParam
 0441 62D000            mov REG[0xd0],>__r0
 0444 5300              mov [__r0],A
 0446 5A00              mov [__r1],X
 0448 20                pop X
 0449 5100              mov A,[__r1]
 044B 5401              mov [X+1],A
 044D 5100              mov A,[__r0]
 044F 5400              mov [X+0],A
 0451 3C0000            cmp [__r0],0
 0454 B006              jnz X20
 0456 3C0000            cmp [__r1],0
 0459 A531              jz L84
 045B           X20:
 045B                   .dbline 335
 045B           ;                       {
 045B                   .dbline 336
 045B           ;                               ID = atoi(param);
 045B 5200              mov A,[X+0]
 045D 08                push A
 045E 5201              mov A,[X+1]
 0460 08                push A
 0461 7C0000            xcall _atoi
 0464 38FE              add SP,-2
 0466 62D000            mov REG[0xd0],>__r0
 0469 5100              mov A,[__r1]
 046B 5404              mov [X+4],A
 046D                   .dbline 338
 046D           ;                               
 046D           ;                               if(param = COMP_SERIAL_szGetParam())
 046D 10                push X
 046E 7C0000            xcall _COMP_SERIAL_szGetParam
 0471 62D000            mov REG[0xd0],>__r0
 0474 5300              mov [__r0],A
 0476 5A00              mov [__r1],X
 0478 20                pop X
 0479 5100              mov A,[__r1]
 047B 5401              mov [X+1],A
 047D 5100              mov A,[__r0]
 047F 5400              mov [X+0],A
 0481 3C0000            cmp [__r0],0
 0484 B006              jnz X21
 0486 3C0000            cmp [__r1],0
 0489 A501              jz L84
 048B           X21:
 048B                   .dbline 339
 048B           ;                               {
 048B                   .dbline 340
 048B           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 048B 62D000            mov REG[0xd0],>__r0
 048E 5201              mov A,[X+1]
 0490 5300              mov [__r1],A
 0492 5200              mov A,[X+0]
 0494 60D4              mov REG[0xd4],A
 0496 3E00              mvi A,[__r1]
 0498 5300              mov [__r1],A
 049A 550000            mov [__r0],0
 049D 3C0000            cmp [__r0],0
 04A0 B005              jnz X22
 04A2 3961              cmp A,97
 04A4 A00E              jz L92
 04A6           X22:
 04A6 62D000            mov REG[0xd0],>__r0
 04A9 3C0000            cmp [__r0],0
 04AC B084              jnz L90
 04AE 3C0041            cmp [__r1],65
 04B1 B07F              jnz L90
 04B3           X23:
 04B3           L92:
 04B3                   .dbline 341
 04B3           ;                                       {
 04B3                   .dbline 342
 04B3           ;                                               if(param = COMP_SERIAL_szGetParam())
 04B3 10                push X
 04B4 7C0000            xcall _COMP_SERIAL_szGetParam
 04B7 62D000            mov REG[0xd0],>__r0
 04BA 5300              mov [__r0],A
 04BC 5A00              mov [__r1],X
 04BE 20                pop X
 04BF 5100              mov A,[__r1]
 04C1 5401              mov [X+1],A
 04C3 5100              mov A,[__r0]
 04C5 5400              mov [X+0],A
 04C7 3C0000            cmp [__r0],0
 04CA B006              jnz X24
 04CC 3C0000            cmp [__r1],0
 04CF A4BB              jz L84
 04D1           X24:
 04D1                   .dbline 343
 04D1           ;                                               {
 04D1                   .dbline 344
 04D1           ;                                                       total = atoi(param);
 04D1 5200              mov A,[X+0]
 04D3 08                push A
 04D4 5201              mov A,[X+1]
 04D6 08                push A
 04D7 7C0000            xcall _atoi
 04DA 38FE              add SP,-2
 04DC 62D000            mov REG[0xd0],>__r0
 04DF 5100              mov A,[__r1]
 04E1 5406              mov [X+6],A
 04E3 5100              mov A,[__r0]
 04E5 5405              mov [X+5],A
 04E7                   .dbline 345
 04E7           ;                                                       angle[0] = total%256;
 04E7 5001              mov A,1
 04E9 08                push A
 04EA 5000              mov A,0
 04EC 08                push A
 04ED 5205              mov A,[X+5]
 04EF 08                push A
 04F0 5206              mov A,[X+6]
 04F2 08                push A
 04F3 7C0000            xcall __divmod_16X16_16
 04F6 38FE              add SP,-2
 04F8 18                pop A
 04F9 5300              mov [__r1],A
 04FB 18                pop A
 04FC 5100              mov A,[__r1]
 04FE 5408              mov [X+8],A
 0500                   .dbline 346
 0500           ;                                                       angle[1] = total/256;
 0500 5001              mov A,1
 0502 08                push A
 0503 5000              mov A,0
 0505 08                push A
 0506 5205              mov A,[X+5]
 0508 08                push A
 0509 5206              mov A,[X+6]
 050B 08                push A
 050C 7C0000            xcall __divmod_16X16_16
 050F 18                pop A
 0510 5300              mov [__r1],A
 0512 18                pop A
 0513 38FE              add SP,-2
 0515 5100              mov A,[__r1]
 0517 5409              mov [X+9],A
 0519                   .dbline 347
 0519           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 0519 5209              mov A,[X+9]
 051B 08                push A
 051C 5208              mov A,[X+8]
 051E 08                push A
 051F 501E              mov A,30
 0521 08                push A
 0522 5003              mov A,3
 0524 08                push A
 0525 5005              mov A,5
 0527 08                push A
 0528 5204              mov A,[X+4]
 052A 08                push A
 052B 952C              xcall _longServoInstruction
 052D 38FA              add SP,-6
 052F                   .dbline 348
 052F           ;                                               }
 052F                   .dbline 349
 052F           ;                                       }
 052F 845B              xjmp L84
 0531           L90:
 0531                   .dbline 350
 0531           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 0531 62D000            mov REG[0xd0],>__r0
 0534 5201              mov A,[X+1]
 0536 5300              mov [__r1],A
 0538 5200              mov A,[X+0]
 053A 60D4              mov REG[0xd4],A
 053C 3E00              mvi A,[__r1]
 053E 5300              mov [__r1],A
 0540 550000            mov [__r0],0
 0543 3C0000            cmp [__r0],0
 0546 B005              jnz X25
 0548 3970              cmp A,112
 054A A00E              jz L99
 054C           X25:
 054C 62D000            mov REG[0xd0],>__r0
 054F 3C0000            cmp [__r0],0
 0552 B045              jnz L97
 0554 3C0050            cmp [__r1],80
 0557 B040              jnz L97
 0559           X26:
 0559           L99:
 0559                   .dbline 351
 0559           ;                                       {
 0559                   .dbline 352
 0559           ;                                               if(param = COMP_SERIAL_szGetParam())
 0559 10                push X
 055A 7C0000            xcall _COMP_SERIAL_szGetParam
 055D 62D000            mov REG[0xd0],>__r0
 0560 5300              mov [__r0],A
 0562 5A00              mov [__r1],X
 0564 20                pop X
 0565 5100              mov A,[__r1]
 0567 5401              mov [X+1],A
 0569 5100              mov A,[__r0]
 056B 5400              mov [X+0],A
 056D 3C0000            cmp [__r0],0
 0570 B006              jnz X27
 0572 3C0000            cmp [__r1],0
 0575 A415              jz L84
 0577           X27:
 0577                   .dbline 353
 0577           ;                                               {
 0577                   .dbline 354
 0577           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0577 5200              mov A,[X+0]
 0579 08                push A
 057A 5201              mov A,[X+1]
 057C 08                push A
 057D 7C0000            xcall _atoi
 0580 62D000            mov REG[0xd0],>__r0
 0583 5100              mov A,[__r1]
 0585 08                push A
 0586 5018              mov A,24
 0588 08                push A
 0589 5003              mov A,3
 058B 08                push A
 058C 5004              mov A,4
 058E 08                push A
 058F 5204              mov A,[X+4]
 0591 08                push A
 0592 9422              xcall _servoInstruction
 0594 38F9              add SP,-7
 0596                   .dbline 355
 0596           ;                                               }
 0596                   .dbline 356
 0596           ;                                       }
 0596 83F4              xjmp L84
 0598           L97:
 0598                   .dbline 357
 0598           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 0598 62D000            mov REG[0xd0],>__r0
 059B 5201              mov A,[X+1]
 059D 5300              mov [__r1],A
 059F 5200              mov A,[X+0]
 05A1 60D4              mov REG[0xd4],A
 05A3 3E00              mvi A,[__r1]
 05A5 5300              mov [__r1],A
 05A7 550000            mov [__r0],0
 05AA 3C0000            cmp [__r0],0
 05AD B005              jnz X28
 05AF 3973              cmp A,115
 05B1 A00E              jz L104
 05B3           X28:
 05B3 62D000            mov REG[0xd0],>__r0
 05B6 3C0000            cmp [__r0],0
 05B9 B3D1              jnz L84
 05BB 3C0053            cmp [__r1],83
 05BE B3CC              jnz L84
 05C0           X29:
 05C0           L104:
 05C0                   .dbline 358
 05C0           ;                                       {
 05C0                   .dbline 359
 05C0           ;                                               if(param = COMP_SERIAL_szGetParam())
 05C0 10                push X
 05C1 7C0000            xcall _COMP_SERIAL_szGetParam
 05C4 62D000            mov REG[0xd0],>__r0
 05C7 5300              mov [__r0],A
 05C9 5A00              mov [__r1],X
 05CB 20                pop X
 05CC 5100              mov A,[__r1]
 05CE 5401              mov [X+1],A
 05D0 5100              mov A,[__r0]
 05D2 5400              mov [X+0],A
 05D4 3C0000            cmp [__r0],0
 05D7 B006              jnz X30
 05D9 3C0000            cmp [__r1],0
 05DC A3AE              jz L84
 05DE           X30:
 05DE                   .dbline 360
 05DE           ;                                               {
 05DE                   .dbline 361
 05DE           ;                                                       total = atoi(param);
 05DE 5200              mov A,[X+0]
 05E0 08                push A
 05E1 5201              mov A,[X+1]
 05E3 08                push A
 05E4 7C0000            xcall _atoi
 05E7 38FE              add SP,-2
 05E9 62D000            mov REG[0xd0],>__r0
 05EC 5100              mov A,[__r1]
 05EE 5406              mov [X+6],A
 05F0 5100              mov A,[__r0]
 05F2 5405              mov [X+5],A
 05F4                   .dbline 364
 05F4           ;                                                       
 05F4           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 05F4           ;                                                       if(total)
 05F4 3D0500            cmp [X+5],0
 05F7 B006              jnz X31
 05F9 3D0600            cmp [X+6],0
 05FC A38E              jz L84
 05FE           X31:
 05FE                   .dbline 365
 05FE           ;                                                       {
 05FE                   .dbline 366
 05FE           ;                                                               speed[0] = total%256;
 05FE 62D000            mov REG[0xd0],>__r0
 0601 5001              mov A,1
 0603 08                push A
 0604 5000              mov A,0
 0606 08                push A
 0607 5205              mov A,[X+5]
 0609 08                push A
 060A 5206              mov A,[X+6]
 060C 08                push A
 060D 7C0000            xcall __divmod_16X16_16
 0610 38FE              add SP,-2
 0612 18                pop A
 0613 5300              mov [__r1],A
 0615 18                pop A
 0616 5100              mov A,[__r1]
 0618 540A              mov [X+10],A
 061A                   .dbline 367
 061A           ;                                                               speed[1] = total/256;
 061A 5001              mov A,1
 061C 08                push A
 061D 5000              mov A,0
 061F 08                push A
 0620 5205              mov A,[X+5]
 0622 08                push A
 0623 5206              mov A,[X+6]
 0625 08                push A
 0626 7C0000            xcall __divmod_16X16_16
 0629 18                pop A
 062A 5300              mov [__r1],A
 062C 18                pop A
 062D 38FE              add SP,-2
 062F 5100              mov A,[__r1]
 0631 540B              mov [X+11],A
 0633                   .dbline 368
 0633           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 0633 520B              mov A,[X+11]
 0635 08                push A
 0636 520A              mov A,[X+10]
 0638 08                push A
 0639 5020              mov A,32
 063B 08                push A
 063C 5003              mov A,3
 063E 08                push A
 063F 5005              mov A,5
 0641 08                push A
 0642 5204              mov A,[X+4]
 0644 08                push A
 0645 9412              xcall _longServoInstruction
 0647 38FA              add SP,-6
 0649                   .dbline 369
 0649           ;                                                       }
 0649                   .dbline 370
 0649           ;                                               }
 0649                   .dbline 371
 0649           ;                                       }
 0649                   .dbline 372
 0649           ;                               }
 0649                   .dbline 373
 0649           ;                       }
 0649                   .dbline 374
 0649           ;               }
 0649 8341              xjmp L84
 064B           L83:
 064B                   .dbline 375
 064B           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 064B 62D000            mov REG[0xd0],>__r0
 064E 5201              mov A,[X+1]
 0650 5300              mov [__r1],A
 0652 5200              mov A,[X+0]
 0654 60D4              mov REG[0xd4],A
 0656 3E00              mvi A,[__r1]
 0658 5300              mov [__r1],A
 065A 550000            mov [__r0],0
 065D 3C0000            cmp [__r0],0
 0660 B005              jnz X32
 0662 3972              cmp A,114
 0664 A00E              jz L113
 0666           X32:
 0666 62D000            mov REG[0xd0],>__r0
 0669 3C0000            cmp [__r0],0
 066C B31E              jnz L111
 066E 3C0052            cmp [__r1],82
 0671 B319              jnz L111
 0673           X33:
 0673           L113:
 0673                   .dbline 376
 0673           ;               {                       
 0673                   .dbline 377
 0673           ;                       if(param = COMP_SERIAL_szGetParam())
 0673 10                push X
 0674 7C0000            xcall _COMP_SERIAL_szGetParam
 0677 62D000            mov REG[0xd0],>__r0
 067A 5300              mov [__r0],A
 067C 5A00              mov [__r1],X
 067E 20                pop X
 067F 5100              mov A,[__r1]
 0681 5401              mov [X+1],A
 0683 5100              mov A,[__r0]
 0685 5400              mov [X+0],A
 0687 3C0000            cmp [__r0],0
 068A B006              jnz X34
 068C 3C0000            cmp [__r1],0
 068F A2FB              jz L114
 0691           X34:
 0691                   .dbline 378
 0691           ;                       {
 0691                   .dbline 379
 0691           ;                               ID = atoi(param);
 0691 5200              mov A,[X+0]
 0693 08                push A
 0694 5201              mov A,[X+1]
 0696 08                push A
 0697 7C0000            xcall _atoi
 069A 38FE              add SP,-2
 069C 62D000            mov REG[0xd0],>__r0
 069F 5100              mov A,[__r1]
 06A1 5404              mov [X+4],A
 06A3                   .dbline 380
 06A3           ;                               if(param = COMP_SERIAL_szGetParam())
 06A3 10                push X
 06A4 7C0000            xcall _COMP_SERIAL_szGetParam
 06A7 62D000            mov REG[0xd0],>__r0
 06AA 5300              mov [__r0],A
 06AC 5A00              mov [__r1],X
 06AE 20                pop X
 06AF 5100              mov A,[__r1]
 06B1 5401              mov [X+1],A
 06B3 5100              mov A,[__r0]
 06B5 5400              mov [X+0],A
 06B7 3C0000            cmp [__r0],0
 06BA B006              jnz X35
 06BC 3C0000            cmp [__r1],0
 06BF A2CB              jz L116
 06C1           X35:
 06C1                   .dbline 381
 06C1           ;                               {
 06C1                   .dbline 382
 06C1           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06C1 62D000            mov REG[0xd0],>__r0
 06C4 5201              mov A,[X+1]
 06C6 5300              mov [__r1],A
 06C8 5200              mov A,[X+0]
 06CA 60D4              mov REG[0xd4],A
 06CC 3E00              mvi A,[__r1]
 06CE 5300              mov [__r1],A
 06D0 550000            mov [__r0],0
 06D3 3C0000            cmp [__r0],0
 06D6 B005              jnz X36
 06D8 3961              cmp A,97
 06DA A00E              jz L120
 06DC           X36:
 06DC 62D000            mov REG[0xd0],>__r0
 06DF 3C0000            cmp [__r0],0
 06E2 B0D1              jnz L118
 06E4 3C0041            cmp [__r1],65
 06E7 B0CC              jnz L118
 06E9           X37:
 06E9           L120:
 06E9                   .dbline 383
 06E9           ;                                       {
 06E9                   .dbline 384
 06E9           ;                                               angle[0] = 0;
 06E9 560800            mov [X+8],0
 06EC                   .dbline 385
 06EC           ;                                               angle[1] = 0;
 06EC 560900            mov [X+9],0
 06EF                   .dbline 387
 06EF           ;                                               
 06EF           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 06EF 5002              mov A,2
 06F1 08                push A
 06F2 5024              mov A,36
 06F4 08                push A
 06F5 5002              mov A,2
 06F7 08                push A
 06F8 5004              mov A,4
 06FA 08                push A
 06FB 5204              mov A,[X+4]
 06FD 08                push A
 06FE 92B6              xcall _servoInstruction
 0700                   .dbline 388
 0700           ;                                               configToggle(RX_MODE);
 0700 5000              mov A,0
 0702 08                push A
 0703 5001              mov A,1
 0705 08                push A
 0706 9402              xcall _configToggle
 0708 38F9              add SP,-7
 070A 8098              xjmp L123
 070C           L122:
 070C                   .dbline 392
 070C           ;                                                       
 070C           ;                                               // Loop until we read a response or time out.
 070C           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 070C           ;                                               {
 070C                   .dbline 393
 070C           ;                                                       if(RECEIVE_cReadChar() == ID)
 070C 10                push X
 070D 7C0000            xcall _RECEIVE_cReadChar
 0710 62D000            mov REG[0xd0],>__r0
 0713 20                pop X
 0714 3B04              cmp A,[X+4]
 0716 B08C              jnz L125
 0718                   .dbline 394
 0718           ;                                                       {
 0718 807B              xjmp L128
 071A           L127:
 071A                   .dbline 396
 071A           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 071A           ;                                                               {
 071A                   .dbline 397
 071A           ;                                                                       if(RECEIVE_cReadChar() == 4)
 071A 10                push X
 071B 7C0000            xcall _RECEIVE_cReadChar
 071E 62D000            mov REG[0xd0],>__r0
 0721 20                pop X
 0722 3904              cmp A,4
 0724 B06F              jnz L130
 0726                   .dbline 398
 0726           ;                                                                       {
 0726                   .dbline 399
 0726           ;                                                                               if(RECEIVE_cGetChar() == 0)
 0726 10                push X
 0727 7C0000            xcall _RECEIVE_cGetChar
 072A 62D000            mov REG[0xd0],>__r0
 072D 20                pop X
 072E 3900              cmp A,0
 0730 B05A              jnz L132
 0732                   .dbline 400
 0732           ;                                                                               {
 0732                   .dbline 401
 0732           ;                                                                                       angle[0] = RECEIVE_cGetChar();
 0732 10                push X
 0733 7C0000            xcall _RECEIVE_cGetChar
 0736 62D000            mov REG[0xd0],>__r0
 0739 20                pop X
 073A 5408              mov [X+8],A
 073C                   .dbline 402
 073C           ;                                                                                       angle[1] = RECEIVE_cGetChar();
 073C 10                push X
 073D 7C0000            xcall _RECEIVE_cGetChar
 0740 62D000            mov REG[0xd0],>__r0
 0743 20                pop X
 0744 5409              mov [X+9],A
 0746                   .dbline 404
 0746           ;                                                                                       
 0746           ;                                                                                       configToggle(PC_MODE);
 0746 5000              mov A,0
 0748 08                push A
 0749 5002              mov A,2
 074B 08                push A
 074C 93BC              xcall _configToggle
 074E                   .dbline 406
 074E           ;                                                                                       
 074E           ;                                                                                       total = ((angle[1])*256) + angle[0];
 074E 5208              mov A,[X+8]
 0750 5406              mov [X+6],A
 0752 5209              mov A,[X+9]
 0754 5405              mov [X+5],A
 0756                   .dbline 407
 0756           ;                                                                                       itoa(param,total,10);
 0756 5000              mov A,0
 0758 08                push A
 0759 500A              mov A,10
 075B 08                push A
 075C 5205              mov A,[X+5]
 075E 08                push A
 075F 5206              mov A,[X+6]
 0761 08                push A
 0762 5200              mov A,[X+0]
 0764 08                push A
 0765 5201              mov A,[X+1]
 0767 08                push A
 0768 7C0000            xcall _itoa
 076B 38F8              add SP,-8
 076D                   .dbline 408
 076D           ;                                                                                       COMP_SERIAL_PutString(param);
 076D 10                push X
 076E 5200              mov A,[X+0]
 0770 08                push A
 0771 5201              mov A,[X+1]
 0773 5C                mov X,A
 0774 18                pop A
 0775 7C0000            xcall _COMP_SERIAL_PutString
 0778 20                pop X
 0779                   .dbline 409
 0779           ;                                                                                       COMP_SERIAL_PutChar('\n');
 0779 10                push X
 077A 500A              mov A,10
 077C 7C0000            xcall _COMP_SERIAL_PutChar
 077F 20                pop X
 0780                   .dbline 411
 0780           ; 
 0780           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0780 62D000            mov REG[0xd0],>_TIMEOUT
 0783 550103            mov [_TIMEOUT+1],3
 0786 550000            mov [_TIMEOUT],0
 0789                   .dbline 412
 0789           ;                                                                               }
 0789 800A              xjmp L133
 078B           L132:
 078B                   .dbline 414
 078B           ;                                                                               else
 078B           ;                                                                               {
 078B                   .dbline 415
 078B           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 078B 62D000            mov REG[0xd0],>_TIMEOUT
 078E 550103            mov [_TIMEOUT+1],3
 0791 550000            mov [_TIMEOUT],0
 0794                   .dbline 416
 0794           ;                                                                               }
 0794           L133:
 0794                   .dbline 417
 0794           ;                                                                       }
 0794           L130:
 0794                   .dbline 418
 0794           ;                                                               }
 0794           L128:
 0794                   .dbline 395
 0794 62D000            mov REG[0xd0],>_TIMEOUT
 0797 5101              mov A,[_TIMEOUT+1]
 0799 1103              sub A,3
 079B 5100              mov A,[_TIMEOUT]
 079D 3180              xor A,-128
 079F 1980              sbb A,(0 ^ 0x80)
 07A1 CF78              jc L127
 07A3           X38:
 07A3                   .dbline 419
 07A3           ;                                                       }
 07A3           L125:
 07A3                   .dbline 420
 07A3           ;                                               }
 07A3           L123:
 07A3                   .dbline 391
 07A3 62D000            mov REG[0xd0],>_TIMEOUT
 07A6 5101              mov A,[_TIMEOUT+1]
 07A8 1103              sub A,3
 07AA 5100              mov A,[_TIMEOUT]
 07AC 3180              xor A,-128
 07AE 1980              sbb A,(0 ^ 0x80)
 07B0 CF5B              jc L122
 07B2           X39:
 07B2                   .dbline 421
 07B2           ;                                       }
 07B2 81D8              xjmp L119
 07B4           L118:
 07B4                   .dbline 422
 07B4           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07B4 62D000            mov REG[0xd0],>__r0
 07B7 5201              mov A,[X+1]
 07B9 5300              mov [__r1],A
 07BB 5200              mov A,[X+0]
 07BD 60D4              mov REG[0xd4],A
 07BF 3E00              mvi A,[__r1]
 07C1 5300              mov [__r1],A
 07C3 550000            mov [__r0],0
 07C6 3C0000            cmp [__r0],0
 07C9 B005              jnz X40
 07CB 3970              cmp A,112
 07CD A00E              jz L138
 07CF           X40:
 07CF 62D000            mov REG[0xd0],>__r0
 07D2 3C0000            cmp [__r0],0
 07D5 B0EF              jnz L136
 07D7 3C0050            cmp [__r1],80
 07DA B0EA              jnz L136
 07DC           X41:
 07DC           L138:
 07DC                   .dbline 423
 07DC           ;                                       {
 07DC                   .dbline 424
 07DC           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 07DC 5001              mov A,1
 07DE 08                push A
 07DF 5018              mov A,24
 07E1 08                push A
 07E2 5002              mov A,2
 07E4 08                push A
 07E5 5004              mov A,4
 07E7 08                push A
 07E8 5204              mov A,[X+4]
 07EA 08                push A
 07EB 91C9              xcall _servoInstruction
 07ED                   .dbline 425
 07ED           ;                                               configToggle(RX_MODE);
 07ED 5000              mov A,0
 07EF 08                push A
 07F0 5001              mov A,1
 07F2 08                push A
 07F3 9315              xcall _configToggle
 07F5 38F9              add SP,-7
 07F7 80BC              xjmp L140
 07F9           L139:
 07F9                   .dbline 429
 07F9           ;                                               
 07F9           ;                                               // Loop until we read a response or time out.
 07F9           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07F9           ;                                               {
 07F9                   .dbline 430
 07F9           ;                                                       if(RECEIVE_cReadChar() == ID)
 07F9 10                push X
 07FA 7C0000            xcall _RECEIVE_cReadChar
 07FD 62D000            mov REG[0xd0],>__r0
 0800 20                pop X
 0801 3B04              cmp A,[X+4]
 0803 B0B0              jnz L142
 0805                   .dbline 431
 0805           ;                                                       {
 0805                   .dbline 432
 0805           ;                                                               runningTotal = ID;
 0805 5204              mov A,[X+4]
 0807 5403              mov [X+3],A
 0809 560200            mov [X+2],0
 080C 8098              xjmp L145
 080E           L144:
 080E                   .dbline 435
 080E           ;                                                               // Loop until we read a response or time out.
 080E           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 080E           ;                                                               {
 080E                   .dbline 437
 080E           ;                                                                       // Check the length of the packet.
 080E           ;                                                                       if(RECEIVE_cReadChar() == 3)
 080E 10                push X
 080F 7C0000            xcall _RECEIVE_cReadChar
 0812 62D000            mov REG[0xd0],>__r0
 0815 20                pop X
 0816 3903              cmp A,3
 0818 B08C              jnz L147
 081A                   .dbline 438
 081A           ;                                                                       {
 081A                   .dbline 439
 081A           ;                                                                               runningTotal += 3;
 081A 070303            add [X+3],3
 081D 0F0200            adc [X+2],0
 0820 8075              xjmp L150
 0822           L149:
 0822                   .dbline 442
 0822           ;                                                                               // Loop until we read a response or time out.
 0822           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0822           ;                                                                               {
 0822                   .dbline 444
 0822           ;                                                                                       // Check for the checksum or 1.
 0822           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 0822 10                push X
 0823 7C0000            xcall _RECEIVE_cReadChar
 0826 62D000            mov REG[0xd0],>__r0
 0829 20                pop X
 082A 5407              mov [X+7],A
 082C 3900              cmp A,0
 082E A067              jz L152
 0830                   .dbline 445
 0830           ;                                                                                       {
 0830                   .dbline 446
 0830           ;                                                                                               configToggle(PC_MODE);
 0830 5000              mov A,0
 0832 08                push A
 0833 5002              mov A,2
 0835 08                push A
 0836 92D2              xcall _configToggle
 0838 38FE              add SP,-2
 083A                   .dbline 448
 083A           ;                                                                                               
 083A           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 083A 62D000            mov REG[0xd0],>__r0
 083D 5207              mov A,[X+7]
 083F 5300              mov [__r1],A
 0841 550000            mov [__r0],0
 0844 50FF              mov A,-1
 0846 1200              sub A,[__r1]
 0848 5300              mov [__r1],A
 084A 5000              mov A,0
 084C 1A00              sbb A,[__r0]
 084E 5300              mov [__r0],A
 0850 5001              mov A,1
 0852 08                push A
 0853 5000              mov A,0
 0855 08                push A
 0856 5202              mov A,[X+2]
 0858 08                push A
 0859 5203              mov A,[X+3]
 085B 08                push A
 085C 7C0000            xcall __divmod_16X16_16
 085F 38FE              add SP,-2
 0861 18                pop A
 0862 5300              mov [__r3],A
 0864 18                pop A
 0865 3A00              cmp A,[__r0]
 0867 B017              jnz L154
 0869 5100              mov A,[__r3]
 086B 3A00              cmp A,[__r1]
 086D B011              jnz L154
 086F           X42:
 086F                   .dbline 449
 086F           ;                                                                                               {
 086F                   .dbline 451
 086F           ;                                                                                                       // Send a 0 if we hit the checksum.
 086F           ;                                                                                                       COMP_SERIAL_PutChar('0');
 086F 10                push X
 0870 5030              mov A,48
 0872 7C0000            xcall _COMP_SERIAL_PutChar
 0875 20                pop X
 0876                   .dbline 452
 0876           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0876 10                push X
 0877 500A              mov A,10
 0879 7C0000            xcall _COMP_SERIAL_PutChar
 087C 20                pop X
 087D                   .dbline 453
 087D           ;                                                                                               }
 087D 800F              xjmp L155
 087F           L154:
 087F                   .dbline 455
 087F           ;                                                                                               else
 087F           ;                                                                                               {
 087F                   .dbline 457
 087F           ;                                                                                                       // Send a 1.
 087F           ;                                                                                                       COMP_SERIAL_PutChar('1');
 087F 10                push X
 0880 5031              mov A,49
 0882 7C0000            xcall _COMP_SERIAL_PutChar
 0885 20                pop X
 0886                   .dbline 458
 0886           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0886 10                push X
 0887 500A              mov A,10
 0889 7C0000            xcall _COMP_SERIAL_PutChar
 088C 20                pop X
 088D                   .dbline 459
 088D           ;                                                                                               }
 088D           L155:
 088D                   .dbline 461
 088D           ;               
 088D           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 088D 62D000            mov REG[0xd0],>_TIMEOUT
 0890 550103            mov [_TIMEOUT+1],3
 0893 550000            mov [_TIMEOUT],0
 0896                   .dbline 462
 0896           ;                                                                                       }
 0896           L152:
 0896                   .dbline 463
 0896           ;                                                                               }
 0896           L150:
 0896                   .dbline 441
 0896 62D000            mov REG[0xd0],>_TIMEOUT
 0899 5101              mov A,[_TIMEOUT+1]
 089B 1103              sub A,3
 089D 5100              mov A,[_TIMEOUT]
 089F 3180              xor A,-128
 08A1 1980              sbb A,(0 ^ 0x80)
 08A3 CF7E              jc L149
 08A5           X43:
 08A5                   .dbline 464
 08A5           ;                                                                       }
 08A5           L147:
 08A5                   .dbline 465
 08A5           ;                                                               }
 08A5           L145:
 08A5                   .dbline 434
 08A5 62D000            mov REG[0xd0],>_TIMEOUT
 08A8 5101              mov A,[_TIMEOUT+1]
 08AA 1103              sub A,3
 08AC 5100              mov A,[_TIMEOUT]
 08AE 3180              xor A,-128
 08B0 1980              sbb A,(0 ^ 0x80)
 08B2 CF5B              jc L144
 08B4           X44:
 08B4                   .dbline 466
 08B4           ;                                                       }
 08B4           L142:
 08B4                   .dbline 467
 08B4           ;                                               }
 08B4           L140:
 08B4                   .dbline 428
 08B4 62D000            mov REG[0xd0],>_TIMEOUT
 08B7 5101              mov A,[_TIMEOUT+1]
 08B9 1103              sub A,3
 08BB 5100              mov A,[_TIMEOUT]
 08BD 3180              xor A,-128
 08BF 1980              sbb A,(0 ^ 0x80)
 08C1 CF37              jc L139
 08C3           X45:
 08C3                   .dbline 468
 08C3           ;                                       }
 08C3 80C7              xjmp L137
 08C5           L136:
 08C5                   .dbline 469
 08C5           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 08C5 62D000            mov REG[0xd0],>__r0
 08C8 5201              mov A,[X+1]
 08CA 5300              mov [__r1],A
 08CC 5200              mov A,[X+0]
 08CE 60D4              mov REG[0xd4],A
 08D0 3E00              mvi A,[__r1]
 08D2 5300              mov [__r1],A
 08D4 550000            mov [__r0],0
 08D7 3C0000            cmp [__r0],0
 08DA B005              jnz X46
 08DC 3974              cmp A,116
 08DE A00E              jz L158
 08E0           X46:
 08E0 62D000            mov REG[0xd0],>__r0
 08E3 3C0000            cmp [__r0],0
 08E6 B042              jnz L156
 08E8 3C0054            cmp [__r1],84
 08EB B03D              jnz L156
 08ED           X47:
 08ED           L158:
 08ED                   .dbline 470
 08ED           ;                                       {
 08ED                   .dbline 471
 08ED           ;                                               if(pingModule(ID))
 08ED 62D000            mov REG[0xd0],>__r0
 08F0 5204              mov A,[X+4]
 08F2 5300              mov [__r1],A
 08F4 5000              mov A,0
 08F6 08                push A
 08F7 5100              mov A,[__r1]
 08F9 08                push A
 08FA 7C0034            xcall _pingModule
 08FD 38FE              add SP,-2
 08FF 62D000            mov REG[0xd0],>__r0
 0902 3C0000            cmp [__r0],0
 0905 B006              jnz X48
 0907 3C0000            cmp [__r1],0
 090A A080              jz L157
 090C           X48:
 090C                   .dbline 472
 090C           ;                                               {
 090C                   .dbline 473
 090C           ;                                                       configToggle(PC_MODE);
 090C 5000              mov A,0
 090E 08                push A
 090F 5002              mov A,2
 0911 08                push A
 0912 91F6              xcall _configToggle
 0914 38FE              add SP,-2
 0916                   .dbline 475
 0916           ;                                                                                               
 0916           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 0916 10                push X
 0917 62D000            mov REG[0xd0],>_PARAM
 091A 5100              mov A,[_PARAM]
 091C 7C0000            xcall _COMP_SERIAL_PutChar
 091F 20                pop X
 0920                   .dbline 476
 0920           ;                                                       COMP_SERIAL_PutChar('\n');
 0920 10                push X
 0921 500A              mov A,10
 0923 7C0000            xcall _COMP_SERIAL_PutChar
 0926 20                pop X
 0927                   .dbline 477
 0927           ;                                               }
 0927                   .dbline 478
 0927           ;                                       }
 0927 8063              xjmp L157
 0929           L156:
 0929                   .dbline 479
 0929           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0929 62D000            mov REG[0xd0],>__r0
 092C 5201              mov A,[X+1]
 092E 5300              mov [__r1],A
 0930 5200              mov A,[X+0]
 0932 60D4              mov REG[0xd4],A
 0934 3E00              mvi A,[__r1]
 0936 5300              mov [__r1],A
 0938 550000            mov [__r0],0
 093B 3C0000            cmp [__r0],0
 093E B005              jnz X49
 0940 3963              cmp A,99
 0942 A00E              jz L163
 0944           X49:
 0944 62D000            mov REG[0xd0],>__r0
 0947 3C0000            cmp [__r0],0
 094A B040              jnz L161
 094C 3C0043            cmp [__r1],67
 094F B03B              jnz L161
 0951           X50:
 0951           L163:
 0951                   .dbline 480
 0951           ;                                       {
 0951                   .dbline 481
 0951           ;                                               if(pingModule(ID))
 0951 62D000            mov REG[0xd0],>__r0
 0954 5204              mov A,[X+4]
 0956 5300              mov [__r1],A
 0958 5000              mov A,0
 095A 08                push A
 095B 5100              mov A,[__r1]
 095D 08                push A
 095E 7C0034            xcall _pingModule
 0961 38FE              add SP,-2
 0963 62D000            mov REG[0xd0],>__r0
 0966 3C0000            cmp [__r0],0
 0969 B006              jnz X51
 096B 3C0000            cmp [__r1],0
 096E A01C              jz L164
 0970           X51:
 0970                   .dbline 482
 0970           ;                                               {       
 0970                   .dbline 483
 0970           ;                                                       configToggle(PC_MODE);
 0970 5000              mov A,0
 0972 08                push A
 0973 5002              mov A,2
 0975 08                push A
 0976 9192              xcall _configToggle
 0978 38FE              add SP,-2
 097A                   .dbline 485
 097A           ;                                                       
 097A           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 097A 10                push X
 097B 62D000            mov REG[0xd0],>_PARAM
 097E 5101              mov A,[_PARAM+1]
 0980 7C0000            xcall _COMP_SERIAL_PutChar
 0983 20                pop X
 0984                   .dbline 486
 0984           ;                                                       COMP_SERIAL_PutChar('\n');
 0984 10                push X
 0985 500A              mov A,10
 0987 7C0000            xcall _COMP_SERIAL_PutChar
 098A 20                pop X
 098B                   .dbline 487
 098B           ;                                               }
 098B           L164:
 098B                   .dbline 488
 098B           ;                                       }
 098B           L161:
 098B           L157:
 098B           L137:
 098B           L119:
 098B                   .dbline 489
 098B           ;                               }
 098B           L116:
 098B                   .dbline 490
 098B           ;                       }
 098B           L114:
 098B                   .dbline 491
 098B           ;               }
 098B           L111:
 098B           L84:
 098B           L81:
 098B           L78:
 098B                   .dbline 492
 098B           ;       }
 098B           L75:
 098B                   .dbline 494
 098B           ;       
 098B           ;       if(STATE != PC_MODE)
 098B 62D000            mov REG[0xd0],>_STATE
 098E 3C0000            cmp [_STATE],0
 0991 B006              jnz X52
 0993 3C0102            cmp [_STATE+1],2
 0996 A00D              jz L167
 0998           X52:
 0998                   .dbline 495
 0998           ;       {
 0998                   .dbline 496
 0998           ;               configToggle(PC_MODE);
 0998 5000              mov A,0
 099A 08                push A
 099B 5002              mov A,2
 099D 08                push A
 099E 916A              xcall _configToggle
 09A0 38FE              add SP,-2
 09A2                   .dbline 497
 09A2           ;       }
 09A2 800F              xjmp L168
 09A4           L167:
 09A4                   .dbline 499
 09A4           ;       else
 09A4           ;       {
 09A4                   .dbline 500
 09A4           ;               TIMEOUT = 0;
 09A4 62D000            mov REG[0xd0],>_TIMEOUT
 09A7 550100            mov [_TIMEOUT+1],0
 09AA 550000            mov [_TIMEOUT],0
 09AD                   .dbline 501
 09AD           ;               COMP_SERIAL_CmdReset();
 09AD 10                push X
 09AE 7C0000            xcall _COMP_SERIAL_CmdReset
 09B1 20                pop X
 09B2                   .dbline 502
 09B2           ;       }
 09B2           L168:
 09B2                   .dbline -2
 09B2           L74:
 09B2 38F4              add SP,-12
 09B4 20                pop X
 09B5                   .dbline 0 ; func end
 09B5 7F                ret
 09B6                   .dbsym l speed 10 A[2:2]c
 09B6                   .dbsym l angle 8 A[2:2]c
 09B6                   .dbsym l tempByte 7 c
 09B6                   .dbsym l total 5 I
 09B6                   .dbsym l ID 4 c
 09B6                   .dbsym l runningTotal 2 I
 09B6                   .dbsym l param 0 pc
 09B6                   .dbend
 09B6                   .dbfunc e servoInstruction _servoInstruction fV
 09B6           ;          total -> X+1
 09B6           ;       checksum -> X+0
 09B6           ;          value -> X-8
 09B6           ;        address -> X-7
 09B6           ;    instruction -> X-6
 09B6           ;         length -> X-5
 09B6           ;             id -> X-4
 09B6           _servoInstruction::
 09B6                   .dbline -1
 09B6 10                push X
 09B7 4F                mov X,SP
 09B8 3803              add SP,3
 09BA                   .dbline 508
 09BA           ; }
 09BA           ; 
 09BA           ; // This function receives a destination, command length, instruction type, address, and value.
 09BA           ; // With these parameters, the function sends a packet to the communication bus.
 09BA           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 09BA           ; {
 09BA                   .dbline 512
 09BA           ;       char checksum;
 09BA           ;       int total;
 09BA           ;       
 09BA           ;       total = id + length + instruction + address + value;
 09BA 62D000            mov REG[0xd0],>__r0
 09BD 52FB              mov A,[X-5]
 09BF 5300              mov [__r1],A
 09C1 550000            mov [__r0],0
 09C4 52FC              mov A,[X-4]
 09C6 0200              add A,[__r1]
 09C8 5300              mov [__r1],A
 09CA 5000              mov A,0
 09CC 0A00              adc A,[__r0]
 09CE 5300              mov [__r0],A
 09D0 52FA              mov A,[X-6]
 09D2 0400              add [__r1],A
 09D4 0E0000            adc [__r0],0
 09D7 52F9              mov A,[X-7]
 09D9 0400              add [__r1],A
 09DB 0E0000            adc [__r0],0
 09DE 52F8              mov A,[X-8]
 09E0 5300              mov [__r3],A
 09E2 550000            mov [__r2],0
 09E5 5100              mov A,[__r1]
 09E7 0200              add A,[__r3]
 09E9 5402              mov [X+2],A
 09EB 5100              mov A,[__r0]
 09ED 0A00              adc A,[__r2]
 09EF 5401              mov [X+1],A
 09F1                   .dbline 515
 09F1           ;       
 09F1           ;       // Calculate the checksum value for our servo communication.
 09F1           ;       checksum = 255-(total%256);
 09F1 5001              mov A,1
 09F3 08                push A
 09F4 5000              mov A,0
 09F6 08                push A
 09F7 5201              mov A,[X+1]
 09F9 08                push A
 09FA 5202              mov A,[X+2]
 09FC 08                push A
 09FD 7C0000            xcall __divmod_16X16_16
 0A00 38FE              add SP,-2
 0A02 18                pop A
 0A03 5300              mov [__r1],A
 0A05 18                pop A
 0A06 50FF              mov A,-1
 0A08 1200              sub A,[__r1]
 0A0A 5400              mov [X+0],A
 0A0C                   .dbline 518
 0A0C           ;       
 0A0C           ;       // Talk to the servo.
 0A0C           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A0C 10                push X
 0A0D 50FF              mov A,-1
 0A0F 7C0000            xcall _TX_REPEATER_PutChar
 0A12 20                pop X
 0A13                   .dbline 519
 0A13           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0A13 10                push X
 0A14 50FF              mov A,-1
 0A16 7C0000            xcall _TX_REPEATER_PutChar
 0A19 20                pop X
 0A1A                   .dbline 520
 0A1A           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0A1A 10                push X
 0A1B 52FC              mov A,[X-4]
 0A1D 7C0000            xcall _TX_REPEATER_PutChar
 0A20 20                pop X
 0A21                   .dbline 521
 0A21           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0A21 10                push X
 0A22 52FB              mov A,[X-5]
 0A24 7C0000            xcall _TX_REPEATER_PutChar
 0A27 20                pop X
 0A28                   .dbline 522
 0A28           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0A28 10                push X
 0A29 52FA              mov A,[X-6]
 0A2B 7C0000            xcall _TX_REPEATER_PutChar
 0A2E 20                pop X
 0A2F                   .dbline 523
 0A2F           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0A2F 10                push X
 0A30 52F9              mov A,[X-7]
 0A32 7C0000            xcall _TX_REPEATER_PutChar
 0A35 20                pop X
 0A36                   .dbline 524
 0A36           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0A36 10                push X
 0A37 52F8              mov A,[X-8]
 0A39 7C0000            xcall _TX_REPEATER_PutChar
 0A3C 20                pop X
 0A3D                   .dbline 525
 0A3D           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0A3D 10                push X
 0A3E 5200              mov A,[X+0]
 0A40 7C0000            xcall _TX_REPEATER_PutChar
 0A43 20                pop X
 0A44           L170:
 0A44                   .dbline 528
 0A44           ;       
 0A44           ;       // Wait for the transmission to finish.
 0A44           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0A44           L171:
 0A44                   .dbline 528
 0A44 10                push X
 0A45 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0A48 62D000            mov REG[0xd0],>__r0
 0A4B 20                pop X
 0A4C 5300              mov [__r0],A
 0A4E 470020            tst [__r0],32
 0A51 AFF2              jz L170
 0A53                   .dbline 531
 0A53           ;       
 0A53           ;       // Make completely sure we're done.
 0A53           ;       xmitWait();
 0A53 935A              xcall _xmitWait
 0A55                   .dbline -2
 0A55           L169:
 0A55 38FD              add SP,-3
 0A57 20                pop X
 0A58                   .dbline 0 ; func end
 0A58 7F                ret
 0A59                   .dbsym l total 1 I
 0A59                   .dbsym l checksum 0 c
 0A59                   .dbsym l value -8 c
 0A59                   .dbsym l address -7 c
 0A59                   .dbsym l instruction -6 c
 0A59                   .dbsym l length -5 c
 0A59                   .dbsym l id -4 c
 0A59                   .dbend
 0A59                   .dbfunc e longServoInstruction _longServoInstruction fV
 0A59           ;          total -> X+1
 0A59           ;       checksum -> X+0
 0A59           ;         value2 -> X-9
 0A59           ;         value1 -> X-8
 0A59           ;        address -> X-7
 0A59           ;    instruction -> X-6
 0A59           ;         length -> X-5
 0A59           ;             id -> X-4
 0A59           _longServoInstruction::
 0A59                   .dbline -1
 0A59 10                push X
 0A5A 4F                mov X,SP
 0A5B 3803              add SP,3
 0A5D                   .dbline 536
 0A5D           ; }
 0A5D           ; 
 0A5D           ; // This function receives a destination, command length, instruction type, address, and two values.
 0A5D           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0A5D           ; {
 0A5D                   .dbline 540
 0A5D           ;       char checksum;
 0A5D           ;       int total;
 0A5D           ;       
 0A5D           ;       total = id + length + instruction + address + value1 + value2;
 0A5D 62D000            mov REG[0xd0],>__r0
 0A60 52FB              mov A,[X-5]
 0A62 5300              mov [__r1],A
 0A64 550000            mov [__r0],0
 0A67 52FC              mov A,[X-4]
 0A69 0200              add A,[__r1]
 0A6B 5300              mov [__r1],A
 0A6D 5000              mov A,0
 0A6F 0A00              adc A,[__r0]
 0A71 5300              mov [__r0],A
 0A73 52FA              mov A,[X-6]
 0A75 0400              add [__r1],A
 0A77 0E0000            adc [__r0],0
 0A7A 52F9              mov A,[X-7]
 0A7C 0400              add [__r1],A
 0A7E 0E0000            adc [__r0],0
 0A81 52F8              mov A,[X-8]
 0A83 0400              add [__r1],A
 0A85 0E0000            adc [__r0],0
 0A88 52F7              mov A,[X-9]
 0A8A 5300              mov [__r3],A
 0A8C 550000            mov [__r2],0
 0A8F 5100              mov A,[__r1]
 0A91 0200              add A,[__r3]
 0A93 5402              mov [X+2],A
 0A95 5100              mov A,[__r0]
 0A97 0A00              adc A,[__r2]
 0A99 5401              mov [X+1],A
 0A9B                   .dbline 543
 0A9B           ;       
 0A9B           ;       // Calculate the checksum value for our servo communication.
 0A9B           ;       checksum = 255-(total%256);
 0A9B 5001              mov A,1
 0A9D 08                push A
 0A9E 5000              mov A,0
 0AA0 08                push A
 0AA1 5201              mov A,[X+1]
 0AA3 08                push A
 0AA4 5202              mov A,[X+2]
 0AA6 08                push A
 0AA7 7C0000            xcall __divmod_16X16_16
 0AAA 38FE              add SP,-2
 0AAC 18                pop A
 0AAD 5300              mov [__r1],A
 0AAF 18                pop A
 0AB0 50FF              mov A,-1
 0AB2 1200              sub A,[__r1]
 0AB4 5400              mov [X+0],A
 0AB6                   .dbline 546
 0AB6           ;       
 0AB6           ;       // Talk to the servo.
 0AB6           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0AB6 10                push X
 0AB7 50FF              mov A,-1
 0AB9 7C0000            xcall _TX_REPEATER_PutChar
 0ABC 20                pop X
 0ABD                   .dbline 547
 0ABD           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0ABD 10                push X
 0ABE 50FF              mov A,-1
 0AC0 7C0000            xcall _TX_REPEATER_PutChar
 0AC3 20                pop X
 0AC4                   .dbline 548
 0AC4           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0AC4 10                push X
 0AC5 52FC              mov A,[X-4]
 0AC7 7C0000            xcall _TX_REPEATER_PutChar
 0ACA 20                pop X
 0ACB                   .dbline 549
 0ACB           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0ACB 10                push X
 0ACC 52FB              mov A,[X-5]
 0ACE 7C0000            xcall _TX_REPEATER_PutChar
 0AD1 20                pop X
 0AD2                   .dbline 550
 0AD2           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AD2 10                push X
 0AD3 52FA              mov A,[X-6]
 0AD5 7C0000            xcall _TX_REPEATER_PutChar
 0AD8 20                pop X
 0AD9                   .dbline 551
 0AD9           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AD9 10                push X
 0ADA 52F9              mov A,[X-7]
 0ADC 7C0000            xcall _TX_REPEATER_PutChar
 0ADF 20                pop X
 0AE0                   .dbline 552
 0AE0           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0AE0 10                push X
 0AE1 52F8              mov A,[X-8]
 0AE3 7C0000            xcall _TX_REPEATER_PutChar
 0AE6 20                pop X
 0AE7                   .dbline 553
 0AE7           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0AE7 10                push X
 0AE8 52F7              mov A,[X-9]
 0AEA 7C0000            xcall _TX_REPEATER_PutChar
 0AED 20                pop X
 0AEE                   .dbline 554
 0AEE           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0AEE 10                push X
 0AEF 5200              mov A,[X+0]
 0AF1 7C0000            xcall _TX_REPEATER_PutChar
 0AF4 20                pop X
 0AF5           L174:
 0AF5                   .dbline 557
 0AF5           ;       
 0AF5           ;       // Wait for the transmission to finish.
 0AF5           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0AF5           L175:
 0AF5                   .dbline 557
 0AF5 10                push X
 0AF6 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0AF9 62D000            mov REG[0xd0],>__r0
 0AFC 20                pop X
 0AFD 5300              mov [__r0],A
 0AFF 470020            tst [__r0],32
 0B02 AFF2              jz L174
 0B04                   .dbline 560
 0B04           ;       
 0B04           ;       // Make completely sure we're done.
 0B04           ;       xmitWait();
 0B04 92A9              xcall _xmitWait
 0B06                   .dbline -2
 0B06           L173:
 0B06 38FD              add SP,-3
 0B08 20                pop X
 0B09                   .dbline 0 ; func end
 0B09 7F                ret
 0B0A                   .dbsym l total 1 I
 0B0A                   .dbsym l checksum 0 c
 0B0A                   .dbsym l value2 -9 c
 0B0A                   .dbsym l value1 -8 c
 0B0A                   .dbsym l address -7 c
 0B0A                   .dbsym l instruction -6 c
 0B0A                   .dbsym l length -5 c
 0B0A                   .dbsym l id -4 c
 0B0A                   .dbend
 0B0A                   .dbfunc e configToggle _configToggle fV
 0B0A           ;           mode -> X-5
 0B0A           _configToggle::
 0B0A                   .dbline -1
 0B0A 10                push X
 0B0B 4F                mov X,SP
 0B0C                   .dbline 566
 0B0C           ; }
 0B0C           ; 
 0B0C           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B0C           ; // half duplex UART serial communication line.
 0B0C           ; void configToggle(int mode)
 0B0C           ; {
 0B0C                   .dbline 568
 0B0C           ;       // Disconnect from the global bus and leave the pin high.
 0B0C           ;       PRT0DR |= 0b11111111;
 0B0C 4300FF            or REG[0],-1
 0B0F                   .dbline 569
 0B0F           ;       PRT0GS &= 0b01000000;
 0B0F 410240            and REG[0x2],64
 0B12                   .dbline 573
 0B12           ; 
 0B12           ;       // Unload the configuration of the current state.
 0B12           ;       // If there is no state, blindly wipe all configurations.
 0B12           ;       if(STATE)
 0B12 62D000            mov REG[0xd0],>_STATE
 0B15 3C0000            cmp [_STATE],0
 0B18 B006              jnz X53
 0B1A 3C0100            cmp [_STATE+1],0
 0B1D A010              jz L178
 0B1F           X53:
 0B1F                   .dbline 574
 0B1F           ;       {
 0B1F                   .dbline 575
 0B1F           ;               unloadConfig(STATE);
 0B1F 62D000            mov REG[0xd0],>_STATE
 0B22 5100              mov A,[_STATE]
 0B24 08                push A
 0B25 5101              mov A,[_STATE+1]
 0B27 08                push A
 0B28 90C9              xcall _unloadConfig
 0B2A 38FE              add SP,-2
 0B2C                   .dbline 576
 0B2C           ;       }
 0B2C 8003              xjmp L179
 0B2E           L178:
 0B2E                   .dbline 578
 0B2E           ;       else
 0B2E           ;       {
 0B2E                   .dbline 579
 0B2E           ;               unloadAllConfigs();
 0B2E 90B9              xcall _unloadAllConfigs
 0B30                   .dbline 580
 0B30           ;       }
 0B30           L179:
 0B30                   .dbline 582
 0B30           ;       
 0B30           ;       if(mode == PC_MODE)
 0B30 3DFB00            cmp [X-5],0
 0B33 B037              jnz L180
 0B35 3DFC02            cmp [X-4],2
 0B38 B032              jnz L180
 0B3A           X54:
 0B3A                   .dbline 583
 0B3A           ;       {
 0B3A                   .dbline 584
 0B3A           ;               LoadConfig_pc_listener();
 0B3A 7C0000            xcall _LoadConfig_pc_listener
 0B3D                   .dbline 586
 0B3D           ; 
 0B3D           ;               COMP_SERIAL_CmdReset();                                                 // Initialize the buffer.
 0B3D 10                push X
 0B3E 7C0000            xcall _COMP_SERIAL_CmdReset
 0B41 20                pop X
 0B42                   .dbline 587
 0B42           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0B42 10                push X
 0B43 5001              mov A,1
 0B45 7C0000            xcall _COMP_SERIAL_IntCntl
 0B48 20                pop X
 0B49                   .dbline 588
 0B49           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0B49 10                push X
 0B4A 5000              mov A,0
 0B4C 7C0000            xcall _COMP_SERIAL_Start
 0B4F 20                pop X
 0B50                   .dbline 590
 0B50           ;               
 0B50           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0B50 10                push X
 0B51 5000              mov A,0
 0B53 7C0000            xcall _TX_REPEATER_Start
 0B56 20                pop X
 0B57                   .dbline 592
 0B57           ;               
 0B57           ;               TIMEOUT = 0;
 0B57 62D000            mov REG[0xd0],>_TIMEOUT
 0B5A 550100            mov [_TIMEOUT+1],0
 0B5D 550000            mov [_TIMEOUT],0
 0B60                   .dbline 593
 0B60           ;               STATE = PC_MODE;
 0B60 62D000            mov REG[0xd0],>_STATE
 0B63 550102            mov [_STATE+1],2
 0B66 550000            mov [_STATE],0
 0B69                   .dbline 594
 0B69           ;       }
 0B69 807A              xjmp L181
 0B6B           L180:
 0B6B                   .dbline 595
 0B6B           ;       else if(mode == RX_MODE)
 0B6B 3DFB00            cmp [X-5],0
 0B6E B02C              jnz L182
 0B70 3DFC01            cmp [X-4],1
 0B73 B027              jnz L182
 0B75           X55:
 0B75                   .dbline 596
 0B75           ;       {
 0B75                   .dbline 597
 0B75           ;               LoadConfig_receiver_config();
 0B75 7C0000            xcall _LoadConfig_receiver_config
 0B78                   .dbline 600
 0B78           ;               
 0B78           ;               // Start the receiver.
 0B78           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0B78 10                push X
 0B79 5000              mov A,0
 0B7B 7C0000            xcall _RECEIVE_Start
 0B7E 20                pop X
 0B7F                   .dbline 603
 0B7F           ;               
 0B7F           ;               // Start response timeout timer and enable its interrupt routine.
 0B7F           ;               TIMEOUT = 0;
 0B7F 62D000            mov REG[0xd0],>_TIMEOUT
 0B82 550100            mov [_TIMEOUT+1],0
 0B85 550000            mov [_TIMEOUT],0
 0B88                   .dbline 604
 0B88           ;               RX_TIMEOUT_EnableInt();
 0B88 10                push X
 0B89 7C0000            xcall _RX_TIMEOUT_EnableInt
 0B8C                   .dbline 605
 0B8C           ;               RX_TIMEOUT_Start();
 0B8C 7C0000            xcall _RX_TIMEOUT_Start
 0B8F 20                pop X
 0B90                   .dbline 607
 0B90           ;               
 0B90           ;               STATE = RX_MODE;
 0B90 62D000            mov REG[0xd0],>_STATE
 0B93 550101            mov [_STATE+1],1
 0B96 550000            mov [_STATE],0
 0B99                   .dbline 608
 0B99           ;       }
 0B99 804A              xjmp L183
 0B9B           L182:
 0B9B                   .dbline 609
 0B9B           ;       else if(mode == TX_MODE)
 0B9B 3DFB00            cmp [X-5],0
 0B9E B045              jnz L184
 0BA0 3DFC00            cmp [X-4],0
 0BA3 B040              jnz L184
 0BA5           X56:
 0BA5                   .dbline 610
 0BA5           ;       {
 0BA5                   .dbline 611
 0BA5           ;               LoadConfig_transmitter_config();
 0BA5 7C0000            xcall _LoadConfig_transmitter_config
 0BA8                   .dbline 613
 0BA8           ;               // Start the transmitter.
 0BA8           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0BA8 10                push X
 0BA9 5000              mov A,0
 0BAB 7C0000            xcall _TRANSMIT_Start
 0BAE 20                pop X
 0BAF                   .dbline 615
 0BAF           ;               
 0BAF           ;               TIMEOUT = 0;
 0BAF 62D000            mov REG[0xd0],>_TIMEOUT
 0BB2 550100            mov [_TIMEOUT+1],0
 0BB5 550000            mov [_TIMEOUT],0
 0BB8                   .dbline 616
 0BB8           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0BB8 10                push X
 0BB9 7C0000            xcall _TX_TIMEOUT_EnableInt
 0BBC                   .dbline 617
 0BBC           ;               TX_TIMEOUT_Start();             // Start the timer.
 0BBC 7C0000            xcall _TX_TIMEOUT_Start
 0BBF 20                pop X
 0BC0           L186:
 0BC0                   .dbline 620
 0BC0           ;               
 0BC0           ;               while(!TIMEOUT)
 0BC0           ;               {
 0BC0                   .dbline 623
 0BC0           ;                       // Do nothing while we wait for one timeout period.
 0BC0           ;                       // This is to allow everyone to get in the right configuration.
 0BC0           ;               }
 0BC0           L187:
 0BC0                   .dbline 619
 0BC0 62D000            mov REG[0xd0],>_TIMEOUT
 0BC3 3C0000            cmp [_TIMEOUT],0
 0BC6 B006              jnz X57
 0BC8 3C0100            cmp [_TIMEOUT+1],0
 0BCB AFF4              jz L186
 0BCD           X57:
 0BCD                   .dbline 625
 0BCD           ;               
 0BCD           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0BCD 10                push X
 0BCE 7C0000            xcall _TX_TIMEOUT_Stop
 0BD1 20                pop X
 0BD2                   .dbline 626
 0BD2           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0BD2 62D000            mov REG[0xd0],>_TIMEOUT
 0BD5 550100            mov [_TIMEOUT+1],0
 0BD8 550000            mov [_TIMEOUT],0
 0BDB                   .dbline 628
 0BDB           ;               
 0BDB           ;               STATE = TX_MODE;
 0BDB 62D000            mov REG[0xd0],>_STATE
 0BDE 550100            mov [_STATE+1],0
 0BE1 550000            mov [_STATE],0
 0BE4                   .dbline 629
 0BE4           ;       }
 0BE4           L184:
 0BE4           L183:
 0BE4           L181:
 0BE4                   .dbline 632
 0BE4           ;       
 0BE4           ;       // Reconnect to the global bus.
 0BE4           ;       PRT0GS |= 0b10111111;
 0BE4 4302BF            or REG[0x2],-65
 0BE7                   .dbline -2
 0BE7           L177:
 0BE7 20                pop X
 0BE8                   .dbline 0 ; func end
 0BE8 7F                ret
 0BE9                   .dbsym l mode -5 I
 0BE9                   .dbend
 0BE9                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0BE9           _unloadAllConfigs::
 0BE9                   .dbline -1
 0BE9                   .dbline 638
 0BE9           ; }
 0BE9           ; 
 0BE9           ; // This function blindly unloads all user configurations. This will be called once,
 0BE9           ; // when the system initially has no known state.
 0BE9           ; void unloadAllConfigs(void)
 0BE9           ; {
 0BE9                   .dbline 639
 0BE9           ;       UnloadConfig_pc_listener();
 0BE9 7C0000            xcall _UnloadConfig_pc_listener
 0BEC                   .dbline 640
 0BEC           ;       UnloadConfig_receiver_config();
 0BEC 7C0000            xcall _UnloadConfig_receiver_config
 0BEF                   .dbline 641
 0BEF           ;       UnloadConfig_transmitter_config();
 0BEF 7C0000            xcall _UnloadConfig_transmitter_config
 0BF2                   .dbline -2
 0BF2           L189:
 0BF2                   .dbline 0 ; func end
 0BF2 7F                ret
 0BF3                   .dbend
 0BF3                   .dbfunc e unloadConfig _unloadConfig fV
 0BF3           ;     config_num -> X-5
 0BF3           _unloadConfig::
 0BF3                   .dbline -1
 0BF3 10                push X
 0BF4 4F                mov X,SP
 0BF5                   .dbline 647
 0BF5           ; }
 0BF5           ; 
 0BF5           ; // This function unloads the configuration corresponding to the config number passed to it.
 0BF5           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0BF5           ; void unloadConfig(int config_num)
 0BF5           ; {
 0BF5                   .dbline 648
 0BF5           ;       if(config_num == PC_MODE)
 0BF5 3DFB00            cmp [X-5],0
 0BF8 B00B              jnz L191
 0BFA 3DFC02            cmp [X-4],2
 0BFD B006              jnz L191
 0BFF           X58:
 0BFF                   .dbline 649
 0BFF           ;       {
 0BFF                   .dbline 650
 0BFF           ;               UnloadConfig_pc_listener();
 0BFF 7C0000            xcall _UnloadConfig_pc_listener
 0C02                   .dbline 651
 0C02           ;       }
 0C02 801D              xjmp L192
 0C04           L191:
 0C04                   .dbline 652
 0C04           ;       else if(config_num == RX_MODE)
 0C04 3DFB00            cmp [X-5],0
 0C07 B00B              jnz L193
 0C09 3DFC01            cmp [X-4],1
 0C0C B006              jnz L193
 0C0E           X59:
 0C0E                   .dbline 653
 0C0E           ;       {
 0C0E                   .dbline 654
 0C0E           ;               UnloadConfig_receiver_config();
 0C0E 7C0000            xcall _UnloadConfig_receiver_config
 0C11                   .dbline 655
 0C11           ;       }
 0C11 800E              xjmp L194
 0C13           L193:
 0C13                   .dbline 656
 0C13           ;       else if(config_num == TX_MODE)
 0C13 3DFB00            cmp [X-5],0
 0C16 B009              jnz L195
 0C18 3DFC00            cmp [X-4],0
 0C1B B004              jnz L195
 0C1D           X60:
 0C1D                   .dbline 657
 0C1D           ;       {
 0C1D                   .dbline 658
 0C1D           ;               UnloadConfig_transmitter_config();
 0C1D 7C0000            xcall _UnloadConfig_transmitter_config
 0C20                   .dbline 659
 0C20           ;       }
 0C20           L195:
 0C20           L194:
 0C20           L192:
 0C20                   .dbline -2
 0C20           L190:
 0C20 20                pop X
 0C21                   .dbline 0 ; func end
 0C21 7F                ret
 0C22                   .dbsym l config_num -5 I
 0C22                   .dbend
 0C22                   .dbfunc e initializeSlaves _initializeSlaves fV
 0C22           ;        maxPrev -> X+4
 0C22           ;              i -> X+2
 0C22           ;        currVal -> X+0
 0C22           _initializeSlaves::
 0C22                   .dbline -1
 0C22 10                push X
 0C23 4F                mov X,SP
 0C24 3806              add SP,6
 0C26                   .dbline 663
 0C26           ; }
 0C26           ; 
 0C26           ; void initializeSlaves(void)
 0C26           ; {
 0C26                   .dbline 664
 0C26           ;       int maxPrev = 0;        // The maximum previous value.
 0C26 560500            mov [X+5],0
 0C29 560400            mov [X+4],0
 0C2C                   .dbline 666
 0C2C           ;       int currVal;            // The current number of modules found.
 0C2C           ;       int i = 0;                      // An int for looping.
 0C2C 560300            mov [X+3],0
 0C2F 560200            mov [X+2],0
 0C32           L198:
 0C32                   .dbline 669
 0C32           ;       
 0C32           ;       // Do nothing while we find nothing.
 0C32           ;       while(!initSweep()) { }
 0C32                   .dbline 669
 0C32           L199:
 0C32                   .dbline 669
 0C32 9081              xcall _initSweep
 0C34 62D000            mov REG[0xd0],>__r0
 0C37 3C0000            cmp [__r0],0
 0C3A B006              jnz X61
 0C3C 3C0000            cmp [__r1],0
 0C3F AFF2              jz L198
 0C41           X61:
 0C41 803F              xjmp L202
 0C43           L201:
 0C43                   .dbline 672
 0C43           ;       
 0C43           ;       while(!maxPrev)
 0C43           ;       {
 0C43                   .dbline 674
 0C43           ;               // Find the maximum value of modules found, it's our number.
 0C43           ;               for(i = 0; i < NUM_SWEEPS; i++)
 0C43 560300            mov [X+3],0
 0C46 560200            mov [X+2],0
 0C49           L204:
 0C49                   .dbline 675
 0C49           ;               {
 0C49                   .dbline 676
 0C49           ;                       currVal = initSweep();
 0C49 906A              xcall _initSweep
 0C4B 62D000            mov REG[0xd0],>__r0
 0C4E 5100              mov A,[__r1]
 0C50 5401              mov [X+1],A
 0C52 5100              mov A,[__r0]
 0C54 5400              mov [X+0],A
 0C56                   .dbline 678
 0C56           ;                       
 0C56           ;                       if(currVal > maxPrev)
 0C56 5205              mov A,[X+5]
 0C58 1301              sub A,[X+1]
 0C5A 5200              mov A,[X+0]
 0C5C 3180              xor A,-128
 0C5E 5300              mov [__rX],A
 0C60 5204              mov A,[X+4]
 0C62 3180              xor A,-128
 0C64 1A00              sbb A,[__rX]
 0C66 D009              jnc L208
 0C68           X62:
 0C68                   .dbline 679
 0C68           ;                       {
 0C68                   .dbline 680
 0C68           ;                               maxPrev = currVal;
 0C68 5201              mov A,[X+1]
 0C6A 5405              mov [X+5],A
 0C6C 5200              mov A,[X+0]
 0C6E 5404              mov [X+4],A
 0C70                   .dbline 681
 0C70           ;                       }
 0C70           L208:
 0C70                   .dbline 682
 0C70           ;               }
 0C70           L205:
 0C70                   .dbline 674
 0C70 7703              inc [X+3]
 0C72 0F0200            adc [X+2],0
 0C75                   .dbline 674
 0C75 5203              mov A,[X+3]
 0C77 1105              sub A,5
 0C79 5202              mov A,[X+2]
 0C7B 3180              xor A,-128
 0C7D 1980              sbb A,(0 ^ 0x80)
 0C7F CFC9              jc L204
 0C81           X63:
 0C81                   .dbline 683
 0C81           ;       }
 0C81           L202:
 0C81                   .dbline 671
 0C81 3D0400            cmp [X+4],0
 0C84 B006              jnz X64
 0C86 3D0500            cmp [X+5],0
 0C89 AFB9              jz L201
 0C8B           X64:
 0C8B           L210:
 0C8B                   .dbline 686
 0C8B           ;       
 0C8B           ;       // Sweep until we get the max number again.
 0C8B           ;       while(initSweep() != maxPrev) { }
 0C8B                   .dbline 686
 0C8B           L211:
 0C8B                   .dbline 686
 0C8B 9028              xcall _initSweep
 0C8D 62D000            mov REG[0xd0],>__r0
 0C90 5100              mov A,[__r0]
 0C92 3B04              cmp A,[X+4]
 0C94 BFF6              jnz L210
 0C96 5100              mov A,[__r1]
 0C98 3B05              cmp A,[X+5]
 0C9A BFF0              jnz L210
 0C9C           X65:
 0C9C                   .dbline 689
 0C9C           ;       
 0C9C           ;       // Store the number of modules.
 0C9C           ;       NUM_MODULES = maxPrev;
 0C9C 62D000            mov REG[0xd0],>_NUM_MODULES
 0C9F 5205              mov A,[X+5]
 0CA1 5301              mov [_NUM_MODULES+1],A
 0CA3 5204              mov A,[X+4]
 0CA5 5300              mov [_NUM_MODULES],A
 0CA7                   .dbline 692
 0CA7           ;       
 0CA7           ;       // Switch back to PC mode.
 0CA7           ;       configToggle(PC_MODE);
 0CA7 5000              mov A,0
 0CA9 08                push A
 0CAA 5002              mov A,2
 0CAC 08                push A
 0CAD 9E5B              xcall _configToggle
 0CAF 38FE              add SP,-2
 0CB1                   .dbline -2
 0CB1           L197:
 0CB1 38FA              add SP,-6
 0CB3 20                pop X
 0CB4                   .dbline 0 ; func end
 0CB4 7F                ret
 0CB5                   .dbsym l maxPrev 4 I
 0CB5                   .dbsym l i 2 I
 0CB5                   .dbsym l currVal 0 I
 0CB5                   .dbend
 0CB5                   .dbfunc e initSweep _initSweep fI
 0CB5           ;     ping_tries -> X+6
 0CB5           ;              i -> X+4
 0CB5           ;   num_timeouts -> X+2
 0CB5           ; currNumModules -> X+0
 0CB5           _initSweep::
 0CB5                   .dbline -1
 0CB5 10                push X
 0CB6 4F                mov X,SP
 0CB7 3808              add SP,8
 0CB9                   .dbline 696
 0CB9           ; }
 0CB9           ; 
 0CB9           ; int initSweep(void)
 0CB9           ; {
 0CB9                   .dbline 697
 0CB9           ;       int i = 0;                                      // An iterator for looping.
 0CB9 560500            mov [X+5],0
 0CBC 560400            mov [X+4],0
 0CBF                   .dbline 698
 0CBF           ;       int num_timeouts = 0;           // The number of consecutive timeouts.
 0CBF 560300            mov [X+3],0
 0CC2 560200            mov [X+2],0
 0CC5                   .dbline 699
 0CC5           ;       int ping_tries = 5;                     // The number of times to try a ping on an unregistered module.
 0CC5 560705            mov [X+7],5
 0CC8 560600            mov [X+6],0
 0CCB                   .dbline 700
 0CCB           ;       int currNumModules = 0;         // The number of modules found in this current sweep.
 0CCB 560100            mov [X+1],0
 0CCE 560000            mov [X+0],0
 0CD1                   .dbline 703
 0CD1           ;       
 0CD1           ;       // Clear the modules.
 0CD1           ;       clearConfig();
 0CD1 7C0181            xcall _clearConfig
 0CD4 8065              xjmp L215
 0CD6           L214:
 0CD6                   .dbline 708
 0CD6           ;       
 0CD6           ;       // This loop continuously probes and listens at intervals
 0CD6           ;       // set by the RX_TIMEOUT_DURATION variable.
 0CD6           ;       while(num_timeouts < MAX_TIMEOUTS)
 0CD6           ;       {
 0CD6                   .dbline 710
 0CD6           ;               // If we are not maxed out on modules, look for more.
 0CD6           ;               if(currNumModules < MAX_MODULES)
 0CD6 5201              mov A,[X+1]
 0CD8 11FA              sub A,-6
 0CDA 5200              mov A,[X+0]
 0CDC 3180              xor A,-128
 0CDE 1980              sbb A,(0 ^ 0x80)
 0CE0 D004              jnc L217
 0CE2           X66:
 0CE2                   .dbline 711
 0CE2           ;               {
 0CE2                   .dbline 712
 0CE2           ;                       sayHello();
 0CE2 7C01F5            xcall _sayHello
 0CE5                   .dbline 713
 0CE5           ;               }
 0CE5           L217:
 0CE5                   .dbline 715
 0CE5           ;                       
 0CE5           ;               if(validTransmission())
 0CE5 7C024D            xcall _validTransmission
 0CE8 62D000            mov REG[0xd0],>__r0
 0CEB 3C0000            cmp [__r0],0
 0CEE B006              jnz X67
 0CF0 3C0000            cmp [__r1],0
 0CF3 A041              jz L219
 0CF5           X67:
 0CF5                   .dbline 716
 0CF5           ;               {
 0CF5                   .dbline 717
 0CF5           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0CF5 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0CF8 3C00C8            cmp [_COMMAND_TYPE],-56
 0CFB B03E              jnz L220
 0CFD                   .dbline 718
 0CFD           ;                       {
 0CFD                   .dbline 720
 0CFD           ;                               // If this is for me, assign them an ID.
 0CFD           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0CFD 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D00 3C0000            cmp [_COMMAND_DESTINATION],0
 0D03 B036              jnz L220
 0D05                   .dbline 721
 0D05           ;                               {
 0D05                   .dbline 722
 0D05           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D05 560300            mov [X+3],0
 0D08 560200            mov [X+2],0
 0D0B                   .dbline 724
 0D0B           ;               
 0D0B           ;                                       if(assignID(currNumModules+1))
 0D0B 62D000            mov REG[0xd0],>__r0
 0D0E 5201              mov A,[X+1]
 0D10 0101              add A,1
 0D12 5300              mov [__r1],A
 0D14 5200              mov A,[X+0]
 0D16 0900              adc A,0
 0D18 08                push A
 0D19 5100              mov A,[__r1]
 0D1B 08                push A
 0D1C 7C00D7            xcall _assignID
 0D1F 38FE              add SP,-2
 0D21 62D000            mov REG[0xd0],>__r0
 0D24 3C0000            cmp [__r0],0
 0D27 B006              jnz X68
 0D29 3C0000            cmp [__r1],0
 0D2C A00D              jz L220
 0D2E           X68:
 0D2E                   .dbline 725
 0D2E           ;                                       {
 0D2E                   .dbline 726
 0D2E           ;                                               currNumModules++;               // Increment the number of modules connected.
 0D2E 7701              inc [X+1]
 0D30 0F0000            adc [X+0],0
 0D33                   .dbline 727
 0D33           ;                                       }
 0D33                   .dbline 728
 0D33           ;                               }
 0D33                   .dbline 729
 0D33           ;                       }
 0D33                   .dbline 730
 0D33           ;               }
 0D33 8006              xjmp L220
 0D35           L219:
 0D35                   .dbline 732
 0D35           ;               else
 0D35           ;               {       
 0D35                   .dbline 733
 0D35           ;                       num_timeouts++;
 0D35 7703              inc [X+3]
 0D37 0F0200            adc [X+2],0
 0D3A                   .dbline 734
 0D3A           ;               }
 0D3A           L220:
 0D3A                   .dbline 735
 0D3A           ;       }
 0D3A           L215:
 0D3A                   .dbline 707
 0D3A 5203              mov A,[X+3]
 0D3C 1105              sub A,5
 0D3E 5202              mov A,[X+2]
 0D40 3180              xor A,-128
 0D42 1980              sbb A,(0 ^ 0x80)
 0D44 CF91              jc L214
 0D46           X69:
 0D46                   .dbline 738
 0D46           ;       
 0D46           ;       // If we didn't find any new modules, check to see if some already exist.
 0D46           ;       if(!currNumModules)
 0D46 3D0000            cmp [X+0],0
 0D49 B056              jnz L227
 0D4B 3D0100            cmp [X+1],0
 0D4E B051              jnz L227
 0D50           X70:
 0D50                   .dbline 739
 0D50           ;       {
 0D50                   .dbline 741
 0D50           ;               // Try to ping the next module up from our current number ping_tries times.
 0D50           ;               for(i = 0; i < ping_tries; i++)
 0D50 560500            mov [X+5],0
 0D53 560400            mov [X+4],0
 0D56 8034              xjmp L232
 0D58           L229:
 0D58                   .dbline 742
 0D58           ;               {       
 0D58                   .dbline 743
 0D58           ;                       if(pingModule(currNumModules+1))
 0D58 62D000            mov REG[0xd0],>__r0
 0D5B 5201              mov A,[X+1]
 0D5D 0101              add A,1
 0D5F 5300              mov [__r1],A
 0D61 5200              mov A,[X+0]
 0D63 0900              adc A,0
 0D65 08                push A
 0D66 5100              mov A,[__r1]
 0D68 08                push A
 0D69 7C0034            xcall _pingModule
 0D6C 38FE              add SP,-2
 0D6E 62D000            mov REG[0xd0],>__r0
 0D71 3C0000            cmp [__r0],0
 0D74 B006              jnz X71
 0D76 3C0000            cmp [__r1],0
 0D79 A00C              jz L233
 0D7B           X71:
 0D7B                   .dbline 744
 0D7B           ;                       {
 0D7B                   .dbline 745
 0D7B           ;                               currNumModules++;
 0D7B 7701              inc [X+1]
 0D7D 0F0000            adc [X+0],0
 0D80                   .dbline 746
 0D80           ;                               i = 0;
 0D80 560500            mov [X+5],0
 0D83 560400            mov [X+4],0
 0D86                   .dbline 747
 0D86           ;                       }
 0D86           L233:
 0D86                   .dbline 748
 0D86           ;               }
 0D86           L230:
 0D86                   .dbline 741
 0D86 7705              inc [X+5]
 0D88 0F0400            adc [X+4],0
 0D8B           L232:
 0D8B                   .dbline 741
 0D8B 5205              mov A,[X+5]
 0D8D 1307              sub A,[X+7]
 0D8F 5206              mov A,[X+6]
 0D91 3180              xor A,-128
 0D93 62D000            mov REG[0xd0],>__r0
 0D96 5300              mov [__rX],A
 0D98 5204              mov A,[X+4]
 0D9A 3180              xor A,-128
 0D9C 1A00              sbb A,[__rX]
 0D9E CFB9              jc L229
 0DA0           X72:
 0DA0                   .dbline 749
 0DA0           ;       }
 0DA0           L227:
 0DA0                   .dbline 751
 0DA0           ;       
 0DA0           ;       return currNumModules;
 0DA0 62D000            mov REG[0xd0],>__r0
 0DA3 5201              mov A,[X+1]
 0DA5 5300              mov [__r1],A
 0DA7 5200              mov A,[X+0]
 0DA9 5300              mov [__r0],A
 0DAB                   .dbline -2
 0DAB           L213:
 0DAB 38F8              add SP,-8
 0DAD 20                pop X
 0DAE                   .dbline 0 ; func end
 0DAE 7F                ret
 0DAF                   .dbsym l ping_tries 6 I
 0DAF                   .dbsym l i 4 I
 0DAF                   .dbsym l num_timeouts 2 I
 0DAF                   .dbsym l currNumModules 0 I
 0DAF                   .dbend
 0DAF                   .dbfunc e xmitWait _xmitWait fV
 0DAF           ;              i -> X+0
 0DAF           _xmitWait::
 0DAF                   .dbline -1
 0DAF 10                push X
 0DB0 4F                mov X,SP
 0DB1 3802              add SP,2
 0DB3                   .dbline 755
 0DB3           ; }
 0DB3           ; 
 0DB3           ; void xmitWait(void)
 0DB3           ; {
 0DB3                   .dbline 758
 0DB3           ;       int i;
 0DB3           ;       
 0DB3           ;       for(i = 0; i < 25; i++)
 0DB3 560100            mov [X+1],0
 0DB6 560000            mov [X+0],0
 0DB9           L236:
 0DB9                   .dbline 759
 0DB9           ;       {
 0DB9                   .dbline 761
 0DB9           ;               // Sit here and spin for about 50 microseconds.
 0DB9           ;       }
 0DB9           L237:
 0DB9                   .dbline 758
 0DB9 7701              inc [X+1]
 0DBB 0F0000            adc [X+0],0
 0DBE                   .dbline 758
 0DBE 5201              mov A,[X+1]
 0DC0 1119              sub A,25
 0DC2 5200              mov A,[X+0]
 0DC4 3180              xor A,-128
 0DC6 1980              sbb A,(0 ^ 0x80)
 0DC8 CFF0              jc L236
 0DCA           X73:
 0DCA                   .dbline -2
 0DCA           L235:
 0DCA 38FE              add SP,-2
 0DCC 20                pop X
 0DCD                   .dbline 0 ; func end
 0DCD 7F                ret
 0DCE                   .dbsym l i 0 I
 0DCE                   .dbend
 0DCE                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0DCE           _TX_TIMEOUT_ISR::
 0DCE                   .dbline -1
 0DCE 71C0              or F,-64
 0DD0 08                push A
 0DD1 5DD0              mov A,REG[0xd0]
 0DD3 08                push A
 0DD4                   .dbline 765
 0DD4           ; }
 0DD4           ; 
 0DD4           ; void TX_TIMEOUT_ISR(void)
 0DD4           ; {     
 0DD4                   .dbline 766
 0DD4           ;       TIMEOUT++;
 0DD4 62D000            mov REG[0xd0],>_TIMEOUT
 0DD7 7601              inc [_TIMEOUT+1]
 0DD9 0E0000            adc [_TIMEOUT],0
 0DDC                   .dbline 768
 0DDC           ;       
 0DDC           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0DDC 62DAFD            mov REG[0xda],-3
 0DDF                   .dbline -2
 0DDF           L240:
 0DDF 18                pop A
 0DE0 60D0              mov REG[208],A
 0DE2 18                pop A
 0DE3                   .dbline 0 ; func end
 0DE3 7E                reti
 0DE4                   .dbend
 0DE4                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0DE4           _RX_TIMEOUT_ISR::
 0DE4                   .dbline -1
 0DE4 71C0              or F,-64
 0DE6 08                push A
 0DE7 5DD0              mov A,REG[0xd0]
 0DE9 08                push A
 0DEA                   .dbline 772
 0DEA           ; }
 0DEA           ; 
 0DEA           ; void RX_TIMEOUT_ISR(void)
 0DEA           ; {     
 0DEA                   .dbline 773
 0DEA           ;       TIMEOUT++;
 0DEA 62D000            mov REG[0xd0],>_TIMEOUT
 0DED 7601              inc [_TIMEOUT+1]
 0DEF 0E0000            adc [_TIMEOUT],0
 0DF2                   .dbline 775
 0DF2           ;       
 0DF2           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0DF2 62DAFD            mov REG[0xda],-3
 0DF5                   .dbline -2
 0DF5           L241:
 0DF5 18                pop A
 0DF6 60D0              mov REG[208],A
 0DF8 18                pop A
 0DF9                   .dbline 0 ; func end
 0DF9 7E                reti
 0DFA                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
