 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 113
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 8-3-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the parent module of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; #include <stdlib.h>                   // Required for string conversions to floats/ints and vice versa.
 0000           ; #include <string.h>
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (2)
 0000           ; #define               RX_MODE                                         (1)
 0000           ; #define               TX_MODE                                         (0)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR                                           (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; #define               SERVO_START                                     (255)   // The start byte of a servo transmission.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (3)             // This is receive wait time in ms.
 0000           ; #define               POST_RX_WAIT                            (10)    // Wait time after a controller responds in ms.
 0000           ; #define               SERVO_FIND_TIME                         (24)    // The wait time after issuing clear config in ms.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (9)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; // Transmits a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; // Performs a non-blocking read operation on a data packet that has come from a controller.
 0000           ; int validResponse(void);
 0000           ; // Performs a data packet decode on a transmission from an external computer.
 0000           ; // This function also performs the desired operation when it is finished decoding.
 0000           ; void decodeTransmission(void);
 0000           ; // Performs a standard read or write command to a servo.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // Performs a write command to a servo value that is larger than one byte long.
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; // Sends out a request to clear all information and start over.
 0000           ; void clearConfig(void);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeChildren(void);
 0000           ; // A single initialization sweep.
 0000           ; int initSweep(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; int PREV_NUM_MODULES;         // Stores the previous number of modules that has been discovered.
 0000           ; int SUGGESTED_NUM_MODULES;    // Stores the module number that is suggested from the PC.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; int TIMEOUT;                          // This flag is set if there is a timeout.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 115
 0000           ;       // Initialize the number of modules.
 0000           ;       NUM_MODULES = 0;
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 116
 0009           ;       PREV_NUM_MODULES = 1;
 0009 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 000C 550101            mov [_PREV_NUM_MODULES+1],1
 000F 550000            mov [_PREV_NUM_MODULES],0
 0012                   .dbline 117
 0012           ;       SUGGESTED_NUM_MODULES = MAX_MODULES;
 0012 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0015 550109            mov [_SUGGESTED_NUM_MODULES+1],9
 0018 550000            mov [_SUGGESTED_NUM_MODULES],0
 001B                   .dbline 120
 001B           ;       
 001B           ;       // Activate GPIO ISR.
 001B           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 001B 43E020            or REG[0xe0],32
 001E                   .dbline 123
 001E           ;       
 001E           ;       // Turn on global interrupts for the transmission timeout timer.
 001E           ;       M8C_EnableGInt;
 001E 7101                      or  F, 01h
 0020           
 0020 8021              xjmp L3
 0022           L2:
 0022                   .dbline 126
 0022           ;       
 0022           ;       while(1)
 0022           ;       {
 0022                   .dbline 127
 0022           ;               if(!NUM_MODULES)
 0022 62D000            mov REG[0xd0],>_NUM_MODULES
 0025 3C0000            cmp [_NUM_MODULES],0
 0028 B00B              jnz L5
 002A 3C0100            cmp [_NUM_MODULES+1],0
 002D B006              jnz L5
 002F           X1:
 002F                   .dbline 128
 002F           ;               {
 002F                   .dbline 130
 002F           ;                       // Find some modules.
 002F           ;                       initializeChildren();
 002F 7C0CAF            xcall _initializeChildren
 0032                   .dbline 131
 0032           ;               }
 0032 800F              xjmp L6
 0034           L5:
 0034                   .dbline 132
 0034           ;               else if(COMP_SERIAL_bCmdCheck())
 0034 10                push X
 0035 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0038 62D000            mov REG[0xd0],>__r0
 003B 20                pop X
 003C 3900              cmp A,0
 003E A003              jz L7
 0040                   .dbline 133
 0040           ;               {
 0040                   .dbline 135
 0040           ;                       // If there's a computer command, read it.
 0040           ;                       decodeTransmission();
 0040 931D              xcall _decodeTransmission
 0042                   .dbline 136
 0042           ;               }
 0042           L7:
 0042           L6:
 0042                   .dbline 137
 0042           ;       }
 0042           L3:
 0042                   .dbline 125
 0042 8FDF              xjmp L2
 0044           X0:
 0044                   .dbline -2
 0044           L1:
 0044                   .dbline 0 ; func end
 0044 8FFF              jmp .
 0046                   .dbend
 0046                   .dbfunc e pingModule _pingModule fI
 0046           ;       response -> X+0
 0046           ;      module_id -> X-5
 0046           _pingModule::
 0046                   .dbline -1
 0046 10                push X
 0047 4F                mov X,SP
 0048 3802              add SP,2
 004A                   .dbline 141
 004A           ; }
 004A           ; 
 004A           ; int pingModule(int module_id)
 004A           ; {
 004A                   .dbline 142
 004A           ;       int response = 0;               // Initialize the response to a fail.
 004A 560100            mov [X+1],0
 004D 560000            mov [X+0],0
 0050                   .dbline 143
 0050           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0050 5000              mov A,0
 0052 08                push A
 0053 08                push A
 0054 7C0B97            xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 146
 0059           ;       
 0059           ;       // Transmit a hello.
 0059           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TRANSMIT_PutChar
 005F 20                pop X
 0060                   .dbline 147
 0060           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TRANSMIT_PutChar
 0066 20                pop X
 0067                   .dbline 148
 0067           ;       TRANSMIT_PutChar(MASTER_ID);
 0067 10                push X
 0068 5000              mov A,0
 006A 7C0000            xcall _TRANSMIT_PutChar
 006D 20                pop X
 006E                   .dbline 149
 006E           ;       TRANSMIT_PutChar(module_id);
 006E 62D000            mov REG[0xd0],>__r0
 0071 52FC              mov A,[X-4]
 0073 10                push X
 0074 7C0000            xcall _TRANSMIT_PutChar
 0077 20                pop X
 0078                   .dbline 150
 0078           ;       TRANSMIT_PutChar(PING);
 0078 10                push X
 0079 50CB              mov A,-53
 007B 7C0000            xcall _TRANSMIT_PutChar
 007E 20                pop X
 007F                   .dbline 151
 007F           ;       TRANSMIT_PutChar(END_TRANSMIT);
 007F 10                push X
 0080 50FD              mov A,-3
 0082 7C0000            xcall _TRANSMIT_PutChar
 0085 20                pop X
 0086                   .dbline 152
 0086           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0086 10                push X
 0087 50FD              mov A,-3
 0089 7C0000            xcall _TRANSMIT_PutChar
 008C 20                pop X
 008D           L10:
 008D                   .dbline 155
 008D           ;       
 008D           ;       // Wait for the transmission to finish.
 008D           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 008D           L11:
 008D                   .dbline 155
 008D 10                push X
 008E 7C0000            xcall _TRANSMIT_bReadTxStatus
 0091 62D000            mov REG[0xd0],>__r0
 0094 20                pop X
 0095 5300              mov [__r0],A
 0097 470020            tst [__r0],32
 009A AFF2              jz L10
 009C                   .dbline 158
 009C           ;       
 009C           ;       // Wait an additional amount of time to be sure.
 009C           ;       xmitWait();
 009C 7C0E34            xcall _xmitWait
 009F                   .dbline 161
 009F           ; 
 009F           ;       // If we get a valid response, check the extracted parameters for what we want.
 009F           ;       if(validResponse())
 009F 91B1              xcall _validResponse
 00A1 62D000            mov REG[0xd0],>__r0
 00A4 3C0000            cmp [__r0],0
 00A7 B006              jnz X2
 00A9 3C0000            cmp [__r1],0
 00AC A02D              jz L13
 00AE           X2:
 00AE                   .dbline 162
 00AE           ;       {
 00AE                   .dbline 163
 00AE           ;               if(COMMAND_TYPE == PING)
 00AE 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00B1 3C00CB            cmp [_COMMAND_TYPE],-53
 00B4 B025              jnz L15
 00B6                   .dbline 164
 00B6           ;               {
 00B6                   .dbline 166
 00B6           ;                       // If this is for me, check who it was from.
 00B6           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 00B6 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00B9 3C0000            cmp [_COMMAND_DESTINATION],0
 00BC B01D              jnz L17
 00BE                   .dbline 167
 00BE           ;                       {
 00BE                   .dbline 168
 00BE           ;                               if(COMMAND_SOURCE == module_id)
 00BE 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00C1 5100              mov A,[_COMMAND_SOURCE]
 00C3 62D000            mov REG[0xd0],>__r0
 00C6 5300              mov [__r1],A
 00C8 5000              mov A,0
 00CA 3BFB              cmp A,[X-5]
 00CC B00D              jnz L19
 00CE 5100              mov A,[__r1]
 00D0 3BFC              cmp A,[X-4]
 00D2 B007              jnz L19
 00D4           X3:
 00D4                   .dbline 169
 00D4           ;                               {
 00D4                   .dbline 170
 00D4           ;                                       response = 1;
 00D4 560101            mov [X+1],1
 00D7 560000            mov [X+0],0
 00DA                   .dbline 171
 00DA           ;                               }
 00DA           L19:
 00DA                   .dbline 172
 00DA           ;                       }
 00DA           L17:
 00DA                   .dbline 173
 00DA           ;               }
 00DA           L15:
 00DA                   .dbline 174
 00DA           ;       }
 00DA           L13:
 00DA                   .dbline 176
 00DA           ;       
 00DA           ;       return response;
 00DA 62D000            mov REG[0xd0],>__r0
 00DD 5201              mov A,[X+1]
 00DF 5300              mov [__r1],A
 00E1 5200              mov A,[X+0]
 00E3 5300              mov [__r0],A
 00E5                   .dbline -2
 00E5           L9:
 00E5 38FE              add SP,-2
 00E7 20                pop X
 00E8                   .dbline 0 ; func end
 00E8 7F                ret
 00E9                   .dbsym l response 0 I
 00E9                   .dbsym l module_id -5 I
 00E9                   .dbend
 00E9                   .dbfunc e assignID _assignID fI
 00E9           ;        success -> X+0
 00E9           ;    assigned_ID -> X-5
 00E9           _assignID::
 00E9                   .dbline -1
 00E9 10                push X
 00EA 4F                mov X,SP
 00EB 3802              add SP,2
 00ED                   .dbline 180
 00ED           ; }
 00ED           ; 
 00ED           ; int assignID(int assigned_ID)
 00ED           ; {
 00ED                   .dbline 181
 00ED           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 00ED 560100            mov [X+1],0
 00F0 560000            mov [X+0],0
 00F3                   .dbline 182
 00F3           ;       configToggle(TX_MODE);  // Switch to TX mode.
 00F3 5000              mov A,0
 00F5 08                push A
 00F6 08                push A
 00F7 7C0B97            xcall _configToggle
 00FA 38FE              add SP,-2
 00FC                   .dbline 185
 00FC           ;       
 00FC           ;       // Transmit the assignment.
 00FC           ;       TRANSMIT_PutChar(START_TRANSMIT);
 00FC 10                push X
 00FD 50FC              mov A,-4
 00FF 7C0000            xcall _TRANSMIT_PutChar
 0102 20                pop X
 0103                   .dbline 186
 0103           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0103 10                push X
 0104 50FC              mov A,-4
 0106 7C0000            xcall _TRANSMIT_PutChar
 0109 20                pop X
 010A                   .dbline 187
 010A           ;       TRANSMIT_PutChar(MASTER_ID);
 010A 10                push X
 010B 5000              mov A,0
 010D 7C0000            xcall _TRANSMIT_PutChar
 0110 20                pop X
 0111                   .dbline 188
 0111           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0111 10                push X
 0112 50FB              mov A,-5
 0114 7C0000            xcall _TRANSMIT_PutChar
 0117 20                pop X
 0118                   .dbline 189
 0118           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0118 10                push X
 0119 50C9              mov A,-55
 011B 7C0000            xcall _TRANSMIT_PutChar
 011E 20                pop X
 011F                   .dbline 190
 011F           ;       TRANSMIT_PutChar(assigned_ID);
 011F 62D000            mov REG[0xd0],>__r0
 0122 52FC              mov A,[X-4]
 0124 10                push X
 0125 7C0000            xcall _TRANSMIT_PutChar
 0128 20                pop X
 0129                   .dbline 191
 0129           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0129 10                push X
 012A 50FD              mov A,-3
 012C 7C0000            xcall _TRANSMIT_PutChar
 012F 20                pop X
 0130                   .dbline 192
 0130           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0130 10                push X
 0131 50FD              mov A,-3
 0133 7C0000            xcall _TRANSMIT_PutChar
 0136 20                pop X
 0137           L22:
 0137                   .dbline 195
 0137           ;       
 0137           ;       // Wait for the transmission to finish.
 0137           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0137           L23:
 0137                   .dbline 195
 0137 10                push X
 0138 7C0000            xcall _TRANSMIT_bReadTxStatus
 013B 62D000            mov REG[0xd0],>__r0
 013E 20                pop X
 013F 5300              mov [__r0],A
 0141 470020            tst [__r0],32
 0144 AFF2              jz L22
 0146                   .dbline 198
 0146           ;       
 0146           ;       // Wait an additional amount of time to make sure the xmit gets out.
 0146           ;       xmitWait();
 0146 7C0E34            xcall _xmitWait
 0149                   .dbline 201
 0149           ;       
 0149           ;       // If we read a valid response, check the extracted parameters for what we want.
 0149           ;       if(validResponse())
 0149 9107              xcall _validResponse
 014B 62D000            mov REG[0xd0],>__r0
 014E 3C0000            cmp [__r0],0
 0151 B006              jnz X4
 0153 3C0000            cmp [__r1],0
 0156 A02D              jz L25
 0158           X4:
 0158                   .dbline 202
 0158           ;       {
 0158                   .dbline 203
 0158           ;               if(COMMAND_TYPE == ID_ASSIGN_OK)
 0158 62D000            mov REG[0xd0],>_COMMAND_TYPE
 015B 3C00CA            cmp [_COMMAND_TYPE],-54
 015E B025              jnz L27
 0160                   .dbline 204
 0160           ;               {
 0160                   .dbline 206
 0160           ;                       // If this is for me, check who it was from.
 0160           ;                       if(COMMAND_DESTINATION == MASTER_ID)
 0160 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0163 3C0000            cmp [_COMMAND_DESTINATION],0
 0166 B01D              jnz L29
 0168                   .dbline 207
 0168           ;                       {
 0168                   .dbline 208
 0168           ;                               if(COMMAND_SOURCE == assigned_ID)
 0168 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 016B 5100              mov A,[_COMMAND_SOURCE]
 016D 62D000            mov REG[0xd0],>__r0
 0170 5300              mov [__r1],A
 0172 5000              mov A,0
 0174 3BFB              cmp A,[X-5]
 0176 B00D              jnz L31
 0178 5100              mov A,[__r1]
 017A 3BFC              cmp A,[X-4]
 017C B007              jnz L31
 017E           X5:
 017E                   .dbline 209
 017E           ;                               {
 017E                   .dbline 210
 017E           ;                                       success = 1;
 017E 560101            mov [X+1],1
 0181 560000            mov [X+0],0
 0184                   .dbline 211
 0184           ;                               }
 0184           L31:
 0184                   .dbline 212
 0184           ;                       }
 0184           L29:
 0184                   .dbline 213
 0184           ;               }
 0184           L27:
 0184                   .dbline 214
 0184           ;       }
 0184           L25:
 0184                   .dbline 216
 0184           ;       
 0184           ;       return success;
 0184 62D000            mov REG[0xd0],>__r0
 0187 5201              mov A,[X+1]
 0189 5300              mov [__r1],A
 018B 5200              mov A,[X+0]
 018D 5300              mov [__r0],A
 018F                   .dbline -2
 018F           L21:
 018F 38FE              add SP,-2
 0191 20                pop X
 0192                   .dbline 0 ; func end
 0192 7F                ret
 0193                   .dbsym l success 0 I
 0193                   .dbsym l assigned_ID -5 I
 0193                   .dbend
 0193                   .dbfunc e clearConfig _clearConfig fV
 0193           _clearConfig::
 0193                   .dbline -1
 0193                   .dbline 220
 0193           ; }
 0193           ; 
 0193           ; void clearConfig(void)
 0193           ; {
 0193                   .dbline 221
 0193           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0193 5000              mov A,0
 0195 08                push A
 0196 08                push A
 0197 7C0B97            xcall _configToggle
 019A 38FE              add SP,-2
 019C                   .dbline 224
 019C           ;       
 019C           ;       // Transmit a clear.
 019C           ;       TRANSMIT_PutChar(START_TRANSMIT);
 019C 10                push X
 019D 50FC              mov A,-4
 019F 7C0000            xcall _TRANSMIT_PutChar
 01A2 20                pop X
 01A3                   .dbline 225
 01A3           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01A3 10                push X
 01A4 50FC              mov A,-4
 01A6 7C0000            xcall _TRANSMIT_PutChar
 01A9 20                pop X
 01AA                   .dbline 226
 01AA           ;       TRANSMIT_PutChar(MASTER_ID);
 01AA 10                push X
 01AB 5000              mov A,0
 01AD 7C0000            xcall _TRANSMIT_PutChar
 01B0 20                pop X
 01B1                   .dbline 227
 01B1           ;       TRANSMIT_PutChar(BROADCAST);
 01B1 10                push X
 01B2 50FE              mov A,-2
 01B4 7C0000            xcall _TRANSMIT_PutChar
 01B7 20                pop X
 01B8                   .dbline 228
 01B8           ;       TRANSMIT_PutChar(CLEAR);
 01B8 10                push X
 01B9 50CC              mov A,-52
 01BB 7C0000            xcall _TRANSMIT_PutChar
 01BE 20                pop X
 01BF                   .dbline 229
 01BF           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01BF 10                push X
 01C0 50FD              mov A,-3
 01C2 7C0000            xcall _TRANSMIT_PutChar
 01C5 20                pop X
 01C6                   .dbline 230
 01C6           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01C6 10                push X
 01C7 50FD              mov A,-3
 01C9 7C0000            xcall _TRANSMIT_PutChar
 01CC 20                pop X
 01CD           L34:
 01CD                   .dbline 233
 01CD           ;       
 01CD           ;       // Wait for the transmission to finish.
 01CD           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01CD           L35:
 01CD                   .dbline 233
 01CD 10                push X
 01CE 7C0000            xcall _TRANSMIT_bReadTxStatus
 01D1 62D000            mov REG[0xd0],>__r0
 01D4 20                pop X
 01D5 5300              mov [__r0],A
 01D7 470020            tst [__r0],32
 01DA AFF2              jz L34
 01DC                   .dbline 236
 01DC           ;       
 01DC           ;       // Wait an additional amount of time to make sure that our xmit got out.
 01DC           ;       xmitWait();
 01DC 7C0E34            xcall _xmitWait
 01DF                   .dbline 239
 01DF           ;       
 01DF           ;       // Wait for servo find time to allow the children to reset.
 01DF           ;       configToggle(RX_MODE);
 01DF 5000              mov A,0
 01E1 08                push A
 01E2 5001              mov A,1
 01E4 08                push A
 01E5 7C0B97            xcall _configToggle
 01E8 38FE              add SP,-2
 01EA           L37:
 01EA                   .dbline 240
 01EA           ;       while(TIMEOUT < SERVO_FIND_TIME) { }
 01EA                   .dbline 240
 01EA           L38:
 01EA                   .dbline 240
 01EA 62D000            mov REG[0xd0],>_TIMEOUT
 01ED 5101              mov A,[_TIMEOUT+1]
 01EF 1118              sub A,24
 01F1 5100              mov A,[_TIMEOUT]
 01F3 3180              xor A,-128
 01F5 1980              sbb A,(0 ^ 0x80)
 01F7 CFF2              jc L37
 01F9           X6:
 01F9                   .dbline -2
 01F9           L33:
 01F9                   .dbline 0 ; func end
 01F9 7F                ret
 01FA                   .dbend
 01FA                   .dbfunc e sayHello _sayHello fV
 01FA           _sayHello::
 01FA                   .dbline -1
 01FA                   .dbline 245
 01FA           ; }
 01FA           ; 
 01FA           ; // This function transmits a hello message.
 01FA           ; void sayHello(void)
 01FA           ; {
 01FA                   .dbline 246
 01FA           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 01FA 5000              mov A,0
 01FC 08                push A
 01FD 08                push A
 01FE 7C0B97            xcall _configToggle
 0201 38FE              add SP,-2
 0203                   .dbline 249
 0203           ;       
 0203           ;       // Transmit a hello.
 0203           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0203 10                push X
 0204 50FC              mov A,-4
 0206 7C0000            xcall _TRANSMIT_PutChar
 0209 20                pop X
 020A                   .dbline 250
 020A           ;       TRANSMIT_PutChar(START_TRANSMIT);
 020A 10                push X
 020B 50FC              mov A,-4
 020D 7C0000            xcall _TRANSMIT_PutChar
 0210 20                pop X
 0211                   .dbline 251
 0211           ;       TRANSMIT_PutChar(MASTER_ID);
 0211 10                push X
 0212 5000              mov A,0
 0214 7C0000            xcall _TRANSMIT_PutChar
 0217 20                pop X
 0218                   .dbline 252
 0218           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0218 10                push X
 0219 50FB              mov A,-5
 021B 7C0000            xcall _TRANSMIT_PutChar
 021E 20                pop X
 021F                   .dbline 253
 021F           ;       TRANSMIT_PutChar(HELLO_BYTE);
 021F 10                push X
 0220 50C8              mov A,-56
 0222 7C0000            xcall _TRANSMIT_PutChar
 0225 20                pop X
 0226                   .dbline 254
 0226           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0226 10                push X
 0227 50FD              mov A,-3
 0229 7C0000            xcall _TRANSMIT_PutChar
 022C 20                pop X
 022D                   .dbline 255
 022D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 022D 10                push X
 022E 50FD              mov A,-3
 0230 7C0000            xcall _TRANSMIT_PutChar
 0233 20                pop X
 0234           L41:
 0234                   .dbline 258
 0234           ;       
 0234           ;       // Wait for the transmission to finish.
 0234           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0234           L42:
 0234                   .dbline 258
 0234 10                push X
 0235 7C0000            xcall _TRANSMIT_bReadTxStatus
 0238 62D000            mov REG[0xd0],>__r0
 023B 20                pop X
 023C 5300              mov [__r0],A
 023E 470020            tst [__r0],32
 0241 AFF2              jz L41
 0243                   .dbline 261
 0243           ;       
 0243           ;       // Wait an additional amount of time to allow the xmit to get out.
 0243           ;       xmitWait();
 0243 7C0E34            xcall _xmitWait
 0246                   .dbline 264
 0246           ;       
 0246           ;       // Listen for the response.
 0246           ;       configToggle(RX_MODE);
 0246 5000              mov A,0
 0248 08                push A
 0249 5001              mov A,1
 024B 08                push A
 024C 7C0B97            xcall _configToggle
 024F 38FE              add SP,-2
 0251                   .dbline -2
 0251           L40:
 0251                   .dbline 0 ; func end
 0251 7F                ret
 0252                   .dbend
 0252                   .dbfunc e validResponse _validResponse fI
 0252           ; valid_transmit -> X+3
 0252           ;              i -> X+1
 0252           ;       tempByte -> X+0
 0252           _validResponse::
 0252                   .dbline -1
 0252 10                push X
 0253 4F                mov X,SP
 0254 3805              add SP,5
 0256                   .dbline 269
 0256           ; }
 0256           ; 
 0256           ; // This function returns whether or not a valid transmission has been received.
 0256           ; int validResponse(void)
 0256           ; {
 0256                   .dbline 270
 0256           ;       int valid_transmit = 0;
 0256 560400            mov [X+4],0
 0259 560300            mov [X+3],0
 025C                   .dbline 271
 025C           ;       int i = 0;
 025C 560200            mov [X+2],0
 025F 560100            mov [X+1],0
 0262                   .dbline 272
 0262           ;       char tempByte = 0;
 0262 560000            mov [X+0],0
 0265                   .dbline 274
 0265           ;       
 0265           ;       configToggle(RX_MODE);  // Listen for the response.
 0265 5000              mov A,0
 0267 08                push A
 0268 5001              mov A,1
 026A 08                push A
 026B 7C0B97            xcall _configToggle
 026E 38FE              add SP,-2
 0270 80C2              xjmp L46
 0272           L45:
 0272                   .dbline 281
 0272           ;       
 0272           ;       // The following code looks very nasty. Basically, while we haven't hit the rx timeout,
 0272           ;       // it checks the buffer for a command with non-blocking read commands. When the next byte
 0272           ;       // is found, we enter another while loop to read for the next byte and so on. We do this
 0272           ;       // so that the parent doesn't get stuck in rx mode when a child doesn't respond.
 0272           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0272           ;       {
 0272                   .dbline 282
 0272           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0272 10                push X
 0273 7C0000            xcall _RECEIVE_cReadChar
 0276 62D000            mov REG[0xd0],>__r0
 0279 20                pop X
 027A 39FC              cmp A,-4
 027C B0B6              jnz L48
 027E                   .dbline 283
 027E           ;               {
 027E 80A5              xjmp L51
 0280           L50:
 0280                   .dbline 285
 0280           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0280           ;                       {
 0280                   .dbline 286
 0280           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0280 10                push X
 0281 7C0000            xcall _RECEIVE_cReadChar
 0284 62D000            mov REG[0xd0],>__r0
 0287 20                pop X
 0288 39FC              cmp A,-4
 028A B099              jnz L53
 028C                   .dbline 287
 028C           ;                               {
 028C 8088              xjmp L56
 028E           L55:
 028E                   .dbline 289
 028E           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 028E           ;                                       {
 028E                   .dbline 290
 028E           ;                                               if(tempByte = RECEIVE_cReadChar())
 028E 10                push X
 028F 7C0000            xcall _RECEIVE_cReadChar
 0292 20                pop X
 0293 5400              mov [X+0],A
 0295 3900              cmp A,0
 0297 A07D              jz L58
 0299                   .dbline 291
 0299           ;                                               {
 0299                   .dbline 292
 0299           ;                                                       COMMAND_SOURCE = tempByte;
 0299 5200              mov A,[X+0]
 029B 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 029E 5300              mov [_COMMAND_SOURCE],A
 02A0 8065              xjmp L61
 02A2           L60:
 02A2                   .dbline 295
 02A2           ;                                                       
 02A2           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02A2           ;                                                       {
 02A2                   .dbline 296
 02A2           ;                                                               if(tempByte = RECEIVE_cReadChar())
 02A2 10                push X
 02A3 7C0000            xcall _RECEIVE_cReadChar
 02A6 62D000            mov REG[0xd0],>__r0
 02A9 20                pop X
 02AA 5400              mov [X+0],A
 02AC 3900              cmp A,0
 02AE A057              jz L63
 02B0                   .dbline 297
 02B0           ;                                                               {
 02B0                   .dbline 298
 02B0           ;                                                                       if(tempByte >= HELLO_BYTE)
 02B0 3D00C8            cmp [X+0],-56
 02B3 C052              jc L65
 02B5           X7:
 02B5                   .dbline 299
 02B5           ;                                                                       {
 02B5                   .dbline 300
 02B5           ;                                                                               COMMAND_TYPE = tempByte;
 02B5 5200              mov A,[X+0]
 02B7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02BA 5300              mov [_COMMAND_TYPE],A
 02BC 803A              xjmp L68
 02BE           L67:
 02BE                   .dbline 303
 02BE           ;                                                                               
 02BE           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 02BE           ;                                                                               {
 02BE                   .dbline 304
 02BE           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 02BE 10                push X
 02BF 7C0000            xcall _RECEIVE_cReadChar
 02C2 62D000            mov REG[0xd0],>__r0
 02C5 20                pop X
 02C6 5400              mov [X+0],A
 02C8 3900              cmp A,0
 02CA A02C              jz L70
 02CC                   .dbline 305
 02CC           ;                                                                                       {
 02CC                   .dbline 306
 02CC           ;                                                                                               if(tempByte != END_TRANSMIT)
 02CC 3D00FD            cmp [X+0],-3
 02CF A018              jz L72
 02D1                   .dbline 307
 02D1           ;                                                                                               {
 02D1                   .dbline 308
 02D1           ;                                                                                                       PARAM[i] = tempByte;
 02D1 5202              mov A,[X+2]
 02D3 0100              add A,<_PARAM
 02D5 5300              mov [__r1],A
 02D7 5201              mov A,[X+1]
 02D9 0900              adc A,>_PARAM
 02DB 60D5              mov REG[0xd5],A
 02DD 5200              mov A,[X+0]
 02DF 3F00              mvi [__r1],A
 02E1                   .dbline 309
 02E1           ;                                                                                                       i++;
 02E1 7702              inc [X+2]
 02E3 0F0100            adc [X+1],0
 02E6                   .dbline 310
 02E6           ;                                                                                               }
 02E6 8010              xjmp L73
 02E8           L72:
 02E8                   .dbline 312
 02E8           ;                                                                                               else
 02E8           ;                                                                                               {
 02E8                   .dbline 313
 02E8           ;                                                                                                       valid_transmit = 1;
 02E8 560401            mov [X+4],1
 02EB 560300            mov [X+3],0
 02EE                   .dbline 314
 02EE           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 02EE 62D000            mov REG[0xd0],>_TIMEOUT
 02F1 550103            mov [_TIMEOUT+1],3
 02F4 550000            mov [_TIMEOUT],0
 02F7                   .dbline 315
 02F7           ;                                                                                               }
 02F7           L73:
 02F7                   .dbline 316
 02F7           ;                                                                                       }
 02F7           L70:
 02F7                   .dbline 317
 02F7           ;                                                                               }
 02F7           L68:
 02F7                   .dbline 302
 02F7 62D000            mov REG[0xd0],>_TIMEOUT
 02FA 5101              mov A,[_TIMEOUT+1]
 02FC 1103              sub A,3
 02FE 5100              mov A,[_TIMEOUT]
 0300 3180              xor A,-128
 0302 1980              sbb A,(0 ^ 0x80)
 0304 CFB9              jc L67
 0306           X8:
 0306                   .dbline 318
 0306           ;                                                                       }
 0306           L65:
 0306                   .dbline 319
 0306           ;                                                               }
 0306           L63:
 0306                   .dbline 320
 0306           ;                                                       }
 0306           L61:
 0306                   .dbline 294
 0306 62D000            mov REG[0xd0],>_TIMEOUT
 0309 5101              mov A,[_TIMEOUT+1]
 030B 1103              sub A,3
 030D 5100              mov A,[_TIMEOUT]
 030F 3180              xor A,-128
 0311 1980              sbb A,(0 ^ 0x80)
 0313 CF8E              jc L60
 0315           X9:
 0315                   .dbline 321
 0315           ;                                               }
 0315           L58:
 0315                   .dbline 322
 0315           ;                                       }
 0315           L56:
 0315                   .dbline 288
 0315 62D000            mov REG[0xd0],>_TIMEOUT
 0318 5101              mov A,[_TIMEOUT+1]
 031A 1103              sub A,3
 031C 5100              mov A,[_TIMEOUT]
 031E 3180              xor A,-128
 0320 1980              sbb A,(0 ^ 0x80)
 0322 CF6B              jc L55
 0324           X10:
 0324                   .dbline 323
 0324           ;                               }
 0324           L53:
 0324                   .dbline 324
 0324           ;                       }
 0324           L51:
 0324                   .dbline 284
 0324 62D000            mov REG[0xd0],>_TIMEOUT
 0327 5101              mov A,[_TIMEOUT+1]
 0329 1103              sub A,3
 032B 5100              mov A,[_TIMEOUT]
 032D 3180              xor A,-128
 032F 1980              sbb A,(0 ^ 0x80)
 0331 CF4E              jc L50
 0333           X11:
 0333                   .dbline 325
 0333           ;               }
 0333           L48:
 0333                   .dbline 326
 0333           ;       }
 0333           L46:
 0333                   .dbline 280
 0333 62D000            mov REG[0xd0],>_TIMEOUT
 0336 5101              mov A,[_TIMEOUT+1]
 0338 1103              sub A,3
 033A 5100              mov A,[_TIMEOUT]
 033C 3180              xor A,-128
 033E 1980              sbb A,(0 ^ 0x80)
 0340 CF31              jc L45
 0342           X12:
 0342                   .dbline 328
 0342           ;       
 0342           ;       RX_TIMEOUT_Stop();
 0342 10                push X
 0343 7C0000            xcall _RX_TIMEOUT_Stop
 0346 20                pop X
 0347                   .dbline 329
 0347           ;       TIMEOUT = 0;
 0347 62D000            mov REG[0xd0],>_TIMEOUT
 034A 550100            mov [_TIMEOUT+1],0
 034D 550000            mov [_TIMEOUT],0
 0350                   .dbline 331
 0350           ;       
 0350           ;       return valid_transmit;
 0350 62D000            mov REG[0xd0],>__r0
 0353 5204              mov A,[X+4]
 0355 5300              mov [__r1],A
 0357 5203              mov A,[X+3]
 0359 5300              mov [__r0],A
 035B                   .dbline -2
 035B           L44:
 035B 38FB              add SP,-5
 035D 20                pop X
 035E                   .dbline 0 ; func end
 035E 7F                ret
 035F                   .dbsym l valid_transmit 3 I
 035F                   .dbsym l i 1 I
 035F                   .dbsym l tempByte 0 c
 035F                   .dbend
 035F                   .dbfunc e decodeTransmission _decodeTransmission fV
 035F           ;          speed -> X+10
 035F           ;          angle -> X+8
 035F           ;       tempByte -> X+7
 035F           ;          total -> X+5
 035F           ;             ID -> X+4
 035F           ;   runningTotal -> X+2
 035F           ;          param -> X+0
 035F           _decodeTransmission::
 035F                   .dbline -1
 035F 10                push X
 0360 4F                mov X,SP
 0361 380C              add SP,12
 0363                   .dbline 336
 0363           ; }
 0363           ; 
 0363           ; // This function decodes the transmission and takes the correct action.
 0363           ; void decodeTransmission(void)
 0363           ; {
 0363                   .dbline 338
 0363           ;       char* param;
 0363           ;       char ID = 0;
 0363 560400            mov [X+4],0
 0366                   .dbline 342
 0366           ;       char tempByte;
 0366           ;       char angle[2];
 0366           ;       char speed[2];
 0366           ;       int total = 0;
 0366 560600            mov [X+6],0
 0369 560500            mov [X+5],0
 036C                   .dbline 343
 036C           ;       int runningTotal = 0;
 036C 560300            mov [X+3],0
 036F 560200            mov [X+2],0
 0372                   .dbline 345
 0372           ;       
 0372           ;       if(param = COMP_SERIAL_szGetParam())
 0372 10                push X
 0373 7C0000            xcall _COMP_SERIAL_szGetParam
 0376 62D000            mov REG[0xd0],>__r0
 0379 5300              mov [__r0],A
 037B 5A00              mov [__r1],X
 037D 20                pop X
 037E 5100              mov A,[__r1]
 0380 5401              mov [X+1],A
 0382 5100              mov A,[__r0]
 0384 5400              mov [X+0],A
 0386 3C0000            cmp [__r0],0
 0389 B006              jnz X13
 038B 3C0000            cmp [__r1],0
 038E A689              jz L75
 0390           X13:
 0390                   .dbline 346
 0390           ;       {
 0390                   .dbline 347
 0390           ;               if((param[0] == 'x') || (param[0] == 'X'))
 0390 62D000            mov REG[0xd0],>__r0
 0393 5201              mov A,[X+1]
 0395 5300              mov [__r1],A
 0397 5200              mov A,[X+0]
 0399 60D4              mov REG[0xd4],A
 039B 3E00              mvi A,[__r1]
 039D 5300              mov [__r1],A
 039F 550000            mov [__r0],0
 03A2 3C0000            cmp [__r0],0
 03A5 B005              jnz X14
 03A7 3978              cmp A,120
 03A9 A00E              jz L79
 03AB           X14:
 03AB 62D000            mov REG[0xd0],>__r0
 03AE 3C0000            cmp [__r0],0
 03B1 B099              jnz L77
 03B3 3C0058            cmp [__r1],88
 03B6 B094              jnz L77
 03B8           X15:
 03B8           L79:
 03B8                   .dbline 348
 03B8           ;               {
 03B8                   .dbline 350
 03B8           ;                       // Reset the arm.
 03B8           ;                       NUM_MODULES = 0;
 03B8 62D000            mov REG[0xd0],>_NUM_MODULES
 03BB 550100            mov [_NUM_MODULES+1],0
 03BE 550000            mov [_NUM_MODULES],0
 03C1                   .dbline 351
 03C1           ;                       if(param = COMP_SERIAL_szGetParam())
 03C1 10                push X
 03C2 7C0000            xcall _COMP_SERIAL_szGetParam
 03C5 62D000            mov REG[0xd0],>__r0
 03C8 5300              mov [__r0],A
 03CA 5A00              mov [__r1],X
 03CC 20                pop X
 03CD 5100              mov A,[__r1]
 03CF 5401              mov [X+1],A
 03D1 5100              mov A,[__r0]
 03D3 5400              mov [X+0],A
 03D5 3C0000            cmp [__r0],0
 03D8 B006              jnz X16
 03DA 3C0000            cmp [__r1],0
 03DD A059              jz L80
 03DF           X16:
 03DF                   .dbline 352
 03DF           ;                       {
 03DF                   .dbline 353
 03DF           ;                               if((param[0] >= '1') && (param[0] <= '9'))
 03DF 62D000            mov REG[0xd0],>__r0
 03E2 5201              mov A,[X+1]
 03E4 5300              mov [__r1],A
 03E6 5200              mov A,[X+0]
 03E8 60D4              mov REG[0xd4],A
 03EA 3E00              mvi A,[__r1]
 03EC 5300              mov [__r1],A
 03EE 550000            mov [__r0],0
 03F1 1131              sub A,49
 03F3 5000              mov A,0
 03F5 3180              xor A,-128
 03F7 1980              sbb A,(0 ^ 0x80)
 03F9 C61E              jc L78
 03FB           X17:
 03FB 62D000            mov REG[0xd0],>__r0
 03FE 5039              mov A,57
 0400 1200              sub A,[__r1]
 0402 5100              mov A,[__r0]
 0404 3180              xor A,-128
 0406 5300              mov [__rX],A
 0408 5080              mov A,(0 ^ 0x80)
 040A 1A00              sbb A,[__rX]
 040C C60B              jc L78
 040E           X18:
 040E                   .dbline 354
 040E           ;                               {
 040E                   .dbline 355
 040E           ;                                       PREV_NUM_MODULES = param[0] - 48;
 040E 62D000            mov REG[0xd0],>__r0
 0411 5201              mov A,[X+1]
 0413 5300              mov [__r1],A
 0415 5200              mov A,[X+0]
 0417 60D4              mov REG[0xd4],A
 0419 3E00              mvi A,[__r1]
 041B 1130              sub A,48
 041D 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0420 5301              mov [_PREV_NUM_MODULES+1],A
 0422 5000              mov A,0
 0424 1900              sbb A,0
 0426 5300              mov [_PREV_NUM_MODULES],A
 0428                   .dbline 356
 0428           ;                                       SUGGESTED_NUM_MODULES = PREV_NUM_MODULES;
 0428 5101              mov A,[_PREV_NUM_MODULES+1]
 042A 08                push A
 042B 5100              mov A,[_PREV_NUM_MODULES]
 042D 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0430 5300              mov [_SUGGESTED_NUM_MODULES],A
 0432 18                pop A
 0433 5301              mov [_SUGGESTED_NUM_MODULES+1],A
 0435                   .dbline 357
 0435           ;                               }
 0435                   .dbline 358
 0435           ;                       }
 0435 85E2              xjmp L78
 0437           L80:
 0437                   .dbline 360
 0437           ;                       else
 0437           ;                       {
 0437                   .dbline 361
 0437           ;                               PREV_NUM_MODULES = 1;
 0437 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 043A 550101            mov [_PREV_NUM_MODULES+1],1
 043D 550000            mov [_PREV_NUM_MODULES],0
 0440                   .dbline 362
 0440           ;                               SUGGESTED_NUM_MODULES = MAX_MODULES;
 0440 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0443 550109            mov [_SUGGESTED_NUM_MODULES+1],9
 0446 550000            mov [_SUGGESTED_NUM_MODULES],0
 0449                   .dbline 363
 0449           ;                       }
 0449                   .dbline 364
 0449           ;               }
 0449 85CE              xjmp L78
 044B           L77:
 044B                   .dbline 365
 044B           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 044B 62D000            mov REG[0xd0],>__r0
 044E 5201              mov A,[X+1]
 0450 5300              mov [__r1],A
 0452 5200              mov A,[X+0]
 0454 60D4              mov REG[0xd4],A
 0456 3E00              mvi A,[__r1]
 0458 5300              mov [__r1],A
 045A 550000            mov [__r0],0
 045D 3C0000            cmp [__r0],0
 0460 B005              jnz X19
 0462 396E              cmp A,110
 0464 A00E              jz L86
 0466           X19:
 0466 62D000            mov REG[0xd0],>__r0
 0469 3C0000            cmp [__r0],0
 046C B035              jnz L84
 046E 3C004E            cmp [__r1],78
 0471 B030              jnz L84
 0473           X20:
 0473           L86:
 0473                   .dbline 366
 0473           ;               {
 0473                   .dbline 368
 0473           ;                       // Return the number of modules that we have found.
 0473           ;                       itoa(param,NUM_MODULES,10);
 0473 5000              mov A,0
 0475 08                push A
 0476 500A              mov A,10
 0478 08                push A
 0479 62D000            mov REG[0xd0],>_NUM_MODULES
 047C 5100              mov A,[_NUM_MODULES]
 047E 08                push A
 047F 5101              mov A,[_NUM_MODULES+1]
 0481 08                push A
 0482 5200              mov A,[X+0]
 0484 08                push A
 0485 5201              mov A,[X+1]
 0487 08                push A
 0488 7C0000            xcall _itoa
 048B 38FA              add SP,-6
 048D                   .dbline 369
 048D           ;                       COMP_SERIAL_PutString(param);
 048D 10                push X
 048E 5200              mov A,[X+0]
 0490 08                push A
 0491 5201              mov A,[X+1]
 0493 5C                mov X,A
 0494 18                pop A
 0495 7C0000            xcall _COMP_SERIAL_PutString
 0498 20                pop X
 0499                   .dbline 370
 0499           ;                       COMP_SERIAL_PutChar('\n');
 0499 10                push X
 049A 500A              mov A,10
 049C 7C0000            xcall _COMP_SERIAL_PutChar
 049F 20                pop X
 04A0                   .dbline 371
 04A0           ;               }
 04A0 8577              xjmp L85
 04A2           L84:
 04A2                   .dbline 372
 04A2           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04A2 62D000            mov REG[0xd0],>__r0
 04A5 5201              mov A,[X+1]
 04A7 5300              mov [__r1],A
 04A9 5200              mov A,[X+0]
 04AB 60D4              mov REG[0xd4],A
 04AD 3E00              mvi A,[__r1]
 04AF 5300              mov [__r1],A
 04B1 550000            mov [__r0],0
 04B4 3C0000            cmp [__r0],0
 04B7 B005              jnz X21
 04B9 3977              cmp A,119
 04BB A00E              jz L89
 04BD           X21:
 04BD 62D000            mov REG[0xd0],>__r0
 04C0 3C0000            cmp [__r0],0
 04C3 B214              jnz L87
 04C5 3C0057            cmp [__r1],87
 04C8 B20F              jnz L87
 04CA           X22:
 04CA           L89:
 04CA                   .dbline 373
 04CA           ;               {
 04CA                   .dbline 374
 04CA           ;                       if(param = COMP_SERIAL_szGetParam())
 04CA 10                push X
 04CB 7C0000            xcall _COMP_SERIAL_szGetParam
 04CE 62D000            mov REG[0xd0],>__r0
 04D1 5300              mov [__r0],A
 04D3 5A00              mov [__r1],X
 04D5 20                pop X
 04D6 5100              mov A,[__r1]
 04D8 5401              mov [X+1],A
 04DA 5100              mov A,[__r0]
 04DC 5400              mov [X+0],A
 04DE 3C0000            cmp [__r0],0
 04E1 B006              jnz X23
 04E3 3C0000            cmp [__r1],0
 04E6 A531              jz L88
 04E8           X23:
 04E8                   .dbline 375
 04E8           ;                       {
 04E8                   .dbline 376
 04E8           ;                               ID = atoi(param);
 04E8 5200              mov A,[X+0]
 04EA 08                push A
 04EB 5201              mov A,[X+1]
 04ED 08                push A
 04EE 7C0000            xcall _atoi
 04F1 38FE              add SP,-2
 04F3 62D000            mov REG[0xd0],>__r0
 04F6 5100              mov A,[__r1]
 04F8 5404              mov [X+4],A
 04FA                   .dbline 378
 04FA           ;                               
 04FA           ;                               if(param = COMP_SERIAL_szGetParam())
 04FA 10                push X
 04FB 7C0000            xcall _COMP_SERIAL_szGetParam
 04FE 62D000            mov REG[0xd0],>__r0
 0501 5300              mov [__r0],A
 0503 5A00              mov [__r1],X
 0505 20                pop X
 0506 5100              mov A,[__r1]
 0508 5401              mov [X+1],A
 050A 5100              mov A,[__r0]
 050C 5400              mov [X+0],A
 050E 3C0000            cmp [__r0],0
 0511 B006              jnz X24
 0513 3C0000            cmp [__r1],0
 0516 A501              jz L88
 0518           X24:
 0518                   .dbline 379
 0518           ;                               {
 0518                   .dbline 380
 0518           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0518 62D000            mov REG[0xd0],>__r0
 051B 5201              mov A,[X+1]
 051D 5300              mov [__r1],A
 051F 5200              mov A,[X+0]
 0521 60D4              mov REG[0xd4],A
 0523 3E00              mvi A,[__r1]
 0525 5300              mov [__r1],A
 0527 550000            mov [__r0],0
 052A 3C0000            cmp [__r0],0
 052D B005              jnz X25
 052F 3961              cmp A,97
 0531 A00E              jz L96
 0533           X25:
 0533 62D000            mov REG[0xd0],>__r0
 0536 3C0000            cmp [__r0],0
 0539 B084              jnz L94
 053B 3C0041            cmp [__r1],65
 053E B07F              jnz L94
 0540           X26:
 0540           L96:
 0540                   .dbline 381
 0540           ;                                       {
 0540                   .dbline 382
 0540           ;                                               if(param = COMP_SERIAL_szGetParam())
 0540 10                push X
 0541 7C0000            xcall _COMP_SERIAL_szGetParam
 0544 62D000            mov REG[0xd0],>__r0
 0547 5300              mov [__r0],A
 0549 5A00              mov [__r1],X
 054B 20                pop X
 054C 5100              mov A,[__r1]
 054E 5401              mov [X+1],A
 0550 5100              mov A,[__r0]
 0552 5400              mov [X+0],A
 0554 3C0000            cmp [__r0],0
 0557 B006              jnz X27
 0559 3C0000            cmp [__r1],0
 055C A4BB              jz L88
 055E           X27:
 055E                   .dbline 383
 055E           ;                                               {
 055E                   .dbline 385
 055E           ;                                                       // Write the desired angle to the servo.
 055E           ;                                                       total = atoi(param);
 055E 5200              mov A,[X+0]
 0560 08                push A
 0561 5201              mov A,[X+1]
 0563 08                push A
 0564 7C0000            xcall _atoi
 0567 38FE              add SP,-2
 0569 62D000            mov REG[0xd0],>__r0
 056C 5100              mov A,[__r1]
 056E 5406              mov [X+6],A
 0570 5100              mov A,[__r0]
 0572 5405              mov [X+5],A
 0574                   .dbline 386
 0574           ;                                                       angle[0] = total%256;
 0574 5001              mov A,1
 0576 08                push A
 0577 5000              mov A,0
 0579 08                push A
 057A 5205              mov A,[X+5]
 057C 08                push A
 057D 5206              mov A,[X+6]
 057F 08                push A
 0580 7C0000            xcall __divmod_16X16_16
 0583 38FE              add SP,-2
 0585 18                pop A
 0586 5300              mov [__r1],A
 0588 18                pop A
 0589 5100              mov A,[__r1]
 058B 5408              mov [X+8],A
 058D                   .dbline 387
 058D           ;                                                       angle[1] = total/256;
 058D 5001              mov A,1
 058F 08                push A
 0590 5000              mov A,0
 0592 08                push A
 0593 5205              mov A,[X+5]
 0595 08                push A
 0596 5206              mov A,[X+6]
 0598 08                push A
 0599 7C0000            xcall __divmod_16X16_16
 059C 18                pop A
 059D 5300              mov [__r1],A
 059F 18                pop A
 05A0 38FE              add SP,-2
 05A2 5100              mov A,[__r1]
 05A4 5409              mov [X+9],A
 05A6                   .dbline 388
 05A6           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05A6 5209              mov A,[X+9]
 05A8 08                push A
 05A9 5208              mov A,[X+8]
 05AB 08                push A
 05AC 501E              mov A,30
 05AE 08                push A
 05AF 5003              mov A,3
 05B1 08                push A
 05B2 5005              mov A,5
 05B4 08                push A
 05B5 5204              mov A,[X+4]
 05B7 08                push A
 05B8 952C              xcall _longServoInstruction
 05BA 38FA              add SP,-6
 05BC                   .dbline 389
 05BC           ;                                               }
 05BC                   .dbline 390
 05BC           ;                                       }
 05BC 845B              xjmp L88
 05BE           L94:
 05BE                   .dbline 391
 05BE           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 05BE 62D000            mov REG[0xd0],>__r0
 05C1 5201              mov A,[X+1]
 05C3 5300              mov [__r1],A
 05C5 5200              mov A,[X+0]
 05C7 60D4              mov REG[0xd4],A
 05C9 3E00              mvi A,[__r1]
 05CB 5300              mov [__r1],A
 05CD 550000            mov [__r0],0
 05D0 3C0000            cmp [__r0],0
 05D3 B005              jnz X28
 05D5 3970              cmp A,112
 05D7 A00E              jz L103
 05D9           X28:
 05D9 62D000            mov REG[0xd0],>__r0
 05DC 3C0000            cmp [__r0],0
 05DF B045              jnz L101
 05E1 3C0050            cmp [__r1],80
 05E4 B040              jnz L101
 05E6           X29:
 05E6           L103:
 05E6                   .dbline 392
 05E6           ;                                       {
 05E6                   .dbline 393
 05E6           ;                                               if(param = COMP_SERIAL_szGetParam())
 05E6 10                push X
 05E7 7C0000            xcall _COMP_SERIAL_szGetParam
 05EA 62D000            mov REG[0xd0],>__r0
 05ED 5300              mov [__r0],A
 05EF 5A00              mov [__r1],X
 05F1 20                pop X
 05F2 5100              mov A,[__r1]
 05F4 5401              mov [X+1],A
 05F6 5100              mov A,[__r0]
 05F8 5400              mov [X+0],A
 05FA 3C0000            cmp [__r0],0
 05FD B006              jnz X30
 05FF 3C0000            cmp [__r1],0
 0602 A415              jz L88
 0604           X30:
 0604                   .dbline 394
 0604           ;                                               {
 0604                   .dbline 396
 0604           ;                                                       // Write the desired power value to the servo.
 0604           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0604 5200              mov A,[X+0]
 0606 08                push A
 0607 5201              mov A,[X+1]
 0609 08                push A
 060A 7C0000            xcall _atoi
 060D 62D000            mov REG[0xd0],>__r0
 0610 5100              mov A,[__r1]
 0612 08                push A
 0613 5018              mov A,24
 0615 08                push A
 0616 5003              mov A,3
 0618 08                push A
 0619 5004              mov A,4
 061B 08                push A
 061C 5204              mov A,[X+4]
 061E 08                push A
 061F 9422              xcall _servoInstruction
 0621 38F9              add SP,-7
 0623                   .dbline 397
 0623           ;                                               }
 0623                   .dbline 398
 0623           ;                                       }
 0623 83F4              xjmp L88
 0625           L101:
 0625                   .dbline 399
 0625           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 0625 62D000            mov REG[0xd0],>__r0
 0628 5201              mov A,[X+1]
 062A 5300              mov [__r1],A
 062C 5200              mov A,[X+0]
 062E 60D4              mov REG[0xd4],A
 0630 3E00              mvi A,[__r1]
 0632 5300              mov [__r1],A
 0634 550000            mov [__r0],0
 0637 3C0000            cmp [__r0],0
 063A B005              jnz X31
 063C 3973              cmp A,115
 063E A00E              jz L108
 0640           X31:
 0640 62D000            mov REG[0xd0],>__r0
 0643 3C0000            cmp [__r0],0
 0646 B3D1              jnz L88
 0648 3C0053            cmp [__r1],83
 064B B3CC              jnz L88
 064D           X32:
 064D           L108:
 064D                   .dbline 400
 064D           ;                                       {
 064D                   .dbline 401
 064D           ;                                               if(param = COMP_SERIAL_szGetParam())
 064D 10                push X
 064E 7C0000            xcall _COMP_SERIAL_szGetParam
 0651 62D000            mov REG[0xd0],>__r0
 0654 5300              mov [__r0],A
 0656 5A00              mov [__r1],X
 0658 20                pop X
 0659 5100              mov A,[__r1]
 065B 5401              mov [X+1],A
 065D 5100              mov A,[__r0]
 065F 5400              mov [X+0],A
 0661 3C0000            cmp [__r0],0
 0664 B006              jnz X33
 0666 3C0000            cmp [__r1],0
 0669 A3AE              jz L88
 066B           X33:
 066B                   .dbline 402
 066B           ;                                               {
 066B                   .dbline 403
 066B           ;                                                       total = atoi(param);
 066B 5200              mov A,[X+0]
 066D 08                push A
 066E 5201              mov A,[X+1]
 0670 08                push A
 0671 7C0000            xcall _atoi
 0674 38FE              add SP,-2
 0676 62D000            mov REG[0xd0],>__r0
 0679 5100              mov A,[__r1]
 067B 5406              mov [X+6],A
 067D 5100              mov A,[__r0]
 067F 5405              mov [X+5],A
 0681                   .dbline 406
 0681           ;                                                       
 0681           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 0681           ;                                                       if(total)
 0681 3D0500            cmp [X+5],0
 0684 B006              jnz X34
 0686 3D0600            cmp [X+6],0
 0689 A38E              jz L88
 068B           X34:
 068B                   .dbline 407
 068B           ;                                                       {
 068B                   .dbline 408
 068B           ;                                                               speed[0] = total%256;
 068B 62D000            mov REG[0xd0],>__r0
 068E 5001              mov A,1
 0690 08                push A
 0691 5000              mov A,0
 0693 08                push A
 0694 5205              mov A,[X+5]
 0696 08                push A
 0697 5206              mov A,[X+6]
 0699 08                push A
 069A 7C0000            xcall __divmod_16X16_16
 069D 38FE              add SP,-2
 069F 18                pop A
 06A0 5300              mov [__r1],A
 06A2 18                pop A
 06A3 5100              mov A,[__r1]
 06A5 540A              mov [X+10],A
 06A7                   .dbline 409
 06A7           ;                                                               speed[1] = total/256;
 06A7 5001              mov A,1
 06A9 08                push A
 06AA 5000              mov A,0
 06AC 08                push A
 06AD 5205              mov A,[X+5]
 06AF 08                push A
 06B0 5206              mov A,[X+6]
 06B2 08                push A
 06B3 7C0000            xcall __divmod_16X16_16
 06B6 18                pop A
 06B7 5300              mov [__r1],A
 06B9 18                pop A
 06BA 38FE              add SP,-2
 06BC 5100              mov A,[__r1]
 06BE 540B              mov [X+11],A
 06C0                   .dbline 410
 06C0           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 06C0 520B              mov A,[X+11]
 06C2 08                push A
 06C3 520A              mov A,[X+10]
 06C5 08                push A
 06C6 5020              mov A,32
 06C8 08                push A
 06C9 5003              mov A,3
 06CB 08                push A
 06CC 5005              mov A,5
 06CE 08                push A
 06CF 5204              mov A,[X+4]
 06D1 08                push A
 06D2 9412              xcall _longServoInstruction
 06D4 38FA              add SP,-6
 06D6                   .dbline 411
 06D6           ;                                                       }
 06D6                   .dbline 412
 06D6           ;                                               }
 06D6                   .dbline 413
 06D6           ;                                       }
 06D6                   .dbline 414
 06D6           ;                               }
 06D6                   .dbline 415
 06D6           ;                       }
 06D6                   .dbline 416
 06D6           ;               }
 06D6 8341              xjmp L88
 06D8           L87:
 06D8                   .dbline 417
 06D8           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 06D8 62D000            mov REG[0xd0],>__r0
 06DB 5201              mov A,[X+1]
 06DD 5300              mov [__r1],A
 06DF 5200              mov A,[X+0]
 06E1 60D4              mov REG[0xd4],A
 06E3 3E00              mvi A,[__r1]
 06E5 5300              mov [__r1],A
 06E7 550000            mov [__r0],0
 06EA 3C0000            cmp [__r0],0
 06ED B005              jnz X35
 06EF 3972              cmp A,114
 06F1 A00E              jz L117
 06F3           X35:
 06F3 62D000            mov REG[0xd0],>__r0
 06F6 3C0000            cmp [__r0],0
 06F9 B31E              jnz L115
 06FB 3C0052            cmp [__r1],82
 06FE B319              jnz L115
 0700           X36:
 0700           L117:
 0700                   .dbline 418
 0700           ;               {                       
 0700                   .dbline 419
 0700           ;                       if(param = COMP_SERIAL_szGetParam())
 0700 10                push X
 0701 7C0000            xcall _COMP_SERIAL_szGetParam
 0704 62D000            mov REG[0xd0],>__r0
 0707 5300              mov [__r0],A
 0709 5A00              mov [__r1],X
 070B 20                pop X
 070C 5100              mov A,[__r1]
 070E 5401              mov [X+1],A
 0710 5100              mov A,[__r0]
 0712 5400              mov [X+0],A
 0714 3C0000            cmp [__r0],0
 0717 B006              jnz X37
 0719 3C0000            cmp [__r1],0
 071C A2FB              jz L118
 071E           X37:
 071E                   .dbline 420
 071E           ;                       {
 071E                   .dbline 421
 071E           ;                               ID = atoi(param);
 071E 5200              mov A,[X+0]
 0720 08                push A
 0721 5201              mov A,[X+1]
 0723 08                push A
 0724 7C0000            xcall _atoi
 0727 38FE              add SP,-2
 0729 62D000            mov REG[0xd0],>__r0
 072C 5100              mov A,[__r1]
 072E 5404              mov [X+4],A
 0730                   .dbline 422
 0730           ;                               if(param = COMP_SERIAL_szGetParam())
 0730 10                push X
 0731 7C0000            xcall _COMP_SERIAL_szGetParam
 0734 62D000            mov REG[0xd0],>__r0
 0737 5300              mov [__r0],A
 0739 5A00              mov [__r1],X
 073B 20                pop X
 073C 5100              mov A,[__r1]
 073E 5401              mov [X+1],A
 0740 5100              mov A,[__r0]
 0742 5400              mov [X+0],A
 0744 3C0000            cmp [__r0],0
 0747 B006              jnz X38
 0749 3C0000            cmp [__r1],0
 074C A2CB              jz L120
 074E           X38:
 074E                   .dbline 423
 074E           ;                               {
 074E                   .dbline 424
 074E           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 074E 62D000            mov REG[0xd0],>__r0
 0751 5201              mov A,[X+1]
 0753 5300              mov [__r1],A
 0755 5200              mov A,[X+0]
 0757 60D4              mov REG[0xd4],A
 0759 3E00              mvi A,[__r1]
 075B 5300              mov [__r1],A
 075D 550000            mov [__r0],0
 0760 3C0000            cmp [__r0],0
 0763 B005              jnz X39
 0765 3961              cmp A,97
 0767 A00E              jz L124
 0769           X39:
 0769 62D000            mov REG[0xd0],>__r0
 076C 3C0000            cmp [__r0],0
 076F B0D1              jnz L122
 0771 3C0041            cmp [__r1],65
 0774 B0CC              jnz L122
 0776           X40:
 0776           L124:
 0776                   .dbline 425
 0776           ;                                       {
 0776                   .dbline 426
 0776           ;                                               angle[0] = 0;
 0776 560800            mov [X+8],0
 0779                   .dbline 427
 0779           ;                                               angle[1] = 0;
 0779 560900            mov [X+9],0
 077C                   .dbline 430
 077C           ;                                               
 077C           ;                                               // Send a request for the servo's angle.
 077C           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 077C 5002              mov A,2
 077E 08                push A
 077F 5024              mov A,36
 0781 08                push A
 0782 5002              mov A,2
 0784 08                push A
 0785 5004              mov A,4
 0787 08                push A
 0788 5204              mov A,[X+4]
 078A 08                push A
 078B 92B6              xcall _servoInstruction
 078D                   .dbline 431
 078D           ;                                               configToggle(RX_MODE);
 078D 5000              mov A,0
 078F 08                push A
 0790 5001              mov A,1
 0792 08                push A
 0793 9402              xcall _configToggle
 0795 38F9              add SP,-7
 0797 8098              xjmp L127
 0799           L126:
 0799                   .dbline 435
 0799           ;                                                       
 0799           ;                                               // Loop until we read a response or time out.
 0799           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0799           ;                                               {
 0799                   .dbline 436
 0799           ;                                                       if(RECEIVE_cReadChar() == ID)
 0799 10                push X
 079A 7C0000            xcall _RECEIVE_cReadChar
 079D 62D000            mov REG[0xd0],>__r0
 07A0 20                pop X
 07A1 3B04              cmp A,[X+4]
 07A3 B08C              jnz L129
 07A5                   .dbline 437
 07A5           ;                                                       {
 07A5 807B              xjmp L132
 07A7           L131:
 07A7                   .dbline 439
 07A7           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07A7           ;                                                               {
 07A7                   .dbline 440
 07A7           ;                                                                       if(RECEIVE_cReadChar() == 4)
 07A7 10                push X
 07A8 7C0000            xcall _RECEIVE_cReadChar
 07AB 62D000            mov REG[0xd0],>__r0
 07AE 20                pop X
 07AF 3904              cmp A,4
 07B1 B06F              jnz L134
 07B3                   .dbline 441
 07B3           ;                                                                       {
 07B3                   .dbline 442
 07B3           ;                                                                               if(RECEIVE_cGetChar() == 0)
 07B3 10                push X
 07B4 7C0000            xcall _RECEIVE_cGetChar
 07B7 62D000            mov REG[0xd0],>__r0
 07BA 20                pop X
 07BB 3900              cmp A,0
 07BD B05A              jnz L136
 07BF                   .dbline 443
 07BF           ;                                                                               {
 07BF                   .dbline 445
 07BF           ;                                                                                       // Grab the angle bytes.
 07BF           ;                                                                                       angle[0] = RECEIVE_cGetChar();
 07BF 10                push X
 07C0 7C0000            xcall _RECEIVE_cGetChar
 07C3 62D000            mov REG[0xd0],>__r0
 07C6 20                pop X
 07C7 5408              mov [X+8],A
 07C9                   .dbline 446
 07C9           ;                                                                                       angle[1] = RECEIVE_cGetChar();
 07C9 10                push X
 07CA 7C0000            xcall _RECEIVE_cGetChar
 07CD 62D000            mov REG[0xd0],>__r0
 07D0 20                pop X
 07D1 5409              mov [X+9],A
 07D3                   .dbline 448
 07D3           ;                                                                                       
 07D3           ;                                                                                       configToggle(PC_MODE);
 07D3 5000              mov A,0
 07D5 08                push A
 07D6 5002              mov A,2
 07D8 08                push A
 07D9 93BC              xcall _configToggle
 07DB                   .dbline 451
 07DB           ;                                                                                       
 07DB           ;                                                                                       // Convert the bytes to an int from 0-1023 and send.
 07DB           ;                                                                                       total = ((angle[1])*256) + angle[0];
 07DB 5208              mov A,[X+8]
 07DD 5406              mov [X+6],A
 07DF 5209              mov A,[X+9]
 07E1 5405              mov [X+5],A
 07E3                   .dbline 452
 07E3           ;                                                                                       itoa(param,total,10);
 07E3 5000              mov A,0
 07E5 08                push A
 07E6 500A              mov A,10
 07E8 08                push A
 07E9 5205              mov A,[X+5]
 07EB 08                push A
 07EC 5206              mov A,[X+6]
 07EE 08                push A
 07EF 5200              mov A,[X+0]
 07F1 08                push A
 07F2 5201              mov A,[X+1]
 07F4 08                push A
 07F5 7C0000            xcall _itoa
 07F8 38F8              add SP,-8
 07FA                   .dbline 453
 07FA           ;                                                                                       COMP_SERIAL_PutString(param);
 07FA 10                push X
 07FB 5200              mov A,[X+0]
 07FD 08                push A
 07FE 5201              mov A,[X+1]
 0800 5C                mov X,A
 0801 18                pop A
 0802 7C0000            xcall _COMP_SERIAL_PutString
 0805 20                pop X
 0806                   .dbline 454
 0806           ;                                                                                       COMP_SERIAL_PutChar('\n');
 0806 10                push X
 0807 500A              mov A,10
 0809 7C0000            xcall _COMP_SERIAL_PutChar
 080C 20                pop X
 080D                   .dbline 456
 080D           ; 
 080D           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 080D 62D000            mov REG[0xd0],>_TIMEOUT
 0810 550103            mov [_TIMEOUT+1],3
 0813 550000            mov [_TIMEOUT],0
 0816                   .dbline 457
 0816           ;                                                                               }
 0816 800A              xjmp L137
 0818           L136:
 0818                   .dbline 459
 0818           ;                                                                               else
 0818           ;                                                                               {
 0818                   .dbline 460
 0818           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0818 62D000            mov REG[0xd0],>_TIMEOUT
 081B 550103            mov [_TIMEOUT+1],3
 081E 550000            mov [_TIMEOUT],0
 0821                   .dbline 461
 0821           ;                                                                               }
 0821           L137:
 0821                   .dbline 462
 0821           ;                                                                       }
 0821           L134:
 0821                   .dbline 463
 0821           ;                                                               }
 0821           L132:
 0821                   .dbline 438
 0821 62D000            mov REG[0xd0],>_TIMEOUT
 0824 5101              mov A,[_TIMEOUT+1]
 0826 1103              sub A,3
 0828 5100              mov A,[_TIMEOUT]
 082A 3180              xor A,-128
 082C 1980              sbb A,(0 ^ 0x80)
 082E CF78              jc L131
 0830           X41:
 0830                   .dbline 464
 0830           ;                                                       }
 0830           L129:
 0830                   .dbline 465
 0830           ;                                               }
 0830           L127:
 0830                   .dbline 434
 0830 62D000            mov REG[0xd0],>_TIMEOUT
 0833 5101              mov A,[_TIMEOUT+1]
 0835 1103              sub A,3
 0837 5100              mov A,[_TIMEOUT]
 0839 3180              xor A,-128
 083B 1980              sbb A,(0 ^ 0x80)
 083D CF5B              jc L126
 083F           X42:
 083F                   .dbline 466
 083F           ;                                       }
 083F 81D8              xjmp L123
 0841           L122:
 0841                   .dbline 467
 0841           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 0841 62D000            mov REG[0xd0],>__r0
 0844 5201              mov A,[X+1]
 0846 5300              mov [__r1],A
 0848 5200              mov A,[X+0]
 084A 60D4              mov REG[0xd4],A
 084C 3E00              mvi A,[__r1]
 084E 5300              mov [__r1],A
 0850 550000            mov [__r0],0
 0853 3C0000            cmp [__r0],0
 0856 B005              jnz X43
 0858 3970              cmp A,112
 085A A00E              jz L142
 085C           X43:
 085C 62D000            mov REG[0xd0],>__r0
 085F 3C0000            cmp [__r0],0
 0862 B0EF              jnz L140
 0864 3C0050            cmp [__r1],80
 0867 B0EA              jnz L140
 0869           X44:
 0869           L142:
 0869                   .dbline 468
 0869           ;                                       {
 0869                   .dbline 469
 0869           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 0869 5001              mov A,1
 086B 08                push A
 086C 5018              mov A,24
 086E 08                push A
 086F 5002              mov A,2
 0871 08                push A
 0872 5004              mov A,4
 0874 08                push A
 0875 5204              mov A,[X+4]
 0877 08                push A
 0878 91C9              xcall _servoInstruction
 087A                   .dbline 470
 087A           ;                                               configToggle(RX_MODE);
 087A 5000              mov A,0
 087C 08                push A
 087D 5001              mov A,1
 087F 08                push A
 0880 9315              xcall _configToggle
 0882 38F9              add SP,-7
 0884 80BC              xjmp L144
 0886           L143:
 0886                   .dbline 474
 0886           ;                                               
 0886           ;                                               // Loop until we read a response or time out.
 0886           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0886           ;                                               {
 0886                   .dbline 475
 0886           ;                                                       if(RECEIVE_cReadChar() == ID)
 0886 10                push X
 0887 7C0000            xcall _RECEIVE_cReadChar
 088A 62D000            mov REG[0xd0],>__r0
 088D 20                pop X
 088E 3B04              cmp A,[X+4]
 0890 B0B0              jnz L146
 0892                   .dbline 476
 0892           ;                                                       {
 0892                   .dbline 477
 0892           ;                                                               runningTotal = ID;
 0892 5204              mov A,[X+4]
 0894 5403              mov [X+3],A
 0896 560200            mov [X+2],0
 0899 8098              xjmp L149
 089B           L148:
 089B                   .dbline 480
 089B           ;                                                               // Loop until we read a response or time out.
 089B           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 089B           ;                                                               {
 089B                   .dbline 482
 089B           ;                                                                       // Check the length of the packet.
 089B           ;                                                                       if(RECEIVE_cReadChar() == 3)
 089B 10                push X
 089C 7C0000            xcall _RECEIVE_cReadChar
 089F 62D000            mov REG[0xd0],>__r0
 08A2 20                pop X
 08A3 3903              cmp A,3
 08A5 B08C              jnz L151
 08A7                   .dbline 483
 08A7           ;                                                                       {
 08A7                   .dbline 484
 08A7           ;                                                                               runningTotal += 3;
 08A7 070303            add [X+3],3
 08AA 0F0200            adc [X+2],0
 08AD 8075              xjmp L154
 08AF           L153:
 08AF                   .dbline 487
 08AF           ;                                                                               // Loop until we read a response or time out.
 08AF           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 08AF           ;                                                                               {
 08AF                   .dbline 489
 08AF           ;                                                                                       // Check for the checksum or 1.
 08AF           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 08AF 10                push X
 08B0 7C0000            xcall _RECEIVE_cReadChar
 08B3 62D000            mov REG[0xd0],>__r0
 08B6 20                pop X
 08B7 5407              mov [X+7],A
 08B9 3900              cmp A,0
 08BB A067              jz L156
 08BD                   .dbline 490
 08BD           ;                                                                                       {
 08BD                   .dbline 491
 08BD           ;                                                                                               configToggle(PC_MODE);
 08BD 5000              mov A,0
 08BF 08                push A
 08C0 5002              mov A,2
 08C2 08                push A
 08C3 92D2              xcall _configToggle
 08C5 38FE              add SP,-2
 08C7                   .dbline 493
 08C7           ;                                                                                               
 08C7           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 08C7 62D000            mov REG[0xd0],>__r0
 08CA 5207              mov A,[X+7]
 08CC 5300              mov [__r1],A
 08CE 550000            mov [__r0],0
 08D1 50FF              mov A,-1
 08D3 1200              sub A,[__r1]
 08D5 5300              mov [__r1],A
 08D7 5000              mov A,0
 08D9 1A00              sbb A,[__r0]
 08DB 5300              mov [__r0],A
 08DD 5001              mov A,1
 08DF 08                push A
 08E0 5000              mov A,0
 08E2 08                push A
 08E3 5202              mov A,[X+2]
 08E5 08                push A
 08E6 5203              mov A,[X+3]
 08E8 08                push A
 08E9 7C0000            xcall __divmod_16X16_16
 08EC 38FE              add SP,-2
 08EE 18                pop A
 08EF 5300              mov [__r3],A
 08F1 18                pop A
 08F2 3A00              cmp A,[__r0]
 08F4 B017              jnz L158
 08F6 5100              mov A,[__r3]
 08F8 3A00              cmp A,[__r1]
 08FA B011              jnz L158
 08FC           X45:
 08FC                   .dbline 494
 08FC           ;                                                                                               {
 08FC                   .dbline 496
 08FC           ;                                                                                                       // Send a 0 if we hit the checksum.
 08FC           ;                                                                                                       COMP_SERIAL_PutChar('0');
 08FC 10                push X
 08FD 5030              mov A,48
 08FF 7C0000            xcall _COMP_SERIAL_PutChar
 0902 20                pop X
 0903                   .dbline 497
 0903           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0903 10                push X
 0904 500A              mov A,10
 0906 7C0000            xcall _COMP_SERIAL_PutChar
 0909 20                pop X
 090A                   .dbline 498
 090A           ;                                                                                               }
 090A 800F              xjmp L159
 090C           L158:
 090C                   .dbline 500
 090C           ;                                                                                               else
 090C           ;                                                                                               {
 090C                   .dbline 502
 090C           ;                                                                                                       // Send a 1.
 090C           ;                                                                                                       COMP_SERIAL_PutChar('1');
 090C 10                push X
 090D 5031              mov A,49
 090F 7C0000            xcall _COMP_SERIAL_PutChar
 0912 20                pop X
 0913                   .dbline 503
 0913           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0913 10                push X
 0914 500A              mov A,10
 0916 7C0000            xcall _COMP_SERIAL_PutChar
 0919 20                pop X
 091A                   .dbline 504
 091A           ;                                                                                               }
 091A           L159:
 091A                   .dbline 506
 091A           ;               
 091A           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 091A 62D000            mov REG[0xd0],>_TIMEOUT
 091D 550103            mov [_TIMEOUT+1],3
 0920 550000            mov [_TIMEOUT],0
 0923                   .dbline 507
 0923           ;                                                                                       }
 0923           L156:
 0923                   .dbline 508
 0923           ;                                                                               }
 0923           L154:
 0923                   .dbline 486
 0923 62D000            mov REG[0xd0],>_TIMEOUT
 0926 5101              mov A,[_TIMEOUT+1]
 0928 1103              sub A,3
 092A 5100              mov A,[_TIMEOUT]
 092C 3180              xor A,-128
 092E 1980              sbb A,(0 ^ 0x80)
 0930 CF7E              jc L153
 0932           X46:
 0932                   .dbline 509
 0932           ;                                                                       }
 0932           L151:
 0932                   .dbline 510
 0932           ;                                                               }
 0932           L149:
 0932                   .dbline 479
 0932 62D000            mov REG[0xd0],>_TIMEOUT
 0935 5101              mov A,[_TIMEOUT+1]
 0937 1103              sub A,3
 0939 5100              mov A,[_TIMEOUT]
 093B 3180              xor A,-128
 093D 1980              sbb A,(0 ^ 0x80)
 093F CF5B              jc L148
 0941           X47:
 0941                   .dbline 511
 0941           ;                                                       }
 0941           L146:
 0941                   .dbline 512
 0941           ;                                               }
 0941           L144:
 0941                   .dbline 473
 0941 62D000            mov REG[0xd0],>_TIMEOUT
 0944 5101              mov A,[_TIMEOUT+1]
 0946 1103              sub A,3
 0948 5100              mov A,[_TIMEOUT]
 094A 3180              xor A,-128
 094C 1980              sbb A,(0 ^ 0x80)
 094E CF37              jc L143
 0950           X48:
 0950                   .dbline 513
 0950           ;                                       }
 0950 80C7              xjmp L141
 0952           L140:
 0952                   .dbline 514
 0952           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 0952 62D000            mov REG[0xd0],>__r0
 0955 5201              mov A,[X+1]
 0957 5300              mov [__r1],A
 0959 5200              mov A,[X+0]
 095B 60D4              mov REG[0xd4],A
 095D 3E00              mvi A,[__r1]
 095F 5300              mov [__r1],A
 0961 550000            mov [__r0],0
 0964 3C0000            cmp [__r0],0
 0967 B005              jnz X49
 0969 3974              cmp A,116
 096B A00E              jz L162
 096D           X49:
 096D 62D000            mov REG[0xd0],>__r0
 0970 3C0000            cmp [__r0],0
 0973 B042              jnz L160
 0975 3C0054            cmp [__r1],84
 0978 B03D              jnz L160
 097A           X50:
 097A           L162:
 097A                   .dbline 515
 097A           ;                                       {
 097A                   .dbline 517
 097A           ;                                               // Ping the module and return its type field to the PC.
 097A           ;                                               if(pingModule(ID))
 097A 62D000            mov REG[0xd0],>__r0
 097D 5204              mov A,[X+4]
 097F 5300              mov [__r1],A
 0981 5000              mov A,0
 0983 08                push A
 0984 5100              mov A,[__r1]
 0986 08                push A
 0987 7C0046            xcall _pingModule
 098A 38FE              add SP,-2
 098C 62D000            mov REG[0xd0],>__r0
 098F 3C0000            cmp [__r0],0
 0992 B006              jnz X51
 0994 3C0000            cmp [__r1],0
 0997 A080              jz L161
 0999           X51:
 0999                   .dbline 518
 0999           ;                                               {
 0999                   .dbline 519
 0999           ;                                                       configToggle(PC_MODE);
 0999 5000              mov A,0
 099B 08                push A
 099C 5002              mov A,2
 099E 08                push A
 099F 91F6              xcall _configToggle
 09A1 38FE              add SP,-2
 09A3                   .dbline 521
 09A3           ;                                                       
 09A3           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 09A3 10                push X
 09A4 62D000            mov REG[0xd0],>_PARAM
 09A7 5100              mov A,[_PARAM]
 09A9 7C0000            xcall _COMP_SERIAL_PutChar
 09AC 20                pop X
 09AD                   .dbline 522
 09AD           ;                                                       COMP_SERIAL_PutChar('\n');
 09AD 10                push X
 09AE 500A              mov A,10
 09B0 7C0000            xcall _COMP_SERIAL_PutChar
 09B3 20                pop X
 09B4                   .dbline 523
 09B4           ;                                               }
 09B4                   .dbline 524
 09B4           ;                                       }
 09B4 8063              xjmp L161
 09B6           L160:
 09B6                   .dbline 525
 09B6           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 09B6 62D000            mov REG[0xd0],>__r0
 09B9 5201              mov A,[X+1]
 09BB 5300              mov [__r1],A
 09BD 5200              mov A,[X+0]
 09BF 60D4              mov REG[0xd4],A
 09C1 3E00              mvi A,[__r1]
 09C3 5300              mov [__r1],A
 09C5 550000            mov [__r0],0
 09C8 3C0000            cmp [__r0],0
 09CB B005              jnz X52
 09CD 3963              cmp A,99
 09CF A00E              jz L167
 09D1           X52:
 09D1 62D000            mov REG[0xd0],>__r0
 09D4 3C0000            cmp [__r0],0
 09D7 B040              jnz L165
 09D9 3C0043            cmp [__r1],67
 09DC B03B              jnz L165
 09DE           X53:
 09DE           L167:
 09DE                   .dbline 526
 09DE           ;                                       {
 09DE                   .dbline 528
 09DE           ;                                               // Ping the module and return its child port to the PC.
 09DE           ;                                               if(pingModule(ID))
 09DE 62D000            mov REG[0xd0],>__r0
 09E1 5204              mov A,[X+4]
 09E3 5300              mov [__r1],A
 09E5 5000              mov A,0
 09E7 08                push A
 09E8 5100              mov A,[__r1]
 09EA 08                push A
 09EB 7C0046            xcall _pingModule
 09EE 38FE              add SP,-2
 09F0 62D000            mov REG[0xd0],>__r0
 09F3 3C0000            cmp [__r0],0
 09F6 B006              jnz X54
 09F8 3C0000            cmp [__r1],0
 09FB A01C              jz L168
 09FD           X54:
 09FD                   .dbline 529
 09FD           ;                                               {       
 09FD                   .dbline 530
 09FD           ;                                                       configToggle(PC_MODE);
 09FD 5000              mov A,0
 09FF 08                push A
 0A00 5002              mov A,2
 0A02 08                push A
 0A03 9192              xcall _configToggle
 0A05 38FE              add SP,-2
 0A07                   .dbline 532
 0A07           ;                                                       
 0A07           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 0A07 10                push X
 0A08 62D000            mov REG[0xd0],>_PARAM
 0A0B 5101              mov A,[_PARAM+1]
 0A0D 7C0000            xcall _COMP_SERIAL_PutChar
 0A10 20                pop X
 0A11                   .dbline 533
 0A11           ;                                                       COMP_SERIAL_PutChar('\n');
 0A11 10                push X
 0A12 500A              mov A,10
 0A14 7C0000            xcall _COMP_SERIAL_PutChar
 0A17 20                pop X
 0A18                   .dbline 534
 0A18           ;                                               }
 0A18           L168:
 0A18                   .dbline 535
 0A18           ;                                       }
 0A18           L165:
 0A18           L161:
 0A18           L141:
 0A18           L123:
 0A18                   .dbline 536
 0A18           ;                               }
 0A18           L120:
 0A18                   .dbline 537
 0A18           ;                       }
 0A18           L118:
 0A18                   .dbline 538
 0A18           ;               }
 0A18           L115:
 0A18           L88:
 0A18           L85:
 0A18           L78:
 0A18                   .dbline 539
 0A18           ;       }
 0A18           L75:
 0A18                   .dbline 541
 0A18           ;       
 0A18           ;       if(STATE != PC_MODE)
 0A18 62D000            mov REG[0xd0],>_STATE
 0A1B 3C0000            cmp [_STATE],0
 0A1E B006              jnz X55
 0A20 3C0102            cmp [_STATE+1],2
 0A23 A00D              jz L171
 0A25           X55:
 0A25                   .dbline 542
 0A25           ;       {
 0A25                   .dbline 543
 0A25           ;               configToggle(PC_MODE);
 0A25 5000              mov A,0
 0A27 08                push A
 0A28 5002              mov A,2
 0A2A 08                push A
 0A2B 916A              xcall _configToggle
 0A2D 38FE              add SP,-2
 0A2F                   .dbline 544
 0A2F           ;       }
 0A2F 800F              xjmp L172
 0A31           L171:
 0A31                   .dbline 546
 0A31           ;       else
 0A31           ;       {
 0A31                   .dbline 547
 0A31           ;               TIMEOUT = 0;
 0A31 62D000            mov REG[0xd0],>_TIMEOUT
 0A34 550100            mov [_TIMEOUT+1],0
 0A37 550000            mov [_TIMEOUT],0
 0A3A                   .dbline 548
 0A3A           ;               COMP_SERIAL_CmdReset();
 0A3A 10                push X
 0A3B 7C0000            xcall _COMP_SERIAL_CmdReset
 0A3E 20                pop X
 0A3F                   .dbline 549
 0A3F           ;       }
 0A3F           L172:
 0A3F                   .dbline -2
 0A3F           L74:
 0A3F 38F4              add SP,-12
 0A41 20                pop X
 0A42                   .dbline 0 ; func end
 0A42 7F                ret
 0A43                   .dbsym l speed 10 A[2:2]c
 0A43                   .dbsym l angle 8 A[2:2]c
 0A43                   .dbsym l tempByte 7 c
 0A43                   .dbsym l total 5 I
 0A43                   .dbsym l ID 4 c
 0A43                   .dbsym l runningTotal 2 I
 0A43                   .dbsym l param 0 pc
 0A43                   .dbend
 0A43                   .dbfunc e servoInstruction _servoInstruction fV
 0A43           ;          total -> X+1
 0A43           ;       checksum -> X+0
 0A43           ;          value -> X-8
 0A43           ;        address -> X-7
 0A43           ;    instruction -> X-6
 0A43           ;         length -> X-5
 0A43           ;             id -> X-4
 0A43           _servoInstruction::
 0A43                   .dbline -1
 0A43 10                push X
 0A44 4F                mov X,SP
 0A45 3803              add SP,3
 0A47                   .dbline 555
 0A47           ; }
 0A47           ; 
 0A47           ; // This function receives a destination, command length, instruction type, address, and value.
 0A47           ; // With these parameters, the function sends a packet to the communication bus.
 0A47           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0A47           ; {
 0A47                   .dbline 559
 0A47           ;       char checksum;
 0A47           ;       int total;
 0A47           ;       
 0A47           ;       total = id + length + instruction + address + value;
 0A47 62D000            mov REG[0xd0],>__r0
 0A4A 52FB              mov A,[X-5]
 0A4C 5300              mov [__r1],A
 0A4E 550000            mov [__r0],0
 0A51 52FC              mov A,[X-4]
 0A53 0200              add A,[__r1]
 0A55 5300              mov [__r1],A
 0A57 5000              mov A,0
 0A59 0A00              adc A,[__r0]
 0A5B 5300              mov [__r0],A
 0A5D 52FA              mov A,[X-6]
 0A5F 0400              add [__r1],A
 0A61 0E0000            adc [__r0],0
 0A64 52F9              mov A,[X-7]
 0A66 0400              add [__r1],A
 0A68 0E0000            adc [__r0],0
 0A6B 52F8              mov A,[X-8]
 0A6D 5300              mov [__r3],A
 0A6F 550000            mov [__r2],0
 0A72 5100              mov A,[__r1]
 0A74 0200              add A,[__r3]
 0A76 5402              mov [X+2],A
 0A78 5100              mov A,[__r0]
 0A7A 0A00              adc A,[__r2]
 0A7C 5401              mov [X+1],A
 0A7E                   .dbline 562
 0A7E           ;       
 0A7E           ;       // Calculate the checksum value for our servo communication.
 0A7E           ;       checksum = 255-(total%256);
 0A7E 5001              mov A,1
 0A80 08                push A
 0A81 5000              mov A,0
 0A83 08                push A
 0A84 5201              mov A,[X+1]
 0A86 08                push A
 0A87 5202              mov A,[X+2]
 0A89 08                push A
 0A8A 7C0000            xcall __divmod_16X16_16
 0A8D 38FE              add SP,-2
 0A8F 18                pop A
 0A90 5300              mov [__r1],A
 0A92 18                pop A
 0A93 50FF              mov A,-1
 0A95 1200              sub A,[__r1]
 0A97 5400              mov [X+0],A
 0A99                   .dbline 565
 0A99           ;       
 0A99           ;       // Talk to the servo.
 0A99           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A99 10                push X
 0A9A 50FF              mov A,-1
 0A9C 7C0000            xcall _TX_REPEATER_PutChar
 0A9F 20                pop X
 0AA0                   .dbline 566
 0AA0           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0AA0 10                push X
 0AA1 50FF              mov A,-1
 0AA3 7C0000            xcall _TX_REPEATER_PutChar
 0AA6 20                pop X
 0AA7                   .dbline 567
 0AA7           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0AA7 10                push X
 0AA8 52FC              mov A,[X-4]
 0AAA 7C0000            xcall _TX_REPEATER_PutChar
 0AAD 20                pop X
 0AAE                   .dbline 568
 0AAE           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0AAE 10                push X
 0AAF 52FB              mov A,[X-5]
 0AB1 7C0000            xcall _TX_REPEATER_PutChar
 0AB4 20                pop X
 0AB5                   .dbline 569
 0AB5           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AB5 10                push X
 0AB6 52FA              mov A,[X-6]
 0AB8 7C0000            xcall _TX_REPEATER_PutChar
 0ABB 20                pop X
 0ABC                   .dbline 570
 0ABC           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0ABC 10                push X
 0ABD 52F9              mov A,[X-7]
 0ABF 7C0000            xcall _TX_REPEATER_PutChar
 0AC2 20                pop X
 0AC3                   .dbline 571
 0AC3           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0AC3 10                push X
 0AC4 52F8              mov A,[X-8]
 0AC6 7C0000            xcall _TX_REPEATER_PutChar
 0AC9 20                pop X
 0ACA                   .dbline 572
 0ACA           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0ACA 10                push X
 0ACB 5200              mov A,[X+0]
 0ACD 7C0000            xcall _TX_REPEATER_PutChar
 0AD0 20                pop X
 0AD1           L174:
 0AD1                   .dbline 575
 0AD1           ;       
 0AD1           ;       // Wait for the transmission to finish.
 0AD1           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0AD1           L175:
 0AD1                   .dbline 575
 0AD1 10                push X
 0AD2 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0AD5 62D000            mov REG[0xd0],>__r0
 0AD8 20                pop X
 0AD9 5300              mov [__r0],A
 0ADB 470020            tst [__r0],32
 0ADE AFF2              jz L174
 0AE0                   .dbline 578
 0AE0           ;       
 0AE0           ;       // Make completely sure we're done.
 0AE0           ;       xmitWait();
 0AE0 9352              xcall _xmitWait
 0AE2                   .dbline -2
 0AE2           L173:
 0AE2 38FD              add SP,-3
 0AE4 20                pop X
 0AE5                   .dbline 0 ; func end
 0AE5 7F                ret
 0AE6                   .dbsym l total 1 I
 0AE6                   .dbsym l checksum 0 c
 0AE6                   .dbsym l value -8 c
 0AE6                   .dbsym l address -7 c
 0AE6                   .dbsym l instruction -6 c
 0AE6                   .dbsym l length -5 c
 0AE6                   .dbsym l id -4 c
 0AE6                   .dbend
 0AE6                   .dbfunc e longServoInstruction _longServoInstruction fV
 0AE6           ;          total -> X+1
 0AE6           ;       checksum -> X+0
 0AE6           ;         value2 -> X-9
 0AE6           ;         value1 -> X-8
 0AE6           ;        address -> X-7
 0AE6           ;    instruction -> X-6
 0AE6           ;         length -> X-5
 0AE6           ;             id -> X-4
 0AE6           _longServoInstruction::
 0AE6                   .dbline -1
 0AE6 10                push X
 0AE7 4F                mov X,SP
 0AE8 3803              add SP,3
 0AEA                   .dbline 583
 0AEA           ; }
 0AEA           ; 
 0AEA           ; // This function receives a destination, command length, instruction type, address, and two values.
 0AEA           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0AEA           ; {
 0AEA                   .dbline 587
 0AEA           ;       char checksum;
 0AEA           ;       int total;
 0AEA           ;       
 0AEA           ;       total = id + length + instruction + address + value1 + value2;
 0AEA 62D000            mov REG[0xd0],>__r0
 0AED 52FB              mov A,[X-5]
 0AEF 5300              mov [__r1],A
 0AF1 550000            mov [__r0],0
 0AF4 52FC              mov A,[X-4]
 0AF6 0200              add A,[__r1]
 0AF8 5300              mov [__r1],A
 0AFA 5000              mov A,0
 0AFC 0A00              adc A,[__r0]
 0AFE 5300              mov [__r0],A
 0B00 52FA              mov A,[X-6]
 0B02 0400              add [__r1],A
 0B04 0E0000            adc [__r0],0
 0B07 52F9              mov A,[X-7]
 0B09 0400              add [__r1],A
 0B0B 0E0000            adc [__r0],0
 0B0E 52F8              mov A,[X-8]
 0B10 0400              add [__r1],A
 0B12 0E0000            adc [__r0],0
 0B15 52F7              mov A,[X-9]
 0B17 5300              mov [__r3],A
 0B19 550000            mov [__r2],0
 0B1C 5100              mov A,[__r1]
 0B1E 0200              add A,[__r3]
 0B20 5402              mov [X+2],A
 0B22 5100              mov A,[__r0]
 0B24 0A00              adc A,[__r2]
 0B26 5401              mov [X+1],A
 0B28                   .dbline 590
 0B28           ;       
 0B28           ;       // Calculate the checksum value for our servo communication.
 0B28           ;       checksum = 255-(total%256);
 0B28 5001              mov A,1
 0B2A 08                push A
 0B2B 5000              mov A,0
 0B2D 08                push A
 0B2E 5201              mov A,[X+1]
 0B30 08                push A
 0B31 5202              mov A,[X+2]
 0B33 08                push A
 0B34 7C0000            xcall __divmod_16X16_16
 0B37 38FE              add SP,-2
 0B39 18                pop A
 0B3A 5300              mov [__r1],A
 0B3C 18                pop A
 0B3D 50FF              mov A,-1
 0B3F 1200              sub A,[__r1]
 0B41 5400              mov [X+0],A
 0B43                   .dbline 593
 0B43           ;       
 0B43           ;       // Talk to the servo.
 0B43           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0B43 10                push X
 0B44 50FF              mov A,-1
 0B46 7C0000            xcall _TX_REPEATER_PutChar
 0B49 20                pop X
 0B4A                   .dbline 594
 0B4A           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0B4A 10                push X
 0B4B 50FF              mov A,-1
 0B4D 7C0000            xcall _TX_REPEATER_PutChar
 0B50 20                pop X
 0B51                   .dbline 595
 0B51           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0B51 10                push X
 0B52 52FC              mov A,[X-4]
 0B54 7C0000            xcall _TX_REPEATER_PutChar
 0B57 20                pop X
 0B58                   .dbline 596
 0B58           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0B58 10                push X
 0B59 52FB              mov A,[X-5]
 0B5B 7C0000            xcall _TX_REPEATER_PutChar
 0B5E 20                pop X
 0B5F                   .dbline 597
 0B5F           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0B5F 10                push X
 0B60 52FA              mov A,[X-6]
 0B62 7C0000            xcall _TX_REPEATER_PutChar
 0B65 20                pop X
 0B66                   .dbline 598
 0B66           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0B66 10                push X
 0B67 52F9              mov A,[X-7]
 0B69 7C0000            xcall _TX_REPEATER_PutChar
 0B6C 20                pop X
 0B6D                   .dbline 599
 0B6D           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0B6D 10                push X
 0B6E 52F8              mov A,[X-8]
 0B70 7C0000            xcall _TX_REPEATER_PutChar
 0B73 20                pop X
 0B74                   .dbline 600
 0B74           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0B74 10                push X
 0B75 52F7              mov A,[X-9]
 0B77 7C0000            xcall _TX_REPEATER_PutChar
 0B7A 20                pop X
 0B7B                   .dbline 601
 0B7B           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0B7B 10                push X
 0B7C 5200              mov A,[X+0]
 0B7E 7C0000            xcall _TX_REPEATER_PutChar
 0B81 20                pop X
 0B82           L178:
 0B82                   .dbline 604
 0B82           ;       
 0B82           ;       // Wait for the transmission to finish.
 0B82           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0B82           L179:
 0B82                   .dbline 604
 0B82 10                push X
 0B83 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0B86 62D000            mov REG[0xd0],>__r0
 0B89 20                pop X
 0B8A 5300              mov [__r0],A
 0B8C 470020            tst [__r0],32
 0B8F AFF2              jz L178
 0B91                   .dbline 607
 0B91           ;       
 0B91           ;       // Make completely sure we're done.
 0B91           ;       xmitWait();
 0B91 92A1              xcall _xmitWait
 0B93                   .dbline -2
 0B93           L177:
 0B93 38FD              add SP,-3
 0B95 20                pop X
 0B96                   .dbline 0 ; func end
 0B96 7F                ret
 0B97                   .dbsym l total 1 I
 0B97                   .dbsym l checksum 0 c
 0B97                   .dbsym l value2 -9 c
 0B97                   .dbsym l value1 -8 c
 0B97                   .dbsym l address -7 c
 0B97                   .dbsym l instruction -6 c
 0B97                   .dbsym l length -5 c
 0B97                   .dbsym l id -4 c
 0B97                   .dbend
 0B97                   .dbfunc e configToggle _configToggle fV
 0B97           ;           mode -> X-5
 0B97           _configToggle::
 0B97                   .dbline -1
 0B97 10                push X
 0B98 4F                mov X,SP
 0B99                   .dbline 613
 0B99           ; }
 0B99           ; 
 0B99           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B99           ; // half duplex UART serial communication line.
 0B99           ; void configToggle(int mode)
 0B99           ; {
 0B99                   .dbline 615
 0B99           ;       // Disconnect from the global bus and leave the pin high.
 0B99           ;       PRT0DR |= 0b11111111;
 0B99 4300FF            or REG[0],-1
 0B9C                   .dbline 616
 0B9C           ;       PRT0GS &= 0b01000000;
 0B9C 410240            and REG[0x2],64
 0B9F                   .dbline 620
 0B9F           ; 
 0B9F           ;       // Unload the configuration of the current state.
 0B9F           ;       // If there is no state, blindly wipe all configurations.
 0B9F           ;       if(STATE)
 0B9F 62D000            mov REG[0xd0],>_STATE
 0BA2 3C0000            cmp [_STATE],0
 0BA5 B006              jnz X56
 0BA7 3C0100            cmp [_STATE+1],0
 0BAA A010              jz L182
 0BAC           X56:
 0BAC                   .dbline 621
 0BAC           ;       {
 0BAC                   .dbline 622
 0BAC           ;               unloadConfig(STATE);
 0BAC 62D000            mov REG[0xd0],>_STATE
 0BAF 5100              mov A,[_STATE]
 0BB1 08                push A
 0BB2 5101              mov A,[_STATE+1]
 0BB4 08                push A
 0BB5 90C9              xcall _unloadConfig
 0BB7 38FE              add SP,-2
 0BB9                   .dbline 623
 0BB9           ;       }
 0BB9 8003              xjmp L183
 0BBB           L182:
 0BBB                   .dbline 625
 0BBB           ;       else
 0BBB           ;       {
 0BBB                   .dbline 626
 0BBB           ;               unloadAllConfigs();
 0BBB 90B9              xcall _unloadAllConfigs
 0BBD                   .dbline 627
 0BBD           ;       }
 0BBD           L183:
 0BBD                   .dbline 629
 0BBD           ;       
 0BBD           ;       if(mode == PC_MODE)
 0BBD 3DFB00            cmp [X-5],0
 0BC0 B037              jnz L184
 0BC2 3DFC02            cmp [X-4],2
 0BC5 B032              jnz L184
 0BC7           X57:
 0BC7                   .dbline 630
 0BC7           ;       {
 0BC7                   .dbline 631
 0BC7           ;               LoadConfig_pc_listener();
 0BC7 7C0000            xcall _LoadConfig_pc_listener
 0BCA                   .dbline 633
 0BCA           ; 
 0BCA           ;               COMP_SERIAL_CmdReset();                                                 // Initialize the buffer.
 0BCA 10                push X
 0BCB 7C0000            xcall _COMP_SERIAL_CmdReset
 0BCE 20                pop X
 0BCF                   .dbline 634
 0BCF           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0BCF 10                push X
 0BD0 5001              mov A,1
 0BD2 7C0000            xcall _COMP_SERIAL_IntCntl
 0BD5 20                pop X
 0BD6                   .dbline 635
 0BD6           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0BD6 10                push X
 0BD7 5000              mov A,0
 0BD9 7C0000            xcall _COMP_SERIAL_Start
 0BDC 20                pop X
 0BDD                   .dbline 637
 0BDD           ;               
 0BDD           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0BDD 10                push X
 0BDE 5000              mov A,0
 0BE0 7C0000            xcall _TX_REPEATER_Start
 0BE3 20                pop X
 0BE4                   .dbline 639
 0BE4           ;               
 0BE4           ;               TIMEOUT = 0;
 0BE4 62D000            mov REG[0xd0],>_TIMEOUT
 0BE7 550100            mov [_TIMEOUT+1],0
 0BEA 550000            mov [_TIMEOUT],0
 0BED                   .dbline 640
 0BED           ;               STATE = PC_MODE;
 0BED 62D000            mov REG[0xd0],>_STATE
 0BF0 550102            mov [_STATE+1],2
 0BF3 550000            mov [_STATE],0
 0BF6                   .dbline 641
 0BF6           ;       }
 0BF6 807A              xjmp L185
 0BF8           L184:
 0BF8                   .dbline 642
 0BF8           ;       else if(mode == RX_MODE)
 0BF8 3DFB00            cmp [X-5],0
 0BFB B02C              jnz L186
 0BFD 3DFC01            cmp [X-4],1
 0C00 B027              jnz L186
 0C02           X58:
 0C02                   .dbline 643
 0C02           ;       {
 0C02                   .dbline 644
 0C02           ;               LoadConfig_receiver_config();
 0C02 7C0000            xcall _LoadConfig_receiver_config
 0C05                   .dbline 647
 0C05           ;               
 0C05           ;               // Start the receiver.
 0C05           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0C05 10                push X
 0C06 5000              mov A,0
 0C08 7C0000            xcall _RECEIVE_Start
 0C0B 20                pop X
 0C0C                   .dbline 650
 0C0C           ;               
 0C0C           ;               // Start response timeout timer and enable its interrupt routine.
 0C0C           ;               TIMEOUT = 0;
 0C0C 62D000            mov REG[0xd0],>_TIMEOUT
 0C0F 550100            mov [_TIMEOUT+1],0
 0C12 550000            mov [_TIMEOUT],0
 0C15                   .dbline 651
 0C15           ;               RX_TIMEOUT_EnableInt();
 0C15 10                push X
 0C16 7C0000            xcall _RX_TIMEOUT_EnableInt
 0C19                   .dbline 652
 0C19           ;               RX_TIMEOUT_Start();
 0C19 7C0000            xcall _RX_TIMEOUT_Start
 0C1C 20                pop X
 0C1D                   .dbline 654
 0C1D           ;               
 0C1D           ;               STATE = RX_MODE;
 0C1D 62D000            mov REG[0xd0],>_STATE
 0C20 550101            mov [_STATE+1],1
 0C23 550000            mov [_STATE],0
 0C26                   .dbline 655
 0C26           ;       }
 0C26 804A              xjmp L187
 0C28           L186:
 0C28                   .dbline 656
 0C28           ;       else if(mode == TX_MODE)
 0C28 3DFB00            cmp [X-5],0
 0C2B B045              jnz L188
 0C2D 3DFC00            cmp [X-4],0
 0C30 B040              jnz L188
 0C32           X59:
 0C32                   .dbline 657
 0C32           ;       {
 0C32                   .dbline 658
 0C32           ;               LoadConfig_transmitter_config();
 0C32 7C0000            xcall _LoadConfig_transmitter_config
 0C35                   .dbline 660
 0C35           ;               // Start the transmitter.
 0C35           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0C35 10                push X
 0C36 5000              mov A,0
 0C38 7C0000            xcall _TRANSMIT_Start
 0C3B 20                pop X
 0C3C                   .dbline 662
 0C3C           ;               
 0C3C           ;               TIMEOUT = 0;
 0C3C 62D000            mov REG[0xd0],>_TIMEOUT
 0C3F 550100            mov [_TIMEOUT+1],0
 0C42 550000            mov [_TIMEOUT],0
 0C45                   .dbline 663
 0C45           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0C45 10                push X
 0C46 7C0000            xcall _TX_TIMEOUT_EnableInt
 0C49                   .dbline 664
 0C49           ;               TX_TIMEOUT_Start();             // Start the timer.
 0C49 7C0000            xcall _TX_TIMEOUT_Start
 0C4C 20                pop X
 0C4D           L190:
 0C4D                   .dbline 667
 0C4D           ;               
 0C4D           ;               while(!TIMEOUT)
 0C4D           ;               {
 0C4D                   .dbline 670
 0C4D           ;                       // Do nothing while we wait for one timeout period.
 0C4D           ;                       // This is to allow everyone to get in the right configuration.
 0C4D           ;               }
 0C4D           L191:
 0C4D                   .dbline 666
 0C4D 62D000            mov REG[0xd0],>_TIMEOUT
 0C50 3C0000            cmp [_TIMEOUT],0
 0C53 B006              jnz X60
 0C55 3C0100            cmp [_TIMEOUT+1],0
 0C58 AFF4              jz L190
 0C5A           X60:
 0C5A                   .dbline 672
 0C5A           ;               
 0C5A           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0C5A 10                push X
 0C5B 7C0000            xcall _TX_TIMEOUT_Stop
 0C5E 20                pop X
 0C5F                   .dbline 673
 0C5F           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0C5F 62D000            mov REG[0xd0],>_TIMEOUT
 0C62 550100            mov [_TIMEOUT+1],0
 0C65 550000            mov [_TIMEOUT],0
 0C68                   .dbline 675
 0C68           ;               
 0C68           ;               STATE = TX_MODE;
 0C68 62D000            mov REG[0xd0],>_STATE
 0C6B 550100            mov [_STATE+1],0
 0C6E 550000            mov [_STATE],0
 0C71                   .dbline 676
 0C71           ;       }
 0C71           L188:
 0C71           L187:
 0C71           L185:
 0C71                   .dbline 679
 0C71           ;       
 0C71           ;       // Reconnect to the global bus.
 0C71           ;       PRT0GS |= 0b10111111;
 0C71 4302BF            or REG[0x2],-65
 0C74                   .dbline -2
 0C74           L181:
 0C74 20                pop X
 0C75                   .dbline 0 ; func end
 0C75 7F                ret
 0C76                   .dbsym l mode -5 I
 0C76                   .dbend
 0C76                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C76           _unloadAllConfigs::
 0C76                   .dbline -1
 0C76                   .dbline 685
 0C76           ; }
 0C76           ; 
 0C76           ; // This function blindly unloads all user configurations. This will be called once,
 0C76           ; // when the system initially has no known state.
 0C76           ; void unloadAllConfigs(void)
 0C76           ; {
 0C76                   .dbline 686
 0C76           ;       UnloadConfig_pc_listener();
 0C76 7C0000            xcall _UnloadConfig_pc_listener
 0C79                   .dbline 687
 0C79           ;       UnloadConfig_receiver_config();
 0C79 7C0000            xcall _UnloadConfig_receiver_config
 0C7C                   .dbline 688
 0C7C           ;       UnloadConfig_transmitter_config();
 0C7C 7C0000            xcall _UnloadConfig_transmitter_config
 0C7F                   .dbline -2
 0C7F           L193:
 0C7F                   .dbline 0 ; func end
 0C7F 7F                ret
 0C80                   .dbend
 0C80                   .dbfunc e unloadConfig _unloadConfig fV
 0C80           ;     config_num -> X-5
 0C80           _unloadConfig::
 0C80                   .dbline -1
 0C80 10                push X
 0C81 4F                mov X,SP
 0C82                   .dbline 694
 0C82           ; }
 0C82           ; 
 0C82           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C82           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C82           ; void unloadConfig(int config_num)
 0C82           ; {
 0C82                   .dbline 695
 0C82           ;       if(config_num == PC_MODE)
 0C82 3DFB00            cmp [X-5],0
 0C85 B00B              jnz L195
 0C87 3DFC02            cmp [X-4],2
 0C8A B006              jnz L195
 0C8C           X61:
 0C8C                   .dbline 696
 0C8C           ;       {
 0C8C                   .dbline 697
 0C8C           ;               UnloadConfig_pc_listener();
 0C8C 7C0000            xcall _UnloadConfig_pc_listener
 0C8F                   .dbline 698
 0C8F           ;       }
 0C8F 801D              xjmp L196
 0C91           L195:
 0C91                   .dbline 699
 0C91           ;       else if(config_num == RX_MODE)
 0C91 3DFB00            cmp [X-5],0
 0C94 B00B              jnz L197
 0C96 3DFC01            cmp [X-4],1
 0C99 B006              jnz L197
 0C9B           X62:
 0C9B                   .dbline 700
 0C9B           ;       {
 0C9B                   .dbline 701
 0C9B           ;               UnloadConfig_receiver_config();
 0C9B 7C0000            xcall _UnloadConfig_receiver_config
 0C9E                   .dbline 702
 0C9E           ;       }
 0C9E 800E              xjmp L198
 0CA0           L197:
 0CA0                   .dbline 703
 0CA0           ;       else if(config_num == TX_MODE)
 0CA0 3DFB00            cmp [X-5],0
 0CA3 B009              jnz L199
 0CA5 3DFC00            cmp [X-4],0
 0CA8 B004              jnz L199
 0CAA           X63:
 0CAA                   .dbline 704
 0CAA           ;       {
 0CAA                   .dbline 705
 0CAA           ;               UnloadConfig_transmitter_config();
 0CAA 7C0000            xcall _UnloadConfig_transmitter_config
 0CAD                   .dbline 706
 0CAD           ;       }
 0CAD           L199:
 0CAD           L198:
 0CAD           L196:
 0CAD                   .dbline -2
 0CAD           L194:
 0CAD 20                pop X
 0CAE                   .dbline 0 ; func end
 0CAE 7F                ret
 0CAF                   .dbsym l config_num -5 I
 0CAF                   .dbend
 0CAF                   .dbfunc e initializeChildren _initializeChildren fV
 0CAF           ;              i -> X+4
 0CAF           ;        currVal -> X+2
 0CAF           ;        maxPrev -> X+0
 0CAF           _initializeChildren::
 0CAF                   .dbline -1
 0CAF 10                push X
 0CB0 4F                mov X,SP
 0CB1 3806              add SP,6
 0CB3                   .dbline 710
 0CB3           ; }
 0CB3           ; 
 0CB3           ; void initializeChildren(void)
 0CB3           ; {
 0CB3                   .dbline 711
 0CB3           ;       int maxPrev = 0;        // The maximum previous value.
 0CB3 560100            mov [X+1],0
 0CB6 560000            mov [X+0],0
 0CB9                   .dbline 713
 0CB9           ;       int currVal;            // The current number of modules found.
 0CB9           ;       int i = 0;                      // An int for looping.
 0CB9 560500            mov [X+5],0
 0CBC 560400            mov [X+4],0
 0CBF 8028              xjmp L203
 0CC1           L202:
 0CC1                   .dbline 717
 0CC1           ;       
 0CC1           ;       // Find a value higher than the previously stored number of modules.
 0CC1           ;       while(maxPrev < PREV_NUM_MODULES)
 0CC1           ;       {
 0CC1                   .dbline 718
 0CC1           ;               currVal = initSweep();
 0CC1 9063              xcall _initSweep
 0CC3 62D000            mov REG[0xd0],>__r0
 0CC6 5100              mov A,[__r1]
 0CC8 5403              mov [X+3],A
 0CCA 5100              mov A,[__r0]
 0CCC 5402              mov [X+2],A
 0CCE                   .dbline 720
 0CCE           ;               
 0CCE           ;               if(currVal > maxPrev)
 0CCE 5201              mov A,[X+1]
 0CD0 1303              sub A,[X+3]
 0CD2 5202              mov A,[X+2]
 0CD4 3180              xor A,-128
 0CD6 5300              mov [__rX],A
 0CD8 5200              mov A,[X+0]
 0CDA 3180              xor A,-128
 0CDC 1A00              sbb A,[__rX]
 0CDE D009              jnc L205
 0CE0           X64:
 0CE0                   .dbline 721
 0CE0           ;               {
 0CE0                   .dbline 722
 0CE0           ;                       maxPrev = currVal;
 0CE0 5203              mov A,[X+3]
 0CE2 5401              mov [X+1],A
 0CE4 5202              mov A,[X+2]
 0CE6 5400              mov [X+0],A
 0CE8                   .dbline 723
 0CE8           ;               }
 0CE8           L205:
 0CE8                   .dbline 724
 0CE8           ;       }
 0CE8           L203:
 0CE8                   .dbline 716
 0CE8 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0CEB 5201              mov A,[X+1]
 0CED 1201              sub A,[_PREV_NUM_MODULES+1]
 0CEF 5100              mov A,[_PREV_NUM_MODULES]
 0CF1 3180              xor A,-128
 0CF3 62D000            mov REG[0xd0],>__r0
 0CF6 5300              mov [__rX],A
 0CF8 5200              mov A,[X+0]
 0CFA 3180              xor A,-128
 0CFC 1A00              sbb A,[__rX]
 0CFE CFC2              jc L202
 0D00           X65:
 0D00                   .dbline 727
 0D00           ;       
 0D00           ;       // Store the number of modules.
 0D00           ;       NUM_MODULES = maxPrev;
 0D00 62D000            mov REG[0xd0],>_NUM_MODULES
 0D03 5201              mov A,[X+1]
 0D05 5301              mov [_NUM_MODULES+1],A
 0D07 5200              mov A,[X+0]
 0D09 5300              mov [_NUM_MODULES],A
 0D0B                   .dbline 728
 0D0B           ;       PREV_NUM_MODULES = NUM_MODULES;
 0D0B 5101              mov A,[_NUM_MODULES+1]
 0D0D 08                push A
 0D0E 5100              mov A,[_NUM_MODULES]
 0D10 62D000            mov REG[0xd0],>_PREV_NUM_MODULES
 0D13 5300              mov [_PREV_NUM_MODULES],A
 0D15 18                pop A
 0D16 5301              mov [_PREV_NUM_MODULES+1],A
 0D18                   .dbline 731
 0D18           ;       
 0D18           ;       // Switch back to PC mode.
 0D18           ;       configToggle(PC_MODE);
 0D18 5000              mov A,0
 0D1A 08                push A
 0D1B 5002              mov A,2
 0D1D 08                push A
 0D1E 9E77              xcall _configToggle
 0D20 38FE              add SP,-2
 0D22                   .dbline -2
 0D22           L201:
 0D22 38FA              add SP,-6
 0D24 20                pop X
 0D25                   .dbline 0 ; func end
 0D25 7F                ret
 0D26                   .dbsym l i 4 I
 0D26                   .dbsym l currVal 2 I
 0D26                   .dbsym l maxPrev 0 I
 0D26                   .dbend
 0D26                   .dbfunc e initSweep _initSweep fI
 0D26           ;     ping_tries -> X+6
 0D26           ;              i -> X+4
 0D26           ;   num_timeouts -> X+2
 0D26           ; currNumModules -> X+0
 0D26           _initSweep::
 0D26                   .dbline -1
 0D26 10                push X
 0D27 4F                mov X,SP
 0D28 3808              add SP,8
 0D2A                   .dbline 735
 0D2A           ; }
 0D2A           ; 
 0D2A           ; int initSweep(void)
 0D2A           ; {
 0D2A                   .dbline 736
 0D2A           ;       int i = 0;                                      // An iterator for looping.
 0D2A 560500            mov [X+5],0
 0D2D 560400            mov [X+4],0
 0D30                   .dbline 737
 0D30           ;       int num_timeouts = 0;           // The number of consecutive timeouts.
 0D30 560300            mov [X+3],0
 0D33 560200            mov [X+2],0
 0D36                   .dbline 738
 0D36           ;       int ping_tries = 5;                     // The number of times to try a ping on an unregistered module.
 0D36 560705            mov [X+7],5
 0D39 560600            mov [X+6],0
 0D3C                   .dbline 739
 0D3C           ;       int currNumModules = 0;         // The number of modules found in this current sweep.
 0D3C 560100            mov [X+1],0
 0D3F 560000            mov [X+0],0
 0D42                   .dbline 742
 0D42           ;       
 0D42           ;       // Clear the modules.
 0D42           ;       clearConfig();
 0D42 7C0193            xcall _clearConfig
 0D45 8079              xjmp L209
 0D47           L208:
 0D47                   .dbline 747
 0D47           ;       
 0D47           ;       // This loop continuously probes and listens at intervals
 0D47           ;       // set by the RX_TIMEOUT_DURATION variable.
 0D47           ;       while(num_timeouts < MAX_TIMEOUTS)
 0D47           ;       {
 0D47                   .dbline 749
 0D47           ;               // If we are not maxed out on modules, look for more.
 0D47           ;               if(currNumModules < SUGGESTED_NUM_MODULES)
 0D47 62D000            mov REG[0xd0],>_SUGGESTED_NUM_MODULES
 0D4A 5201              mov A,[X+1]
 0D4C 1201              sub A,[_SUGGESTED_NUM_MODULES+1]
 0D4E 5100              mov A,[_SUGGESTED_NUM_MODULES]
 0D50 3180              xor A,-128
 0D52 62D000            mov REG[0xd0],>__r0
 0D55 5300              mov [__rX],A
 0D57 5200              mov A,[X+0]
 0D59 3180              xor A,-128
 0D5B 1A00              sbb A,[__rX]
 0D5D D006              jnc L211
 0D5F           X66:
 0D5F                   .dbline 750
 0D5F           ;               {
 0D5F                   .dbline 751
 0D5F           ;                       sayHello();
 0D5F 7C01FA            xcall _sayHello
 0D62                   .dbline 752
 0D62           ;               }
 0D62 8007              xjmp L212
 0D64           L211:
 0D64                   .dbline 754
 0D64           ;               else
 0D64           ;               {
 0D64                   .dbline 755
 0D64           ;                       num_timeouts = MAX_TIMEOUTS;
 0D64 560332            mov [X+3],50
 0D67 560200            mov [X+2],0
 0D6A                   .dbline 756
 0D6A           ;               }
 0D6A           L212:
 0D6A                   .dbline 758
 0D6A           ;                       
 0D6A           ;               if(validResponse())
 0D6A 7C0252            xcall _validResponse
 0D6D 62D000            mov REG[0xd0],>__r0
 0D70 3C0000            cmp [__r0],0
 0D73 B006              jnz X67
 0D75 3C0000            cmp [__r1],0
 0D78 A041              jz L213
 0D7A           X67:
 0D7A                   .dbline 759
 0D7A           ;               {
 0D7A                   .dbline 760
 0D7A           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0D7A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0D7D 3C00C8            cmp [_COMMAND_TYPE],-56
 0D80 B03E              jnz L214
 0D82                   .dbline 761
 0D82           ;                       {
 0D82                   .dbline 763
 0D82           ;                               // If this is for me, assign them an ID.
 0D82           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0D82 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D85 3C0000            cmp [_COMMAND_DESTINATION],0
 0D88 B036              jnz L214
 0D8A                   .dbline 764
 0D8A           ;                               {
 0D8A                   .dbline 765
 0D8A           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D8A 560300            mov [X+3],0
 0D8D 560200            mov [X+2],0
 0D90                   .dbline 767
 0D90           ;               
 0D90           ;                                       if(assignID(currNumModules+1))
 0D90 62D000            mov REG[0xd0],>__r0
 0D93 5201              mov A,[X+1]
 0D95 0101              add A,1
 0D97 5300              mov [__r1],A
 0D99 5200              mov A,[X+0]
 0D9B 0900              adc A,0
 0D9D 08                push A
 0D9E 5100              mov A,[__r1]
 0DA0 08                push A
 0DA1 7C00E9            xcall _assignID
 0DA4 38FE              add SP,-2
 0DA6 62D000            mov REG[0xd0],>__r0
 0DA9 3C0000            cmp [__r0],0
 0DAC B006              jnz X68
 0DAE 3C0000            cmp [__r1],0
 0DB1 A00D              jz L214
 0DB3           X68:
 0DB3                   .dbline 768
 0DB3           ;                                       {
 0DB3                   .dbline 769
 0DB3           ;                                               currNumModules++;               // Increment the number of modules connected.
 0DB3 7701              inc [X+1]
 0DB5 0F0000            adc [X+0],0
 0DB8                   .dbline 770
 0DB8           ;                                       }
 0DB8                   .dbline 771
 0DB8           ;                               }
 0DB8                   .dbline 772
 0DB8           ;                       }
 0DB8                   .dbline 773
 0DB8           ;               }
 0DB8 8006              xjmp L214
 0DBA           L213:
 0DBA                   .dbline 775
 0DBA           ;               else
 0DBA           ;               {       
 0DBA                   .dbline 776
 0DBA           ;                       num_timeouts++;
 0DBA 7703              inc [X+3]
 0DBC 0F0200            adc [X+2],0
 0DBF                   .dbline 777
 0DBF           ;               }
 0DBF           L214:
 0DBF                   .dbline 778
 0DBF           ;       }
 0DBF           L209:
 0DBF                   .dbline 746
 0DBF 5203              mov A,[X+3]
 0DC1 1132              sub A,50
 0DC3 5202              mov A,[X+2]
 0DC5 3180              xor A,-128
 0DC7 1980              sbb A,(0 ^ 0x80)
 0DC9 CF7D              jc L208
 0DCB           X69:
 0DCB                   .dbline 781
 0DCB           ;       
 0DCB           ;       // If we didn't find any new modules, check to see if some already exist.
 0DCB           ;       if(!currNumModules)
 0DCB 3D0000            cmp [X+0],0
 0DCE B056              jnz L221
 0DD0 3D0100            cmp [X+1],0
 0DD3 B051              jnz L221
 0DD5           X70:
 0DD5                   .dbline 782
 0DD5           ;       {
 0DD5                   .dbline 784
 0DD5           ;               // Try to ping the next module up from our current number ping_tries times.
 0DD5           ;               for(i = 0; i < ping_tries; i++)
 0DD5 560500            mov [X+5],0
 0DD8 560400            mov [X+4],0
 0DDB 8034              xjmp L226
 0DDD           L223:
 0DDD                   .dbline 785
 0DDD           ;               {       
 0DDD                   .dbline 786
 0DDD           ;                       if(pingModule(currNumModules+1))
 0DDD 62D000            mov REG[0xd0],>__r0
 0DE0 5201              mov A,[X+1]
 0DE2 0101              add A,1
 0DE4 5300              mov [__r1],A
 0DE6 5200              mov A,[X+0]
 0DE8 0900              adc A,0
 0DEA 08                push A
 0DEB 5100              mov A,[__r1]
 0DED 08                push A
 0DEE 7C0046            xcall _pingModule
 0DF1 38FE              add SP,-2
 0DF3 62D000            mov REG[0xd0],>__r0
 0DF6 3C0000            cmp [__r0],0
 0DF9 B006              jnz X71
 0DFB 3C0000            cmp [__r1],0
 0DFE A00C              jz L227
 0E00           X71:
 0E00                   .dbline 787
 0E00           ;                       {
 0E00                   .dbline 788
 0E00           ;                               currNumModules++;
 0E00 7701              inc [X+1]
 0E02 0F0000            adc [X+0],0
 0E05                   .dbline 789
 0E05           ;                               i = 0;
 0E05 560500            mov [X+5],0
 0E08 560400            mov [X+4],0
 0E0B                   .dbline 790
 0E0B           ;                       }
 0E0B           L227:
 0E0B                   .dbline 791
 0E0B           ;               }
 0E0B           L224:
 0E0B                   .dbline 784
 0E0B 7705              inc [X+5]
 0E0D 0F0400            adc [X+4],0
 0E10           L226:
 0E10                   .dbline 784
 0E10 5205              mov A,[X+5]
 0E12 1307              sub A,[X+7]
 0E14 5206              mov A,[X+6]
 0E16 3180              xor A,-128
 0E18 62D000            mov REG[0xd0],>__r0
 0E1B 5300              mov [__rX],A
 0E1D 5204              mov A,[X+4]
 0E1F 3180              xor A,-128
 0E21 1A00              sbb A,[__rX]
 0E23 CFB9              jc L223
 0E25           X72:
 0E25                   .dbline 792
 0E25           ;       }
 0E25           L221:
 0E25                   .dbline 794
 0E25           ;       
 0E25           ;       return currNumModules;
 0E25 62D000            mov REG[0xd0],>__r0
 0E28 5201              mov A,[X+1]
 0E2A 5300              mov [__r1],A
 0E2C 5200              mov A,[X+0]
 0E2E 5300              mov [__r0],A
 0E30                   .dbline -2
 0E30           L207:
 0E30 38F8              add SP,-8
 0E32 20                pop X
 0E33                   .dbline 0 ; func end
 0E33 7F                ret
 0E34                   .dbsym l ping_tries 6 I
 0E34                   .dbsym l i 4 I
 0E34                   .dbsym l num_timeouts 2 I
 0E34                   .dbsym l currNumModules 0 I
 0E34                   .dbend
 0E34                   .dbfunc e xmitWait _xmitWait fV
 0E34           ;              i -> X+0
 0E34           _xmitWait::
 0E34                   .dbline -1
 0E34 10                push X
 0E35 4F                mov X,SP
 0E36 3802              add SP,2
 0E38                   .dbline 798
 0E38           ; }
 0E38           ; 
 0E38           ; void xmitWait(void)
 0E38           ; {
 0E38                   .dbline 801
 0E38           ;       int i;
 0E38           ;       
 0E38           ;       for(i = 0; i < 25; i++)
 0E38 560100            mov [X+1],0
 0E3B 560000            mov [X+0],0
 0E3E           L230:
 0E3E                   .dbline 802
 0E3E           ;       {
 0E3E                   .dbline 804
 0E3E           ;               // Sit here and spin for about 50 microseconds.
 0E3E           ;       }
 0E3E           L231:
 0E3E                   .dbline 801
 0E3E 7701              inc [X+1]
 0E40 0F0000            adc [X+0],0
 0E43                   .dbline 801
 0E43 5201              mov A,[X+1]
 0E45 1119              sub A,25
 0E47 5200              mov A,[X+0]
 0E49 3180              xor A,-128
 0E4B 1980              sbb A,(0 ^ 0x80)
 0E4D CFF0              jc L230
 0E4F           X73:
 0E4F                   .dbline -2
 0E4F           L229:
 0E4F 38FE              add SP,-2
 0E51 20                pop X
 0E52                   .dbline 0 ; func end
 0E52 7F                ret
 0E53                   .dbsym l i 0 I
 0E53                   .dbend
 0E53                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0E53           _TX_TIMEOUT_ISR::
 0E53                   .dbline -1
 0E53 71C0              or F,-64
 0E55 08                push A
 0E56 5DD0              mov A,REG[0xd0]
 0E58 08                push A
 0E59                   .dbline 808
 0E59           ; }
 0E59           ; 
 0E59           ; void TX_TIMEOUT_ISR(void)
 0E59           ; {     
 0E59                   .dbline 809
 0E59           ;       TIMEOUT++;
 0E59 62D000            mov REG[0xd0],>_TIMEOUT
 0E5C 7601              inc [_TIMEOUT+1]
 0E5E 0E0000            adc [_TIMEOUT],0
 0E61                   .dbline 811
 0E61           ;       
 0E61           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0E61 62DAFD            mov REG[0xda],-3
 0E64                   .dbline -2
 0E64           L234:
 0E64 18                pop A
 0E65 60D0              mov REG[208],A
 0E67 18                pop A
 0E68                   .dbline 0 ; func end
 0E68 7E                reti
 0E69                   .dbend
 0E69                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0E69           _RX_TIMEOUT_ISR::
 0E69                   .dbline -1
 0E69 71C0              or F,-64
 0E6B 08                push A
 0E6C 5DD0              mov A,REG[0xd0]
 0E6E 08                push A
 0E6F                   .dbline 815
 0E6F           ; }
 0E6F           ; 
 0E6F           ; void RX_TIMEOUT_ISR(void)
 0E6F           ; {     
 0E6F                   .dbline 816
 0E6F           ;       TIMEOUT++;
 0E6F 62D000            mov REG[0xd0],>_TIMEOUT
 0E72 7601              inc [_TIMEOUT+1]
 0E74 0E0000            adc [_TIMEOUT],0
 0E77                   .dbline 818
 0E77           ;       
 0E77           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0E77 62DAFD            mov REG[0xda],-3
 0E7A                   .dbline -2
 0E7A           L235:
 0E7A 18                pop A
 0E7B 60D0              mov REG[208],A
 0E7D 18                pop A
 0E7E                   .dbline 0 ; func end
 0E7E 7E                reti
 0E7F                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _SUGGESTED_NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e SUGGESTED_NUM_MODULES _SUGGESTED_NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _PREV_NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e PREV_NUM_MODULES _PREV_NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
