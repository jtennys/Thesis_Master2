0000: 80 7F    JMP   0x0080
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0117) ; Generated by PSoC Designer 5.0.985.0
                                   (0118) ;
                                   (0119) ;@Id: boot.tpl#884 @
0004: 30       HALT                (0120) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0121) ;  FILENAME:   boot.asm
                                   (0122) ;  VERSION:    1.00
                                   (0123) ;  DATE:       05 March 2009
0008: 7E       RETI                (0124) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0125) ;  DESCRIPTION:
                                   (0126) ;  M8C Boot Code for CY8C28xxx microcontroller devices.
                                   (0127) ;
000C: 7E       RETI                (0128) ;  Copyright (C) Cypress Semiconductors 2009. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0129) ;
                                   (0130) ; NOTES:
                                   (0131) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0132) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0133) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0134) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0135) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0136) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0137) ;
                                   (0138) ;=============================================================================
                                   (0139) 
0018: 7E       RETI                (0140) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0141) include "m8c.inc"			;Part specific file
                                   (0142) include "m8ssc.inc"			;Part specific file
                                   (0143) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0144) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0145) ;--------------------------------------
                                   (0146) ; Export Declarations
                                   (0147) ;--------------------------------------
0020: 7E       RETI                (0148) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0149) export __Start
                                   (0150) IF	(TOOLCHAIN & HITECH)
0024: 7D 1C 7E LJMP  Dispatch_INTERRUPT_9(0151) ELSE
0027: 7E       RETI                (0152) export __bss_start
                                   (0153) export __data_start
                                   (0154) export __idata_start
0028: 7D 1C 54 LJMP  Dispatch_INTERRUPT_10(0155) export __func_lit_start
002B: 7E       RETI                (0156) export __text_start
                                   (0157) ENDIF
                                   (0158) export  _bGetPowerSetting
                                   (0159) export   bGetPowerSetting	
002C: 7E       RETI                (0160) 
002D: 30       HALT  
002E: 30       HALT  
002F: 30       HALT  
                                   (0161) 
                                   (0162) ;--------------------------------------
                                   (0163) ; Optimization flags
0030: 7E       RETI                (0164) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0165) ;
                                   (0166) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0167) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0168) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0169) 
                                   (0170) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 0B 5E LJMP  0x0B5E        (0171) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0172) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0173) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0174) ;
003C: 7D 0B 5F LJMP  0x0B5F        (0175) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0176) ; The C compiler will customize the startup code - it's not required here
                                   (0177) 
                                   (0178) C_LANGUAGE_SUPPORT:              equ 0
                                   (0179) ELSE
0040: 7E       RETI                (0180) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0181) ENDIF
                                   (0182) 
                                   (0183) 
0044: 7E       RETI                (0184) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0185) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0186) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0187) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0188) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0189) ;
                                   (0190) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0191) ;                invoking main
004C: 7E       RETI                (0192) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
0050: 30       HALT  
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
0054: 30       HALT  
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
0058: 30       HALT  
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
005C: 30       HALT  
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0193) ;               the time code in main starts executing.
                                   (0194) ;
                                   (0195) WAIT_FOR_32K:                    equ 1
0060: 7E       RETI                (0196) 
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0197) 
                                   (0198) 
                                   (0199) ; For historical reasons, by default the boot code uses an lcall instruction
0064: 7E       RETI                (0200) ; to invoke the user's _main code. If _main executes a return instruction,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0201) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0202) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0203) ; bytes on the stack which are otherwise required for the return address. If
0068: 7E       RETI                (0204) ; this option is enabled, _main must not return. (Beginning with the 4.2
0069: 30       HALT  
006A: 30       HALT  
006B: 30       HALT  
                                   (0205) ; release, the C compiler automatically places an infinite loop at the end
                                   (0206) ; of main, rather than a return instruction.)
                                   (0207) ;
006C: 7E       RETI                (0208) ENABLE_LJMP_TO_MAIN:             equ 0
006D: 30       HALT  
006E: 30       HALT  
006F: 30       HALT  
                                   (0209) 
                                   (0210) 
                                   (0211) ;-----------------------------------------------------------------------------
0070: 7E       RETI                (0212) ; Interrupt Vector Table
0071: 30       HALT  
0072: 30       HALT  
0073: 30       HALT  
                                   (0213) ;-----------------------------------------------------------------------------
                                   (0214) ;
                                   (0215) ; Interrupt vector table entries are 4 bytes long.  Each one contains
0074: 7E       RETI                (0216) ; a jump instruction to an ISR (Interrupt Service Routine), although
0075: 30       HALT  
0076: 30       HALT  
0077: 30       HALT  
0078: 30       HALT  
0079: 30       HALT  
007A: 30       HALT  
007B: 30       HALT  
                                   (0217) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0218) ; vector jump targets are modified automatically according to the user
                                   (0219) ; modules selected. This occurs when the 'Generate Application' opera-
007C: 7E       RETI                (0220) ; tion is run causing PSoC Designer to create boot.asm and the other
007D: 30       HALT  
007E: 30       HALT  
007F: 30       HALT  
                                   (0221) ; configuration files. If you need to hard code a vector, update the
                                   (0222) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0223) ; of this file.
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) 
                                   (0226)     AREA TOP (ROM, ABS, CON)
                                   (0227) 
                                   (0228)     org   0                        ;Reset Interrupt Vector
                                   (0229) IF	(TOOLCHAIN & HITECH)
                                   (0230) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0231) ELSE
                                   (0232)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0233) ENDIF
                                   (0234) 
                                   (0235)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0236)     halt                           ;Stop execution if power falls too low
                                   (0237) 
                                   (0238)     org   08h                      ;Analog Column 0 / Decimator 0 Interrupt Vector
                                   (0239)     // call	void_handler
0080: 71 10    OR    F,16          (0240)     reti
0082: 62 E3 87 MOV   REG[227],135  (0241) 
0085: 70 EF    AND   F,239         (0242)     org   0Ch                      ;Analog Column 1 / Decimator 1 Interrupt Vector
                                   (0243)     // call	void_handler
                                   (0244)     reti
                                   (0245) 
                                   (0246)     org   10h                      ;Analog Column 2 / Decimator 2 Interrupt Vector
                                   (0247)     // call	void_handler
                                   (0248)     reti
                                   (0249) 
                                   (0250)     org   14h                      ;Analog Column 3 / Decimator 3 Interrupt Vector
0087: 41 FE FB AND   REG[254],251  (0251)     // call	void_handler
                                   (0252)     reti
                                   (0253)     
                                   (0254)     org   18h                      ;VC3 Interrupt Vector
                                   (0255)     // call	void_handler
                                   (0256)     reti
                                   (0257) 
                                   (0258)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0259)     // call	void_handler
                                   (0260)     reti
008A: 50 80    MOV   A,128         (0261) 
008C: 4E       SWAP  SP,A          (0262)     org   20h                      ;PSoC Block DBC00 Interrupt Vector
                                   (0263)     // call	void_handler
                                   (0264)     reti
                                   (0265) 
                                   (0266)     org   24h                      ;PSoC Block DBC01 Interrupt Vector
                                   (0267)     ljmp	Dispatch_INTERRUPT_9
                                   (0268)     reti
                                   (0269) 
                                   (0270)     org   28h                      ;PSoC Block DCC02 Interrupt Vector
                                   (0271)     ljmp	Dispatch_INTERRUPT_10
                                   (0272)     reti
                                   (0273) 
                                   (0274)     org   2Ch                      ;PSoC Block DCC03 Interrupt Vector
                                   (0275)     // call	void_handler
                                   (0276)     reti
                                   (0277)     
                                   (0278)     org   30h                      ;PSoC Block DBC10 Interrupt Vector
                                   (0279)     // call	void_handler
                                   (0280)     reti
                                   (0281) 
                                   (0282)     org   34h                      ;PSoC Block DBC11 Interrupt Vector
                                   (0283)     // call	void_handler
                                   (0284)     reti
                                   (0285) 
                                   (0286)     org   38h                      ;PSoC Block DCC12 Interrupt Vector
                                   (0287)     ljmp	_COMP_SERIAL_TX_ISR
                                   (0288)     reti
                                   (0289) 
                                   (0290)     org   3Ch                      ;PSoC Block DCC13 Interrupt Vector
                                   (0291)     ljmp	_COMP_SERIAL_RX_ISR
                                   (0292)     reti
                                   (0293) 
008D: 55 F8 00 MOV   [248],0       (0294) 	org   40h                      ;PSoC Block DBC20 Interrupt Vector
0090: 55 F9 00 MOV   [249],0       (0295)     // call	void_handler
                                   (0296)     reti
                                   (0297) 	
                                   (0298) 	org   44h                      ;PSoC Block DBC21 Interrupt Vector
                                   (0299)     // call	void_handler
                                   (0300)     reti
                                   (0301) 	
                                   (0302) 	org   48h                      ;PSoC Block DCC22 Interrupt Vector
                                   (0303)     // call	void_handler
                                   (0304)     reti
                                   (0305) 	
                                   (0306) 	org   4Ch                      ;PSoC Block DCC23 Interrupt Vector
                                   (0307)     // call	void_handler
                                   (0308)     reti
                                   (0309) 	 
                                   (0310)     org   60h                      ;PSoC I2C0 Interrupt Vector
                                   (0311)     // call	void_handler
                                   (0312)     reti
                                   (0313) 
                                   (0314) 	org   64h                      ;PSoC I2C1 Interrupt Vector
                                   (0315)     // call	void_handler
                                   (0316)     reti
                                   (0317) 	
0093: 71 10    OR    F,16          (0318) 	org   68h                      ;PSoC SARADC Interrupt Vector
0095: 62 E0 1A MOV   REG[224],26   (0319)     // call	void_handler
0098: 70 EF    AND   F,239         (0320)     reti
009A: 62 E3 38 MOV   REG[227],56   (0321) 	
                                   (0322) 	org   6Ch                      ;PSoC RTC Interrupt Vector
                                   (0323)     // call	void_handler
                                   (0324)     reti
                                   (0325) 	
                                   (0326) 	org   70h                      ;Analog Column 4 Interrupt Vector
                                   (0327)     // call	void_handler
                                   (0328)     reti
                                   (0329) 	
                                   (0330) 	org   74h                      ;Analog Column 5 Interrupt Vector
                                   (0331)     // call	void_handler
                                   (0332)     reti
                                   (0333) 	
                                   (0334)     org   7Ch                      ;Sleep Timer Interrupt Vector
                                   (0335)     // call	void_handler
                                   (0336)     reti
                                   (0337) 
                                   (0338) ;-----------------------------------------------------------------------------
                                   (0339) ;  Start of Execution.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0342) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0343) ;
                                   (0344) 
                                   (0345) IF	(TOOLCHAIN & HITECH)
                                   (0346)  	AREA PD_startup(CODE, REL, CON)
                                   (0347) ELSE
                                   (0348)     org 80h
                                   (0349) ENDIF
                                   (0350) __Start:
                                   (0351) 
009D: 62 71 05 MOV   REG[113],5    (0352)     ; initialize SMP values for voltage stabilization, if required,
00A0: 62 72 05 MOV   REG[114],5    (0353)     ; leaving power-on reset (POR) level at the default (low) level, at
00A3: 62 73 05 MOV   REG[115],5    (0354)     ; least for now. 
00A6: 62 74 05 MOV   REG[116],5    (0355)     ;
                                   (0356)     M8C_SetBank1
                                   (0357)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0358)     M8C_SetBank0
                                   (0359) 
                                   (0360) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0361)     M8C_EnableWatchDog
                                   (0362) ENDIF
                                   (0363) 
                                   (0364) IF ( SELECT_32K )
                                   (0365)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0366) ELSE
                                   (0367)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0368) ENDIF
                                   (0369) 
                                   (0370)     ;---------------------------
                                   (0371)     ; Set up the Temporary stack
                                   (0372)     ;---------------------------
                                   (0373)     ; A temporary stack is set up for the SSC instructions.
                                   (0374)     ; The real stack start will be assigned later.
                                   (0375)     ;
                                   (0376) _stack_start:          equ 80h
                                   (0377)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0378)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0379) 
                                   (0380)     ;------------------------
                                   (0381)     ; Set Power-related Trim 
                                   (0382)     ;------------------------
                                   (0383) 
00A9: 62 D1 03 MOV   REG[209],3    (0384) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00AC: 50 00    MOV   A,0           (0385)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00AE: 4E       SWAP  SP,A          (0386)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00AF: 62 D3 03 MOV   REG[211],3    (0387)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00B2: 62 D0 00 MOV   REG[208],0    (0388) ELSE
00B5: 62 D5 00 MOV   REG[213],0    (0389) 	IF ( AGND_BYPASS )
00B8: 62 D4 00 MOV   REG[212],0    (0390)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0391)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0392)     ; bit in the write-only BDG_TR register. Recalculate the register
00BB: 71 C0    OR    F,192         (0393)     ; value using the proper trim values.
                                   (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0396)   ENDIF
                                   (0397)  ENDIF
                                   (0398) ENDIF ; 5.0 V Operation
                                   (0399) 
                                   (0400) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0401)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0402)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0403)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0404)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0405)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0406)  ENDIF
                                   (0407) ENDIF ; 3.3 Volt Operation
                                   (0408) 
                                   (0409) 
                                   (0410)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00BD: 7C 05 BB LCALL 0x05BB        (0411)     mov  [bSSC_KEYSP], 0
00C0: 70 EF    AND   F,239         (0412) 
                                   (0413)     ;---------------------------------------
                                   (0414)     ; Initialize Crystal Oscillator and PLL
                                   (0415)     ;---------------------------------------
                                   (0416) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0417)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0418)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0419)     ; is left off.  The SleepTimer period is set to 1 sec to time the wait for
                                   (0420)     ; the ECO to stabilize.
                                   (0421)     ;
                                   (0422)     M8C_SetBank1
                                   (0423)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0424)     M8C_SetBank0
                                   (0425)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0426)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0427)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0428) .WaitFor1s:
                                   (0429)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0430)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0431)                                           ;  since interrupts are not globally enabled
                                   (0432) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0433)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0434)     M8C_SetBank1
                                   (0435)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0436)     M8C_SetBank0
                                   (0437)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0438) 
                                   (0439) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0440) 
                                   (0441) IF ( PLL_MODE )
                                   (0442)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                   (0443)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
00C2: 62 D0 00 MOV   REG[208],0    (0444)     ;
                                   (0445)     M8C_SetBank1
                                   (0446)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0447)     M8C_SetBank0
                                   (0448)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0449)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                   (0450) 
00C5: 50 05    MOV   A,5           (0451) .WaitFor16ms:
00C7: 57 B9    MOV   X,185         (0452)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00C9: 08       PUSH  A             (0453)     jz   .WaitFor16ms
00CA: 28       ROMX                (0454)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00CB: 53 67    MOV   [__r0],A      (0455)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00CD: 18       POP   A             (0456)     M8C_SetBank0
00CE: 75       INC   X             (0457) 
00CF: 09 00    ADC   A,0           (0458) IF      ( WAIT_FOR_32K )
00D1: 28       ROMX                (0459) ELSE ; !( WAIT_FOR_32K )
00D2: 4B       SWAP  A,X           (0460)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
00D3: 51 67    MOV   A,[103]       (0461)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                   (0462) ENDIF ;(WAIT_FOR_32K)
00D5: 80 04    JMP   0x00DA        (0463) ENDIF ;(PLL_MODE)
                                   (0464) 
                                   (0465)     ;------------------------
                                   (0466)     ; Close CT leakage path.
                                   (0467)     ;------------------------
                                   (0468)     mov   reg[0x71], 05h
                                   (0469)     mov   reg[0x72], 05h
                                   (0470)     mov   reg[0x73], 05h
                                   (0471)     mov   reg[0x74], 05h
                                   (0472) 
                                   (0473) 
                                   (0474) 
                                   (0475) IF	(TOOLCHAIN & HITECH)
                                   (0476)     ;---------------------------------------------
                                   (0477)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0478)     ;---------------------------------------------
                                   (0479) 	global		__Lstackps
                                   (0480) 	mov     a,low __Lstackps
00D7: 75       INC   X             (0481) 	swap    a,sp
00D8: 09 00    ADC   A,0           (0482) 
                                   (0483) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0484)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0485)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0486)     RAM_SETPAGE_CUR 0
00DA: 62 E3 00 MOV   REG[227],0    (0487)     RAM_SETPAGE_MVW 0
00DD: 08       PUSH  A             (0488)     RAM_SETPAGE_MVR 0
00DE: 28       ROMX                (0489)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00DF: 60 D5    MOV   REG[213],A    (0490)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00E1: 74       INC   A             (0491)     ELSE
00E2: A0 4B    JZ    0x012E        (0492)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00E4: 18       POP   A             (0493)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00E5: 75       INC   X             (0494) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00E6: 09 00    ADC   A,0           (0495) ELSE
00E8: 08       PUSH  A             (0496)     ;---------------------------------------------
00E9: 28       ROMX                (0497)     ; ImageCraft Enter the Large Memory Model, if applicable
00EA: 53 67    MOV   [__r0],A      (0498)     ;---------------------------------------------
00EC: 18       POP   A             (0499) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00ED: 75       INC   X             (0500)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00EE: 09 00    ADC   A,0           (0501)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00F0: 08       PUSH  A             (0502)     swap  A, SP
00F1: 28       ROMX                (0503)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00F2: A0 1C    JZ    0x010F        (0504)     RAM_SETPAGE_CUR 0
00F4: 53 66    MOV   [__r1],A      (0505)     RAM_SETPAGE_MVW 0
00F6: 18       POP   A             (0506)     RAM_SETPAGE_MVR 0
                                   (0507) 
                                   (0508)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0509)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0510)   ELSE
                                   (0511)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0512)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0513) ELSE
00F7: 75       INC   X             (0514)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00F8: 09 00    ADC   A,0           (0515)     swap  SP, A
00FA: 08       PUSH  A             (0516) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00FB: 28       ROMX                (0517) ENDIF ;	TOOLCHAIN
00FC: 3F 67    MVI   [__r0],A      (0518) 
00FE: 47 67 FF TST   [103],255     (0519)     ;-------------------------
0101: B0 06    JNZ   0x0108        (0520)     ; Load Base Configuration
0103: 5D D5    MOV   A,REG[213]    (0521)     ;-------------------------
0105: 74       INC   A             (0522)     ; Load global parameter settings and load the user modules in the
0106: 60 D5    MOV   REG[213],A    (0523)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0524)     ; to minimize start up time; (2) We may still need to play with the
0108: 18       POP   A             (0525)     ; Sleep Timer.
0109: 7A 66    DEC   [__r1]        (0526)     ;
010B: BF EB    JNZ   0x00F7        (0527)     lcall LoadConfigInit
010D: 8F C9    JMP   0x00D7        (0528)     M8C_SetBank0
                                   (0529) 
                                   (0530)     ;-----------------------------------
010F: 18       POP   A             (0531)     ; Initialize C Run-Time Environment
0110: 75       INC   X             (0532)     ;-----------------------------------
0111: 09 00    ADC   A,0           (0533) IF ( C_LANGUAGE_SUPPORT )
0113: 08       PUSH  A             (0534) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0114: 28       ROMX                (0535)     mov  A,0                           ; clear the 'bss' segment to zero
0115: 53 66    MOV   [__r1],A      (0536)     mov  [__r0],<__bss_start
0117: 50 00    MOV   A,0           (0537) BssLoop:
                                   (0538)     cmp  [__r0],<__bss_end
                                   (0539)     jz   BssDone
                                   (0540)     mvi  [__r0],A
                                   (0541)     jmp  BssLoop
                                   (0542) BssDone:
0119: 3F 67    MVI   [__r0],A      (0543)     mov  A,>__idata_start              ; copy idata to data segment
011B: 47 67 FF TST   [103],255     (0544)     mov  X,<__idata_start
011E: B0 08    JNZ   0x0127        (0545)     mov  [__r0],<__data_start
0120: 5D D5    MOV   A,REG[213]    (0546) IDataLoop:
0122: 74       INC   A             (0547)     cmp  [__r0],<__data_end
0123: 60 D5    MOV   REG[213],A    (0548)     jz   C_RTE_Done
0125: 50 00    MOV   A,0           (0549)     push A
                                   (0550)     romx
0127: 7A 66    DEC   [__r1]        (0551)     mvi  [__r0],A
0129: BF EF    JNZ   0x0119        (0552)     pop  A
012B: 18       POP   A             (0553)     inc  X
012C: 8F AA    JMP   0x00D7        (0554)     adc  A,0
                                   (0555)     jmp  IDataLoop
                                   (0556) 
012E: 18       POP   A             (0557) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0558) 
                                   (0559) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0560)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0561)                                        ; to use the Virtual Register page.
                                   (0562) 
                                   (0563)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0564)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0565)     ; text segment and may have been relocated by the Code Compressor.
                                   (0566)     ;
                                   (0567)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0568)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0569)     push  A
                                   (0570)     romx                               ; get the MSB of xidata's address
                                   (0571)     mov   [__r0], A
                                   (0572)     pop   A
                                   (0573)     inc   X
                                   (0574)     adc   A, 0
                                   (0575)     romx                               ; get the LSB of xidata's address
                                   (0576)     swap  A, X
                                   (0577)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0578)                                        ;   XIData structure list in flash
                                   (0579)     jmp   .AccessStruct
                                   (0580) 
                                   (0581)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0582)     ; values of C variables. Each structure contains 3 member elements.
                                   (0583)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0584)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0585)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0586)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0587)     ; value in the second member element, an unsigned byte:
                                   (0588)     ; (1) If the value of the second element is non-zero, it represents
                                   (0589)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0590)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0591)     ; the bytes are copied to the block of RAM.
                                   (0592)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0593)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0594)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0595) 
                                   (0596) .AccessNextStructLoop:
                                   (0597)     inc   X                            ; pXIData++
                                   (0598)     adc   A, 0
                                   (0599) .AccessStruct:                         ; Entry point for first block
                                   (0600)     ;
                                   (0601)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0602)     ;
                                   (0603)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0604)     push  A
                                   (0605)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0606)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                   (0607)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0608)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0609)     pop   A                            ; restore pXIData to [A,X]
                                   (0610)     inc   X                            ; pXIData++
                                   (0611)     adc   A, 0
012F: 71 10    OR    F,16          (0612)     push  A
                                   (0613)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0614)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0615)     pop   A                            ; restore pXIData to [A,X]
                                   (0616)     inc   X                            ; pXIData++ (point to size)
                                   (0617)     adc   A, 0
                                   (0618)     push  A
                                   (0619)     romx                               ; Get the size (CPU.A <- *pXIData)
0131: 43 E3 20 OR    REG[227],32   (0620)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                   (0621)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0622)     pop   A                            ; restore pXIData to [A,X]
                                   (0623) 
                                   (0624) .CopyNextByteLoop:
0134: 70 EF    AND   F,239         (0625)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0626)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0627)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0628)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0629)     ;
                                   (0630)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0631)     adc   A, 0
                                   (0632)     push  A
                                   (0633)     romx                               ; Get the data value (CPU.A <- *pXIData)
0136: 62 E0 00 MOV   REG[224],0    (0634)     mvi   [__r0], A                    ; Transfer the data to RAM
                                   (0635)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0636)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0637)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0139: 71 10    OR    F,16          (0638)     inc   A
013B: 62 E0 1B MOV   REG[224],27   (0639)     mov   reg[ MVW_PP], A
013E: 43 E2 00 OR    REG[226],0    (0640) .CopyLoopTail:
0141: 70 EF    AND   F,239         (0641)     pop   A                            ; restore pXIData to [A,X]
                                   (0642)     dec   [__r1]                       ; End of this array in flash?
                                   (0643)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0644)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0645) 
                                   (0646) .ClearRAMBlockToZero:
0143: 62 E2 00 MOV   REG[226],0    (0647)     pop   A                            ; restore pXIData to [A,X]
                                   (0648)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0649)     adc   A, 0
                                   (0650)     push  A
                                   (0651)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0652)     mov   [__r1], A                    ; Initialize downcounter
                                   (0653)     mov   A, 0                         ; Initialize source data
                                   (0654) 
0146: 7C 0D BE LCALL _main         (0655) .ClearRAMBlockLoop:
                                   (0656)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
0149: 8F FF    JMP   0x0149        (0657)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0658)     ;
                                   (0659)     mvi   [__r0], A                    ; Clear a byte
                                   (0660)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0661)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                   (0662)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0663)     inc   A
                                   (0664)     mov   reg[ MVW_PP], A
                                   (0665)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0666) .ClearLoopTail:
                                   (0667)     dec   [__r1]                       ; Was this the last byte?
                                   (0668)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                   (0669)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                   (0670)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0671) 
                                   (0672) .C_RTE_WrapUp:
014B: 50 10    MOV   A,16          (0673)     pop   A                            ; balance stack
                                   (0674) 
0340: 71 10    OR    F,16          (0675) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL

FILE: lib\psocconfigtbl.asm
0342: 62 00 10 MOV   REG[0],16     (0322) ; Generated by PSoC Designer 5.0.985.0
0345: 62 01 EF MOV   REG[1],239    (0323) ;
0348: 70 EF    AND   F,239         (0324) include "m8c.inc"
034A: 62 03 EF MOV   REG[3],239    (0325) ;  Personalization tables 
034D: 62 02 10 MOV   REG[2],16     (0326) export LoadConfigTBL_transmitter_config_Bank1
0350: 71 10    OR    F,16          (0327) export LoadConfigTBL_transmitter_config_Bank0
0352: 62 02 00 MOV   REG[2],0      (0328) export LoadConfigTBL_transmitter_config_Ordered
0355: 62 03 00 MOV   REG[3],0      (0329) export UnloadConfigTBL_transmitter_config_Bank1
0358: 70 EF    AND   F,239         (0330) export UnloadConfigTBL_transmitter_config_Bank0
035A: 62 01 00 MOV   REG[1],0      (0331) export ReloadConfigTBL_transmitter_config_Bank1
035D: 71 10    OR    F,16          (0332) export ReloadConfigTBL_transmitter_config_Bank0
035F: 62 04 00 MOV   REG[4],0      (0333) export LoadConfigTBL_pc_listener_Bank1
0362: 62 05 FF MOV   REG[5],255    (0334) export LoadConfigTBL_pc_listener_Bank0
0365: 70 EF    AND   F,239         (0335) export UnloadConfigTBL_pc_listener_Bank1
0367: 62 07 FF MOV   REG[7],255    (0336) export UnloadConfigTBL_pc_listener_Bank0
036A: 62 06 00 MOV   REG[6],0      (0337) export LoadConfigTBL_receiver_config_Bank1
036D: 71 10    OR    F,16          (0338) export LoadConfigTBL_receiver_config_Bank0
036F: 62 06 00 MOV   REG[6],0      (0339) export UnloadConfigTBL_receiver_config_Bank1
0372: 62 07 00 MOV   REG[7],0      (0340) export UnloadConfigTBL_receiver_config_Bank0
0375: 70 EF    AND   F,239         (0341) export UnloadConfigTBL_Total_Bank1
0377: 62 05 00 MOV   REG[5],0      (0342) export UnloadConfigTBL_Total_Bank0
037A: 71 10    OR    F,16          (0343) AREA lit(rom, rel)
037C: 62 08 00 MOV   REG[8],0      (0344) LoadConfigTBL_pc_listener_Bank0:
037F: 62 09 FF MOV   REG[9],255    (0345) ;  Instance name COMP_SERIAL, User Module UART
0382: 70 EF    AND   F,239         (0346) ;       Instance name COMP_SERIAL, Block Name RX(DCC13)
0384: 62 0B FF MOV   REG[11],255   (0347) 	db		3fh, 00h		;COMP_SERIAL_RX_CONTROL_REG(DCC13CR0)
0387: 62 0A 00 MOV   REG[10],0     (0348) 	db		3dh, 00h		;COMP_SERIAL_(DCC13DR1)
038A: 71 10    OR    F,16          (0349) 	db		3eh, 00h		;COMP_SERIAL_RX_BUFFER_REG (DCC13DR2)
038C: 62 0A 00 MOV   REG[10],0     (0350) ;       Instance name COMP_SERIAL, Block Name TX(DCC12)
038F: 62 0B 00 MOV   REG[11],0     (0351) 	db		3bh, 00h		;COMP_SERIAL_TX_CONTROL_REG(DCC12CR0)
0392: 70 EF    AND   F,239         (0352) 	db		39h, 00h		;COMP_SERIAL_TX_BUFFER_REG (DCC12DR1)
0394: 62 09 00 MOV   REG[9],0      (0353) 	db		3ah, 00h		;COMP_SERIAL_(DCC12DR2)
0397: 71 10    OR    F,16          (0354) ;  Instance name TX_REPEATER, User Module TX8
0399: 62 0C 00 MOV   REG[12],0     (0355) ;       Instance name TX_REPEATER, Block Name TX8(DCC02)
039C: 62 0D 00 MOV   REG[13],0     (0356) 	db		2bh, 00h		;TX_REPEATER_CONTROL_REG  (DCC02CR0)
039F: 70 EF    AND   F,239         (0357) 	db		29h, 00h		;TX_REPEATER_TX_BUFFER_REG(DCC02DR1)
03A1: 62 0F 00 MOV   REG[15],0     (0358) 	db		2ah, 00h		;TX_REPEATER_(DCC02DR2)
03A4: 62 0E 00 MOV   REG[14],0     (0359) 	db		ffh
03A7: 71 10    OR    F,16          (0360) LoadConfigTBL_pc_listener_Bank1:
03A9: 62 0E 00 MOV   REG[14],0     (0361) ;  Instance name COMP_SERIAL, User Module UART
03AC: 62 0F 00 MOV   REG[15],0     (0362) ;       Instance name COMP_SERIAL, Block Name RX(DCC13)
03AF: 70 EF    AND   F,239         (0363) 	db		3fh, 00h		;COMP_SERIAL_(DCC13CR1)
03B1: 62 0D 00 MOV   REG[13],0     (0364) 	db		3ch, 05h		;COMP_SERIAL_RX_FUNC_REG   (DCC13FN)
03B4: 71 10    OR    F,16          (0365) 	db		3dh, f6h		;COMP_SERIAL_RX_INPUT_REG  (DCC13IN)
03B6: 62 10 00 MOV   REG[16],0     (0366) 	db		3eh, 80h		;COMP_SERIAL_RX_OUTPUT_REG (DCC13OU)
03B9: 62 11 00 MOV   REG[17],0     (0367) ;       Instance name COMP_SERIAL, Block Name TX(DCC12)
03BC: 70 EF    AND   F,239         (0368) 	db		3bh, 00h		;COMP_SERIAL_(DCC12CR1)
03BE: 62 13 00 MOV   REG[19],0     (0369) 	db		38h, 1dh		;COMP_SERIAL_TX_FUNC_REG   (DCC12FN)
03C1: 62 12 00 MOV   REG[18],0     (0370) 	db		39h, 06h		;COMP_SERIAL_TX_INPUT_REG  (DCC12IN)
03C4: 71 10    OR    F,16          (0371) 	db		3ah, 85h		;COMP_SERIAL_TX_OUTPUT_REG (DCC12OU)
03C6: 62 12 00 MOV   REG[18],0     (0372) ;  Instance name TX_REPEATER, User Module TX8
03C9: 62 13 00 MOV   REG[19],0     (0373) ;       Instance name TX_REPEATER, Block Name TX8(DCC02)
03CC: 70 EF    AND   F,239         (0374) 	db		2bh, 00h		;TX_REPEATER_(DCC02CR1)
03CE: 62 11 00 MOV   REG[17],0     (0375) 	db		28h, 1dh		;TX_REPEATER_FUNC_REG     (DCC02FN)
03D1: 62 15 00 MOV   REG[21],0     (0376) 	db		29h, 01h		;TX_REPEATER_INPUT_REG    (DCC02IN)
03D4: 62 16 00 MOV   REG[22],0     (0377) 	db		2ah, 84h		;TX_REPEATER_OUTPUT_REG   (DCC02OU)
03D7: 62 17 00 MOV   REG[23],0     (0378) 	db		ffh
03DA: 71 10    OR    F,16          (0379) UnloadConfigTBL_pc_listener_Bank0:
03DC: 62 15 00 MOV   REG[21],0     (0380) ;  Instance name COMP_SERIAL, User Module UART
03DF: 62 14 00 MOV   REG[20],0     (0381) ;       Instance name COMP_SERIAL, Block Name RX(DCC13)
03E2: 62 16 00 MOV   REG[22],0     (0382) 	db		3fh, 00h		;COMP_SERIAL_CONTROL_0 (DCC13CR0)
03E5: 62 17 00 MOV   REG[23],0     (0383) ;       Instance name COMP_SERIAL, Block Name TX(DCC12)
05BB: 62 D0 00 MOV   REG[208],0    (0384) 	db		3bh, 00h		;COMP_SERIAL_CONTROL_0 (DCC12CR0)

FILE: lib\psocconfig.asm
05BE: 55 02 00 MOV   [2],0         (0074) ; Generated by PSoC Designer 5.0.985.0
                                   (0075) ;
05C1: 7C 05 C8 LCALL 0x05C8        (0076) INCLUDE "PSoCDynamic.inc"
05C4: 7C 03 40 LCALL 0x0340        (0077) ;==========================================================================
                                   (0078) ;  PSoCConfig.asm
                                   (0079) ;  @PSOC_VERSION
                                   (0080) ;
05C7: 7F       RET                 (0081) ;  Version: 0.85
                                   (0082) ;  Revised: June 22, 2004
                                   (0083) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0084) ;
                                   (0085) ;  This file is generated by the Device Editor on Application Generation.
                                   (0086) ;  It contains code which loads the configuration data table generated in
                                   (0087) ;  the file PSoCConfigTBL.asm
                                   (0088) ;
                                   (0089) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0090) ;  Edits to this file will not be preserved.
                                   (0091) ;==========================================================================
                                   (0092) ;
                                   (0093) include "m8c.inc"
                                   (0094) include "memory.inc"
                                   (0095) include "GlobalParams.inc"
                                   (0096) 
                                   (0097) export LoadConfigInit
                                   (0098) export _LoadConfigInit
                                   (0099) export LoadConfig_transmitter_config
                                   (0100) export _LoadConfig_transmitter_config
                                   (0101) export UnloadConfig_transmitter_config
                                   (0102) export _UnloadConfig_transmitter_config
                                   (0103) export ReloadConfig_transmitter_config
                                   (0104) export _ReloadConfig_transmitter_config
05C8: 71 10    OR    F,16          (0105) export LoadConfig_pc_listener
                                   (0106) export _LoadConfig_pc_listener
05CA: 10       PUSH  X             (0107) export UnloadConfig_pc_listener
05CB: 70 EF    AND   F,239         (0108) export _UnloadConfig_pc_listener
05CD: 50 00    MOV   A,0           (0109) export LoadConfig_receiver_config
05CF: 67       ASR   A             (0110) export _LoadConfig_receiver_config
                                   (0111) export UnloadConfig_receiver_config
05D0: 50 02    MOV   A,2           (0112) export _UnloadConfig_receiver_config
05D2: 57 2A    MOV   X,42          (0113) export UnloadConfig_Total
05D4: 7C 07 53 LCALL 0x0753        (0114) export _UnloadConfig_Total
                                   (0115) export ACTIVE_CONFIG_STATUS
05D7: 50 01    MOV   A,1           (0116) 
05D9: 67       ASR   A             (0117) export NO_SHADOW
                                   (0118) export _NO_SHADOW
05DA: 50 02    MOV   A,2           (0119) 
05DC: 57 9F    MOV   X,159         (0120) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
05DE: 7C 07 53 LCALL 0x0753        (0121) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0122) 
05E1: 62 D0 00 MOV   REG[208],0    (0123) AREA psoc_config(rom, rel)
                                   (0124) 
05E4: 2E 02 01 OR    [2],1         (0125) ;---------------------------------------------------------------------------
05E7: 70 EF    AND   F,239         (0126) ; LoadConfigInit - Establish the start-up configuration (except for a few
05E9: 20       POP   X             (0127) ;                  parameters handled by boot code, like CPU speed). This
                                   (0128) ;                  function can be called from user code, but typically it
                                   (0129) ;                  is only called from boot.
05EA: 7F       RET                 (0130) ;
                                   (0131) ;       INPUTS: None.
                                   (0132) ;      RETURNS: Nothing.
                                   (0133) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0134) ;               In the large memory model currently only the page
                                   (0135) ;               pointer registers listed below are modified.  This does
                                   (0136) ;               not guarantee that in future implementations of this
                                   (0137) ;               function other page pointer registers will not be
                                   (0138) ;               modified.
                                   (0139) ;          
                                   (0140) ;               Page Pointer Registers Modified: 
                                   (0141) ;               CUR_PP
                                   (0142) ;
                                   (0143) _LoadConfigInit:
                                   (0144)  LoadConfigInit:
                                   (0145)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0146)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0147) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0148) 
                                   (0149) 	lcall	LoadConfig_transmitter_config
                                   (0150) 	lcall	LoadConfigTBL_transmitter_config_Ordered
                                   (0151) 
                                   (0152) 
                                   (0153)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0154)     ret
05EB: 10       PUSH  X             (0155) 
05EC: 70 EF    AND   F,239         (0156) ;---------------------------------------------------------------------------
05EE: 50 00    MOV   A,0           (0157) ; Load Configuration transmitter_config
05F0: 67       ASR   A             (0158) ;
                                   (0159) ;    Load configuration registers for transmitter_config.
05F1: 50 03    MOV   A,3           (0160) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
05F3: 57 E9    MOV   X,233         (0161) ;
05F5: 7C 07 53 LCALL 0x0753        (0162) ;       INPUTS: None.
                                   (0163) ;      RETURNS: Nothing.
05F8: 50 01    MOV   A,1           (0164) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
05FA: 67       ASR   A             (0165) ;               modified as may the Page Pointer registers!
                                   (0166) ;               In the large memory model currently only the page
05FB: 50 03    MOV   A,3           (0167) ;               pointer registers listed below are modified.  This does
05FD: 57 FC    MOV   X,252         (0168) ;               not guarantee that in future implementations of this
05FF: 7C 07 53 LCALL 0x0753        (0169) ;               function other page pointer registers will not be
                                   (0170) ;               modified.
                                   (0171) ;          
0602: 62 D0 00 MOV   REG[208],0    (0172) ;               Page Pointer Registers Modified: 
0605: 2E 02 01 OR    [2],1         (0173) ;               CUR_PP
0608: 70 EF    AND   F,239         (0174) ;
060A: 20       POP   X             (0175) _LoadConfig_transmitter_config:
                                   (0176)  LoadConfig_transmitter_config:
                                   (0177)     RAM_PROLOGUE RAM_USE_CLASS_4
060B: 7F       RET                 (0178) 	M8C_SetBank1
                                   (0179) 
                                   (0180) 	push	x
                                   (0181)     M8C_SetBank0                    ; Force bank 0
                                   (0182)     mov     a, 0                    ; Specify bank 0
                                   (0183)     asr     a                       ; Store in carry flag
                                   (0184)                                     ; Load bank 0 table:
                                   (0185)     mov     A, >LoadConfigTBL_transmitter_config_Bank0
                                   (0186)     mov     X, <LoadConfigTBL_transmitter_config_Bank0
                                   (0187)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0188) 
                                   (0189)     mov     a, 1                    ; Specify bank 1
                                   (0190)     asr     a                       ; Store in carry flag
                                   (0191)                                     ; Load bank 1 table:
                                   (0192)     mov     A, >LoadConfigTBL_transmitter_config_Bank1
                                   (0193)     mov     X, <LoadConfigTBL_transmitter_config_Bank1
                                   (0194)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0195) 
                                   (0196) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0197) ; set config active bit
                                   (0198) 	or		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
                                   (0199)     M8C_SetBank0                    ; Force return to bank 0
                                   (0200) 	pop		x
                                   (0201) 
                                   (0202)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0203)     ret
060C: 10       PUSH  X             (0204) 
060D: 70 EF    AND   F,239         (0205) ;---------------------------------------------------------------------------
060F: 50 00    MOV   A,0           (0206) ; Reload Configuration transmitter_config
0611: 67       ASR   A             (0207) ;
                                   (0208) ;    Reload configuration registers for transmitter_config.
0612: 50 04    MOV   A,4           (0209) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0614: 57 15    MOV   X,21          (0210) ;
0616: 7C 07 53 LCALL 0x0753        (0211) ;       INPUTS: None.
                                   (0212) ;      RETURNS: Nothing.
0619: 50 01    MOV   A,1           (0213) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
061B: 67       ASR   A             (0214) ;               modified as may the Page Pointer registers!
                                   (0215) ;               In the large memory model currently only the page
061C: 50 04    MOV   A,4           (0216) ;               pointer registers listed below are modified.  This does
061E: 57 1C    MOV   X,28          (0217) ;               not guarantee that in future implementations of this
0620: 7C 07 53 LCALL 0x0753        (0218) ;               function other page pointer registers will not be
                                   (0219) ;               modified.
0623: 71 10    OR    F,16          (0220) ;          
0625: 70 EF    AND   F,239         (0221) ;               Page Pointer Registers Modified: 
                                   (0222) ;               CUR_PP
0627: 62 D0 00 MOV   REG[208],0    (0223) ;
062A: 26 02 FE AND   [2],254       (0224) _ReloadConfig_transmitter_config:
062D: 70 EF    AND   F,239         (0225)  ReloadConfig_transmitter_config:
062F: 20       POP   X             (0226)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0227) 
                                   (0228) 	push	x
0630: 7F       RET                 (0229)     M8C_SetBank0                    ; Force bank 0
                                   (0230)     mov     a, 0                    ; Specify bank 0
                                   (0231)     asr     a                       ; Store in carry flag
                                   (0232)                                     ; Bank 0 table address:
                                   (0233)     mov     A, >ReloadConfigTBL_transmitter_config_Bank0
                                   (0234)     mov     X, <ReloadConfigTBL_transmitter_config_Bank0
                                   (0235)     lcall   LoadConfig              ; Reload the bank 0 values
                                   (0236) 
                                   (0237)     mov     a, 1                    ; Specify bank 1
                                   (0238)     asr     a                       ; Store in carry flag
                                   (0239)                                     ; Bank 1 table address:
                                   (0240)     mov     A, >ReloadConfigTBL_transmitter_config_Bank1
                                   (0241)     mov     X, <ReloadConfigTBL_transmitter_config_Bank1
                                   (0242)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0243) 
                                   (0244) ; set config active bit
                                   (0245) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0246) 	or		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
                                   (0247)     M8C_SetBank0                    ; Force return to bank 0
                                   (0248) 	pop		x
                                   (0249) 
                                   (0250)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0251)     ret
                                   (0252) 
0631: 71 10    OR    F,16          (0253) ;---------------------------------------------------------------------------
                                   (0254) ; Unload Configuration transmitter_config
0633: 41 00 DF AND   REG[0],223    (0255) ;
0636: 43 00 20 OR    REG[0],32     (0256) ;    Reset configuration registers for transmitter_config
                                   (0257) ;    to their values as initially configured.
0639: 41 01 DF AND   REG[1],223    (0258) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0259) ;
063C: 70 EF    AND   F,239         (0260) ;       INPUTS: None.
063E: 41 03 5F AND   REG[3],95     (0261) ;      RETURNS: Nothing.
                                   (0262) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0641: 41 02 5F AND   REG[2],95     (0263) ;               modified as may the Page Pointer registers!
0644: 43 02 A0 OR    REG[2],160    (0264) ;               In the large memory model currently only the page
                                   (0265) ;               pointer registers listed below are modified.  This does
0647: 71 10    OR    F,16          (0266) ;               not guarantee that in future implementations of this
0649: 41 E1 00 AND   REG[225],0    (0267) ;               function other page pointer registers will not be
064C: 43 E1 C1 OR    REG[225],193  (0268) ;               modified.
                                   (0269) ;          
064F: 70 EF    AND   F,239         (0270) ;               Page Pointer Registers Modified: 
0651: 41 BD DF AND   REG[189],223  (0271) ;               CUR_PP
0654: 43 BD 20 OR    REG[189],32   (0272) ;
                                   (0273) _UnloadConfig_transmitter_config:
0657: 10       PUSH  X             (0274)  UnloadConfig_transmitter_config:
0658: 70 EF    AND   F,239         (0275)     RAM_PROLOGUE RAM_USE_CLASS_4
065A: 50 00    MOV   A,0           (0276) 
065C: 67       ASR   A             (0277) 	push	x
                                   (0278)     M8C_SetBank0                    ; Force bank 0
065D: 50 01    MOV   A,1           (0279)     mov     a, 0                    ; Specify bank 0
065F: 57 90    MOV   X,144         (0280)     asr     a                       ; Store in carry flag
0661: 7C 07 53 LCALL 0x0753        (0281)                                     ; Bank 0 table address:
                                   (0282)     mov     A, >UnloadConfigTBL_transmitter_config_Bank0
0664: 50 01    MOV   A,1           (0283)     mov     X, <UnloadConfigTBL_transmitter_config_Bank0
0666: 67       ASR   A             (0284)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0285) 
0667: 50 01    MOV   A,1           (0286)     mov     a, 1                    ; Specify bank 1
0669: 57 A3    MOV   X,163         (0287)     asr     a                       ; Store in carry flag
066B: 7C 07 53 LCALL 0x0753        (0288)                                     ; Bank 1 table address:
                                   (0289)     mov     A, >UnloadConfigTBL_transmitter_config_Bank1
066E: 62 D0 00 MOV   REG[208],0    (0290)     mov     X, <UnloadConfigTBL_transmitter_config_Bank1
                                   (0291)     lcall   LoadConfig              ; Unload the bank 1 values
0671: 2E 02 02 OR    [2],2         (0292) 
0674: 70 EF    AND   F,239         (0293) 	M8C_SetBank1
0676: 20       POP   X             (0294) 	M8C_SetBank0
                                   (0295) ; clear config active bit
                                   (0296) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0677: 7F       RET                 (0297) 	and		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], ~transmitter_config_BIT
                                   (0298)     M8C_SetBank0                    ; Force return to bank 0
                                   (0299) 	pop		x
                                   (0300) 
                                   (0301)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0302)     ret
                                   (0303) 
                                   (0304) ;---------------------------------------------------------------------------
                                   (0305) ; Load Configuration pc_listener
                                   (0306) ;
                                   (0307) ;    Load configuration registers for pc_listener.
                                   (0308) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0309) ;
                                   (0310) ;       INPUTS: None.
                                   (0311) ;      RETURNS: Nothing.
                                   (0312) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0313) ;               modified as may the Page Pointer registers!
                                   (0314) ;               In the large memory model currently only the page
                                   (0315) ;               pointer registers listed below are modified.  This does
                                   (0316) ;               not guarantee that in future implementations of this
                                   (0317) ;               function other page pointer registers will not be
                                   (0318) ;               modified.
                                   (0319) ;          
                                   (0320) ;               Page Pointer Registers Modified: 
                                   (0321) ;               CUR_PP
                                   (0322) ;
0678: 10       PUSH  X             (0323) _LoadConfig_pc_listener:
0679: 70 EF    AND   F,239         (0324)  LoadConfig_pc_listener:
067B: 50 00    MOV   A,0           (0325)     RAM_PROLOGUE RAM_USE_CLASS_4
067D: 67       ASR   A             (0326) 	M8C_SetBank1
                                   (0327) ; writing Port_0_DriveMode_0 register
067E: 50 01    MOV   A,1           (0328) 	and		reg[ 0h], ~20h
0680: 57 BC    MOV   X,188         (0329) 	or		reg[ 0h], 20h
0682: 7C 07 53 LCALL 0x0753        (0330) ; writing Port_0_DriveMode_1 register
                                   (0331) 	and		reg[ 1h], ~20h
0685: 50 01    MOV   A,1           (0332) ; writing Port_0_DriveMode_2 register
0687: 67       ASR   A             (0333) 	M8C_SetBank0
                                   (0334) 	and		reg[ 3h], ~a0h
0688: 50 01    MOV   A,1           (0335) ; writing Port_0_GlobalSelect register
068A: 57 C3    MOV   X,195         (0336) 	and		reg[ 2h], ~a0h
068C: 7C 07 53 LCALL 0x0753        (0337) 	or		reg[ 2h], a0h
                                   (0338) ; writing OscillatorControl_1 register
068F: 71 10    OR    F,16          (0339) 	M8C_SetBank1
                                   (0340) 	and		reg[e1h], ~ffh
0691: 41 E1 00 AND   REG[225],0    (0341) 	or		reg[e1h], c1h
0694: 43 E1 99 OR    REG[225],153  (0342) ; writing Row_1_OutputDrive_0 register
                                   (0343) 	M8C_SetBank0
0697: 70 EF    AND   F,239         (0344) 	and		reg[bdh], ~20h
0699: 41 BD DF AND   REG[189],223  (0345) 	or		reg[bdh], 20h
                                   (0346) 
069C: 41 02 5F AND   REG[2],95     (0347) 	push	x
                                   (0348)     M8C_SetBank0                    ; Force bank 0
069F: 41 03 5F AND   REG[3],95     (0349)     mov     a, 0                    ; Specify bank 0
06A2: 43 03 A0 OR    REG[3],160    (0350)     asr     a                       ; Store in carry flag
                                   (0351)                                     ; Load bank 0 table:
06A5: 71 10    OR    F,16          (0352)     mov     A, >LoadConfigTBL_pc_listener_Bank0
06A7: 41 01 DF AND   REG[1],223    (0353)     mov     X, <LoadConfigTBL_pc_listener_Bank0
06AA: 43 01 20 OR    REG[1],32     (0354)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0355) 
06AD: 41 00 DF AND   REG[0],223    (0356)     mov     a, 1                    ; Specify bank 1
06B0: 70 EF    AND   F,239         (0357)     asr     a                       ; Store in carry flag
                                   (0358)                                     ; Load bank 1 table:
06B2: 62 D0 00 MOV   REG[208],0    (0359)     mov     A, >LoadConfigTBL_pc_listener_Bank1
06B5: 26 02 FD AND   [2],253       (0360)     mov     X, <LoadConfigTBL_pc_listener_Bank1
06B8: 70 EF    AND   F,239         (0361)     lcall   LoadConfig              ; Load the bank 1 values
06BA: 20       POP   X             (0362) 
                                   (0363) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0364) ; set config active bit
06BB: 7F       RET                 (0365) 	or		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
                                   (0366)     M8C_SetBank0                    ; Force return to bank 0
                                   (0367) 	pop		x
                                   (0368) 
                                   (0369)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0370)     ret
                                   (0371) 
                                   (0372) ;---------------------------------------------------------------------------
                                   (0373) ; Unload Configuration pc_listener
                                   (0374) ;
                                   (0375) ;    Reset configuration registers for pc_listener
                                   (0376) ;    to their values as initially configured.
                                   (0377) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0378) ;
                                   (0379) ;       INPUTS: None.
                                   (0380) ;      RETURNS: Nothing.
                                   (0381) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0382) ;               modified as may the Page Pointer registers!
                                   (0383) ;               In the large memory model currently only the page
                                   (0384) ;               pointer registers listed below are modified.  This does
                                   (0385) ;               not guarantee that in future implementations of this
                                   (0386) ;               function other page pointer registers will not be
                                   (0387) ;               modified.
                                   (0388) ;          
06BC: 71 10    OR    F,16          (0389) ;               Page Pointer Registers Modified: 
                                   (0390) ;               CUR_PP
06BE: 41 00 EF AND   REG[0],239    (0391) ;
                                   (0392) _UnloadConfig_pc_listener:
06C1: 41 01 EF AND   REG[1],239    (0393)  UnloadConfig_pc_listener:
06C4: 43 01 10 OR    REG[1],16     (0394)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0395) 
06C7: 70 EF    AND   F,239         (0396) 	push	x
06C9: 41 B0 FC AND   REG[176],252  (0397)     M8C_SetBank0                    ; Force bank 0
06CC: 43 B0 01 OR    REG[176],1    (0398)     mov     a, 0                    ; Specify bank 0
                                   (0399)     asr     a                       ; Store in carry flag
06CF: 41 B5 FD AND   REG[181],253  (0400)                                     ; Bank 0 table address:
                                   (0401)     mov     A, >UnloadConfigTBL_pc_listener_Bank0
06D2: 10       PUSH  X             (0402)     mov     X, <UnloadConfigTBL_pc_listener_Bank0
06D3: 70 EF    AND   F,239         (0403)     lcall   LoadConfig              ; Unload the bank 0 values
06D5: 50 00    MOV   A,0           (0404) 
06D7: 67       ASR   A             (0405)     mov     a, 1                    ; Specify bank 1
                                   (0406)     asr     a                       ; Store in carry flag
06D8: 50 01    MOV   A,1           (0407)                                     ; Bank 1 table address:
06DA: 57 DD    MOV   X,221         (0408)     mov     A, >UnloadConfigTBL_pc_listener_Bank1
06DC: 7C 07 53 LCALL 0x0753        (0409)     mov     X, <UnloadConfigTBL_pc_listener_Bank1
                                   (0410)     lcall   LoadConfig              ; Unload the bank 1 values
06DF: 50 01    MOV   A,1           (0411) 
06E1: 67       ASR   A             (0412) 	M8C_SetBank1
                                   (0413) ; writing OscillatorControl_1 register
06E2: 50 01    MOV   A,1           (0414) 	and		reg[e1h], ~ffh
06E4: 57 F0    MOV   X,240         (0415) 	or		reg[e1h], 99h
06E6: 7C 07 53 LCALL 0x0753        (0416) ; writing Row_1_OutputDrive_0 register
                                   (0417) 	M8C_SetBank0
06E9: 62 D0 00 MOV   REG[208],0    (0418) 	and		reg[bdh], ~20h
                                   (0419) ; writing Port_0_GlobalSelect register
06EC: 2E 02 04 OR    [2],4         (0420) 	and		reg[ 2h], ~a0h
06EF: 70 EF    AND   F,239         (0421) ; writing Port_0_DriveMode_2 register
06F1: 20       POP   X             (0422) 	and		reg[ 3h], ~a0h
                                   (0423) 	or		reg[ 3h], a0h
                                   (0424) ; writing Port_0_DriveMode_1 register
06F2: 7F       RET                 (0425) 	M8C_SetBank1
                                   (0426) 	and		reg[ 1h], ~20h
                                   (0427) 	or		reg[ 1h], 20h
                                   (0428) ; writing Port_0_DriveMode_0 register
                                   (0429) 	and		reg[ 0h], ~20h
                                   (0430) 	M8C_SetBank0
                                   (0431) ; clear config active bit
                                   (0432) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0433) 	and		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], ~pc_listener_BIT
                                   (0434)     M8C_SetBank0                    ; Force return to bank 0
                                   (0435) 	pop		x
                                   (0436) 
                                   (0437)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0438)     ret
                                   (0439) 
                                   (0440) ;---------------------------------------------------------------------------
                                   (0441) ; Load Configuration receiver_config
                                   (0442) ;
                                   (0443) ;    Load configuration registers for receiver_config.
                                   (0444) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0445) ;
                                   (0446) ;       INPUTS: None.
                                   (0447) ;      RETURNS: Nothing.
                                   (0448) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0449) ;               modified as may the Page Pointer registers!
                                   (0450) ;               In the large memory model currently only the page
06F3: 10       PUSH  X             (0451) ;               pointer registers listed below are modified.  This does
06F4: 70 EF    AND   F,239         (0452) ;               not guarantee that in future implementations of this
06F6: 50 00    MOV   A,0           (0453) ;               function other page pointer registers will not be
06F8: 67       ASR   A             (0454) ;               modified.
                                   (0455) ;          
06F9: 50 02    MOV   A,2           (0456) ;               Page Pointer Registers Modified: 
06FB: 57 09    MOV   X,9           (0457) ;               CUR_PP
06FD: 7C 07 53 LCALL 0x0753        (0458) ;
                                   (0459) _LoadConfig_receiver_config:
0700: 50 01    MOV   A,1           (0460)  LoadConfig_receiver_config:
0702: 67       ASR   A             (0461)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0462) 	M8C_SetBank1
0703: 50 02    MOV   A,2           (0463) ; writing Port_0_DriveMode_0 register
0705: 57 10    MOV   X,16          (0464) 	and		reg[ 0h], ~10h
0707: 7C 07 53 LCALL 0x0753        (0465) ; writing Port_0_DriveMode_1 register
                                   (0466) 	and		reg[ 1h], ~10h
070A: 71 10    OR    F,16          (0467) 	or		reg[ 1h], 10h
                                   (0468) ; writing Row_0_InputMux register
070C: 70 EF    AND   F,239         (0469) 	M8C_SetBank0
070E: 41 B0 FC AND   REG[176],252  (0470) 	and		reg[b0h], ~ 3h
                                   (0471) 	or		reg[b0h],  1h
0711: 41 B5 FD AND   REG[181],253  (0472) ; writing Row_0_OutputDrive_0 register
0714: 43 B5 02 OR    REG[181],2    (0473) 	and		reg[b5h], ~ 2h
                                   (0474) 
0717: 71 10    OR    F,16          (0475) 	push	x
0719: 41 01 EF AND   REG[1],239    (0476)     M8C_SetBank0                    ; Force bank 0
                                   (0477)     mov     a, 0                    ; Specify bank 0
071C: 41 00 EF AND   REG[0],239    (0478)     asr     a                       ; Store in carry flag
071F: 43 00 10 OR    REG[0],16     (0479)                                     ; Load bank 0 table:
0722: 70 EF    AND   F,239         (0480)     mov     A, >LoadConfigTBL_receiver_config_Bank0
                                   (0481)     mov     X, <LoadConfigTBL_receiver_config_Bank0
0724: 62 D0 00 MOV   REG[208],0    (0482)     lcall   LoadConfig              ; Load the bank 0 values
0727: 26 02 FB AND   [2],251       (0483) 
072A: 70 EF    AND   F,239         (0484)     mov     a, 1                    ; Specify bank 1
072C: 20       POP   X             (0485)     asr     a                       ; Store in carry flag
                                   (0486)                                     ; Load bank 1 table:
                                   (0487)     mov     A, >LoadConfigTBL_receiver_config_Bank1
072D: 7F       RET                 (0488)     mov     X, <LoadConfigTBL_receiver_config_Bank1
                                   (0489)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0490) 
                                   (0491) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0492) ; set config active bit
                                   (0493) 	or		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
                                   (0494)     M8C_SetBank0                    ; Force return to bank 0
                                   (0495) 	pop		x
                                   (0496) 
                                   (0497)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0498)     ret
                                   (0499) 
                                   (0500) ;---------------------------------------------------------------------------
                                   (0501) ; Unload Configuration receiver_config
                                   (0502) ;
                                   (0503) ;    Reset configuration registers for receiver_config
                                   (0504) ;    to their values as initially configured.
                                   (0505) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0506) ;
                                   (0507) ;       INPUTS: None.
                                   (0508) ;      RETURNS: Nothing.
                                   (0509) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0510) ;               modified as may the Page Pointer registers!
                                   (0511) ;               In the large memory model currently only the page
                                   (0512) ;               pointer registers listed below are modified.  This does
                                   (0513) ;               not guarantee that in future implementations of this
072E: 10       PUSH  X             (0514) ;               function other page pointer registers will not be
072F: 70 EF    AND   F,239         (0515) ;               modified.
0731: 50 00    MOV   A,0           (0516) ;          
0733: 67       ASR   A             (0517) ;               Page Pointer Registers Modified: 
                                   (0518) ;               CUR_PP
0734: 50 04    MOV   A,4           (0519) ;
0736: 57 36    MOV   X,54          (0520) _UnloadConfig_receiver_config:
0738: 7C 07 53 LCALL 0x0753        (0521)  UnloadConfig_receiver_config:
                                   (0522)     RAM_PROLOGUE RAM_USE_CLASS_4
073B: 50 01    MOV   A,1           (0523) 
073D: 67       ASR   A             (0524) 	push	x
                                   (0525)     M8C_SetBank0                    ; Force bank 0
073E: 50 04    MOV   A,4           (0526)     mov     a, 0                    ; Specify bank 0
0740: 57 57    MOV   X,87          (0527)     asr     a                       ; Store in carry flag
0742: 7C 07 53 LCALL 0x0753        (0528)                                     ; Bank 0 table address:
                                   (0529)     mov     A, >UnloadConfigTBL_receiver_config_Bank0
0745: 71 10    OR    F,16          (0530)     mov     X, <UnloadConfigTBL_receiver_config_Bank0
0747: 70 EF    AND   F,239         (0531)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0532) 
0749: 62 D0 00 MOV   REG[208],0    (0533)     mov     a, 1                    ; Specify bank 1
074C: 55 02 00 MOV   [2],0         (0534)     asr     a                       ; Store in carry flag
074F: 70 EF    AND   F,239         (0535)                                     ; Bank 1 table address:
0751: 20       POP   X             (0536)     mov     A, >UnloadConfigTBL_receiver_config_Bank1
                                   (0537)     mov     X, <UnloadConfigTBL_receiver_config_Bank1
                                   (0538)     lcall   LoadConfig              ; Unload the bank 1 values
0752: 7F       RET                 (0539) 
                                   (0540) 	M8C_SetBank1
                                   (0541) ; writing Row_0_InputMux register
                                   (0542) 	M8C_SetBank0
                                   (0543) 	and		reg[b0h], ~ 3h
                                   (0544) ; writing Row_0_OutputDrive_0 register
                                   (0545) 	and		reg[b5h], ~ 2h
                                   (0546) 	or		reg[b5h],  2h
                                   (0547) ; writing Port_0_DriveMode_1 register
                                   (0548) 	M8C_SetBank1
                                   (0549) 	and		reg[ 1h], ~10h
                                   (0550) ; writing Port_0_DriveMode_0 register
                                   (0551) 	and		reg[ 0h], ~10h
                                   (0552) 	or		reg[ 0h], 10h
                                   (0553) 	M8C_SetBank0
                                   (0554) ; clear config active bit
                                   (0555) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0556) 	and		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], ~receiver_config_BIT
                                   (0557)     M8C_SetBank0                    ; Force return to bank 0
                                   (0558) 	pop		x
                                   (0559) 
                                   (0560)     RAM_EPILOGUE RAM_USE_CLASS_4
0753: 38 02    ADD   SP,2          (0561)     ret
0755: 10       PUSH  X             (0562) 
0756: 08       PUSH  A             (0563) ;---------------------------------------------------------------------------
0757: 4F       MOV   X,SP          (0564) ; Unload Configuration Total
0758: 56 FC 00 MOV   [X-4],0       (0565) ;
075B: D0 04    JNC   0x0760        (0566) ;    Reset configuration registers for Total
075D: 56 FC 01 MOV   [X-4],1       (0567) ;    to their values as initially configured.
                                   (0568) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0760: 18       POP   A             (0569) ;
0761: 20       POP   X             (0570) ;       INPUTS: None.
                                   (0571) ;      RETURNS: Nothing.
                                   (0572) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0762: 70 EF    AND   F,239         (0573) ;               modified as may the Page Pointer registers!
0764: 62 E3 00 MOV   REG[227],0    (0574) ;               In the large memory model currently only the page
0767: 10       PUSH  X             (0575) ;               pointer registers listed below are modified.  This does
0768: 08       PUSH  A             (0576) ;               not guarantee that in future implementations of this
0769: 28       ROMX                (0577) ;               function other page pointer registers will not be
076A: 39 FF    CMP   A,255         (0578) ;               modified.
076C: A0 1F    JZ    0x078C        (0579) ;          
076E: 4F       MOV   X,SP          (0580) ;               Page Pointer Registers Modified: 
076F: 48 FC 01 TST   [X-4],1       (0581) ;               CUR_PP
0772: A0 03    JZ    0x0776        (0582) ;
0774: 71 10    OR    F,16          (0583) _UnloadConfig_Total:
                                   (0584)  UnloadConfig_Total:
0776: 54 FD    MOV   [X-3],A       (0585)     RAM_PROLOGUE RAM_USE_CLASS_4
0778: 18       POP   A             (0586) 
0779: 20       POP   X             (0587) 	push	x
077A: 75       INC   X             (0588)     M8C_SetBank0                    ; Force bank 0
077B: 09 00    ADC   A,0           (0589)     mov     a, 0                    ; Specify bank 0
077D: 10       PUSH  X             (0590)     asr     a                       ; Store in carry flag
077E: 08       PUSH  A             (0591)                                     ; Bank 0 table address:
077F: 28       ROMX                (0592)     mov     A, >UnloadConfigTBL_Total_Bank0
0780: 4F       MOV   X,SP          (0593)     mov     X, <UnloadConfigTBL_Total_Bank0
0781: 59 FD    MOV   X,[X-3]       (0594)     lcall   LoadConfig              ; Unload the bank 0 values
0783: 61 00    MOV   REG[X+0],A    (0595) 
0785: 18       POP   A             (0596)     mov     a, 1                    ; Specify bank 1
0786: 20       POP   X             (0597)     asr     a                       ; Store in carry flag
0787: 75       INC   X             (0598)                                     ; Bank 1 table address:
0788: 09 00    ADC   A,0           (0599)     mov     A, >UnloadConfigTBL_Total_Bank1
078A: 8F D7    JMP   0x0762        (0600)     mov     X, <UnloadConfigTBL_Total_Bank1
                                   (0601)     lcall   LoadConfig              ; Unload the bank 1 values
078C: 38 FC    ADD   SP,252        (0602) 
078E: 70 3F    AND   F,63
0790: 71 C0    OR    F,192         (0603) 	M8C_SetBank1
0793: 43 E1 02 OR    REG[225],2    (0604) 	M8C_SetBank0

FILE: lib\tx_timeout.asm
                                   (0102) ;;*****************************************************************************
0796: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0797: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
079A: 7F       RET                 (0131) export  TX_TIMEOUT_EnableInt
                                   (0132) export _TX_TIMEOUT_EnableInt
                                   (0133) export  TX_TIMEOUT_DisableInt
                                   (0134) export _TX_TIMEOUT_DisableInt
                                   (0135) export  TX_TIMEOUT_Start
                                   (0136) export _TX_TIMEOUT_Start
                                   (0137) export  TX_TIMEOUT_Stop
                                   (0138) export _TX_TIMEOUT_Stop
                                   (0139) export  TX_TIMEOUT_WritePeriod
                                   (0140) export _TX_TIMEOUT_WritePeriod
                                   (0141) export  TX_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_TIMEOUT_wReadTimer
                                   (0146) export _TX_TIMEOUT_wReadTimer
                                   (0147) export  TX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
079B: 43 23 01 OR    REG[35],1     (0157) export _wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
079E: 7F       RET                 (0159) export  wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA transmitter_config_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
079F: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
07A2: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_TIMEOUT_EnableInt:
                                   (0200) _TX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
07A3: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
07A5: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
07A6: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
07A8: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_TIMEOUT_DisableInt:
                                   (0228) _TX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
07A9: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
07AB: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
07AC: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
07AE: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_TIMEOUT_Start:
                                   (0256) _TX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
07AF: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
07B1: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
07B2: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
07B4: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_TIMEOUT_Stop:
                                   (0284) _TX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_TIMEOUT_WritePeriod:
                                   (0313) _TX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_TIMEOUT_Stop to disable).
07B5: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
07B6: 38 03    ADD   SP,3          (0334) ;
07B8: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
07BA: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
07BB: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
07BD: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
07BE: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
07C0: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
07C1: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
07C3: 5D 26    MOV   A,REG[38]     (0343) ;
07C5: 54 01    MOV   [X+1],A       (0344)  TX_TIMEOUT_WriteCompareValue:
07C7: 5D 22    MOV   A,REG[34]     (0345) _TX_TIMEOUT_WriteCompareValue:
07C9: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
07CB: 50 00    MOV   A,0           (0347)    mov   reg[TX_TIMEOUT_COMPARE_LSB_REG], A
07CD: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
07D0: A0 03    JZ    0x07D4        (0349)    mov   reg[TX_TIMEOUT_COMPARE_MSB_REG], A
07D2: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
07D4: 54 00    MOV   [X+0],A       (0352) 
07D6: 70 FE    AND   F,254         (0353) .ENDSECTION
07D8: 41 23 FE AND   REG[35],254   (0354) 
07DB: 18       POP   A             (0355) 
07DC: 60 26    MOV   REG[38],A     (0356) .SECTION
07DE: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
07DF: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_TIMEOUT_wReadCompareValue
07E1: 18       POP   A             (0359) ;
07E2: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
07E4: 18       POP   A             (0361) ;     Reads the Compare registers.
07E5: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
07E6: 70 3F    AND   F,63
07E8: 71 C0    OR    F,192         (0363) ;
07EA: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
07EB: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
07ED: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
07EF: 5C       MOV   X,A           (0409) ;
07F0: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
07F4: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\tx_repeater.asm
                                   (0109) ;;*****************************************************************************
07F7: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_REPEATER.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_REPEATER.inc"
07F8: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
07FB: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_REPEATER_SetTxIntMode
                                   (0143) export  _TX_REPEATER_SetTxIntMode
                                   (0144) export   TX_REPEATER_EnableInt
                                   (0145) export  _TX_REPEATER_EnableInt
                                   (0146) export   TX_REPEATER_DisableInt
                                   (0147) export  _TX_REPEATER_DisableInt
                                   (0148) export   TX_REPEATER_Start
                                   (0149) export  _TX_REPEATER_Start
                                   (0150) export   TX_REPEATER_Stop
                                   (0151) export  _TX_REPEATER_Stop
                                   (0152) export   TX_REPEATER_SendData
                                   (0153) export  _TX_REPEATER_SendData
                                   (0154) export   TX_REPEATER_bReadTxStatus
                                   (0155) export  _TX_REPEATER_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_REPEATER_ReadTxStatus
                                   (0160) export  _bTX_REPEATER_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_REPEATER_PutSHexByte
                                   (0166) export _TX_REPEATER_PutSHexByte
                                   (0167) export  TX_REPEATER_PutSHexInt
                                   (0168) export _TX_REPEATER_PutSHexInt
                                   (0169) 
07FC: 71 10    OR    F,16          (0170) export  TX_REPEATER_CPutString
07FE: 21 01    AND   A,1           (0171) export _TX_REPEATER_CPutString
0800: A0 07    JZ    0x0808        (0172) export  TX_REPEATER_PutString
0802: 43 28 10 OR    REG[40],16    (0173) export _TX_REPEATER_PutString
0805: 70 EF    AND   F,239         (0174) export  TX_REPEATER_PutChar
                                   (0175) export _TX_REPEATER_PutChar
0807: 7F       RET                 (0176) export  TX_REPEATER_Write
                                   (0177) export _TX_REPEATER_Write
                                   (0178) export  TX_REPEATER_CWrite
0808: 41 28 EF AND   REG[40],239   (0179) export _TX_REPEATER_CWrite
080B: 70 EF    AND   F,239         (0180) export  TX_REPEATER_PutCRLF
                                   (0181) export _TX_REPEATER_PutCRLF 
080D: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_REPEATER_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
080E: 29 01    OR    A,1           (0211) ;    functions.
0810: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_REPEATER_EnableInt:
0812: 7F       RET                 (0214) _TX_REPEATER_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_REPEATER_INT_REG, TX_REPEATER_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_REPEATER_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0813: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0816: 7F       RET                 (0242)  TX_REPEATER_DisableInt:
                                   (0243) _TX_REPEATER_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_REPEATER_INT_REG, TX_REPEATER_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_REPEATER_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0817: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0819: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_REPEATER_SetTxIntMode:
                                   (0276) _TX_REPEATER_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_REPEATER_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_REPEATER_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_REPEATER_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_REPEATER_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
081A: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
081C: 7F       RET                 (0303) ;
081D: 30       HALT  
081E: 31 32    XOR   A,50
0820: 33 34    XOR   A,[X+52]
0822: 35 36    XOR   [X+54],A
0824: 37 38 39 XOR   [X+56],57
0827: 41 42 43 AND   REG[66],67
082A: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_REPEATER_Start:
                                   (0317) _TX_REPEATER_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_REPEATER_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_REPEATER_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
082D: 08       PUSH  A             (0335) ;
082E: 67       ASR   A             (0336) ;  RETURNS:  none
082F: 67       ASR   A             (0337) ;
0830: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0831: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0832: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0834: FF E7    INDEX 0x081D        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0836: 90 0F    CALL  0x0847        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0838: 18       POP   A             (0343) ;    functions.
0839: 21 0F    AND   A,15          (0344) ;
083B: FF E0    INDEX 0x081D        (0345)  TX_REPEATER_Stop:
083D: 90 08    CALL  0x0847        (0346) _TX_REPEATER_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
083F: 7F       RET                 (0348)    and   REG[TX_REPEATER_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_REPEATER_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_REPEATER_SendData:
                                   (0375) _TX_REPEATER_SendData:
0840: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0841: 9F EA    CALL  0x082D        (0377)    mov REG[TX_REPEATER_TX_BUFFER_REG], A
0843: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0844: 9F E7    CALL  0x082D        (0379)    ret
                                   (0380) .ENDSECTION
0846: 7F       RET                 (0381) 
0847: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_REPEATER_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_REPEATER_bReadTxStatus:
                                   (0405) _TX_REPEATER_bReadTxStatus:
                                   (0406)  bTX_REPEATER_ReadTxStatus:
                                   (0407) _bTX_REPEATER_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_REPEATER_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
084A: AF FC    JZ    0x0847        (0416) ;  FUNCTION NAME: TX_REPEATER_PutSHexByte
084C: 60 29    MOV   REG[41],A
                                   (0417) ;
084E: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_REPEATER_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_REPEATER_PutSHexByte:
                                   (0441) _TX_REPEATER_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_REPEATER_HEX_STR          ; Get Hex value
                                   (0450)     call  TX_REPEATER_PutChar          ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_REPEATER_HEX_STR          ; Get Hex value
                                   (0454)     call  TX_REPEATER_PutChar          ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
084F: 70 BF    AND   F,191         (0456)     ret
0851: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0853: 52 00    MOV   A,[X+0]       (0459) .SECTION
0855: A0 06    JZ    0x085C        (0460) ;-----------------------------------------------------------------------------
0857: 9F EE    CALL  0x0847        (0461) ;  FUNCTION NAME: TX_REPEATER_PutSHexInt
0859: 75       INC   X             (0462) ;
085A: 8F F8    JMP   0x0853        (0463) ;  DESCRIPTION:
085C: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
085E: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0860: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_REPEATER_PutSHexInt:
                                   (0482) _TX_REPEATER_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_REPEATER_PutSHexByte      ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_REPEATER_PutSHexByte      ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_REPEATER_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0861: 70 BF    AND   F,191         (0503) ;  RETURNS:
0863: 62 D3 03 MOV   REG[211],3    (0504) ;     none
0866: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0867: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0869: A0 1A    JZ    0x0884        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
086B: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
086D: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_REPEATER_CONTROL_REG], TX_REPEATER_TX_BUFFER_EMPTY    ; Check Tx Status
086F: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0871: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_REPEATER_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0873: 52 00    MOV   A,[X+0]       (0518)    endm
0875: 49 2B 10 TST   REG[43],16
0878: AF FC    JZ    0x0875        (0519) 
087A: 60 29    MOV   REG[41],A
087C: 4F       MOV   X,SP          (0520) 
087D: 62 D3 03 MOV   REG[211],3    (0521)  TX_REPEATER_PutChar:
0880: 77 FD    INC   [X-3]         (0522) _TX_REPEATER_PutChar:
0882: 8F E4    JMP   0x0867        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0884: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0886: 71 C0    OR    F,192         (0526)    ret
0888: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_REPEATER_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_REPEATER_PutString:
                                   (0563) _TX_REPEATER_PutString:
0889: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
088A: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
088D: B0 06    JNZ   0x0894        (0569)    call  TX_REPEATER_PutChar                ; Send character to Tx port
088F: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0892: A0 1D    JZ    0x08B0        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0894: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0895: 52 FC    MOV   A,[X-4]       (0575)    ret
0897: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0899: 28       ROMX                (0577) 
089A: 49 2B 10 TST   REG[43],16
089D: AF FC    JZ    0x089A        (0578) .SECTION
089F: 60 29    MOV   REG[41],A
08A1: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_REPEATER_Write
08A2: 07 FD 01 ADD   [X-3],1       (0581) ;
08A5: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
08A8: 17 FB 01 SUB   [X-5],1       (0585) ;
08AB: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
08AE: 8F DB    JMP   0x088A        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
08B0: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_REPEATER_Write:
                                   (0610) _TX_REPEATER_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
08B1: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
08B2: 10       PUSH  X             (0622)    ENDIF
08B3: 28       ROMX                (0623) 
08B4: A0 0B    JZ    0x08C0        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
08B6: 9F 8F    CALL  0x0847        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
08B8: 20       POP   X             (0626)    mov   A,[X]
08B9: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
08BA: 75       INC   X             (0628)    mov   X, SP
08BB: DF F5    JNC   0x08B1        (0629)    RAM_SETPAGE_IDX2STK
08BD: 74       INC   A             (0630)    inc   [X+STR_LSB]
08BE: 8F F2    JMP   0x08B1        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
08C0: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
08C2: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_REPEATER_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
08C3: 50 0D    MOV   A,13          (0663) ;
08C5: 9F 80    CALL  0x0847        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
08C7: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
08C9: 9F 7C    CALL  0x0847        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
08CD: 43 E1 04 OR    REG[225],4    (0668) 

FILE: lib\transmit.asm
                                   (0109) ;;*****************************************************************************
08D0: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TRANSMIT.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TRANSMIT.inc"
08D1: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
08D4: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TRANSMIT_SetTxIntMode
                                   (0143) export  _TRANSMIT_SetTxIntMode
                                   (0144) export   TRANSMIT_EnableInt
                                   (0145) export  _TRANSMIT_EnableInt
                                   (0146) export   TRANSMIT_DisableInt
                                   (0147) export  _TRANSMIT_DisableInt
                                   (0148) export   TRANSMIT_Start
                                   (0149) export  _TRANSMIT_Start
                                   (0150) export   TRANSMIT_Stop
                                   (0151) export  _TRANSMIT_Stop
                                   (0152) export   TRANSMIT_SendData
                                   (0153) export  _TRANSMIT_SendData
                                   (0154) export   TRANSMIT_bReadTxStatus
                                   (0155) export  _TRANSMIT_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTRANSMIT_ReadTxStatus
                                   (0160) export  _bTRANSMIT_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TRANSMIT_PutSHexByte
                                   (0166) export _TRANSMIT_PutSHexByte
                                   (0167) export  TRANSMIT_PutSHexInt
                                   (0168) export _TRANSMIT_PutSHexInt
                                   (0169) 
08D5: 71 10    OR    F,16          (0170) export  TRANSMIT_CPutString
08D7: 21 01    AND   A,1           (0171) export _TRANSMIT_CPutString
08D9: A0 07    JZ    0x08E1        (0172) export  TRANSMIT_PutString
08DB: 43 28 10 OR    REG[40],16    (0173) export _TRANSMIT_PutString
08DE: 70 EF    AND   F,239         (0174) export  TRANSMIT_PutChar
                                   (0175) export _TRANSMIT_PutChar
08E0: 7F       RET                 (0176) export  TRANSMIT_Write
                                   (0177) export _TRANSMIT_Write
                                   (0178) export  TRANSMIT_CWrite
08E1: 41 28 EF AND   REG[40],239   (0179) export _TRANSMIT_CWrite
08E4: 70 EF    AND   F,239         (0180) export  TRANSMIT_PutCRLF
                                   (0181) export _TRANSMIT_PutCRLF 
08E6: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TRANSMIT_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
08E7: 29 01    OR    A,1           (0211) ;    functions.
08E9: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TRANSMIT_EnableInt:
08EB: 7F       RET                 (0214) _TRANSMIT_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TRANSMIT_INT_REG, TRANSMIT_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TRANSMIT_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
08EC: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
08EF: 7F       RET                 (0242)  TRANSMIT_DisableInt:
                                   (0243) _TRANSMIT_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TRANSMIT_INT_REG, TRANSMIT_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TRANSMIT_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
08F0: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
08F2: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TRANSMIT_SetTxIntMode:
                                   (0276) _TRANSMIT_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TRANSMIT_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TRANSMIT_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TRANSMIT_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TRANSMIT_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
08F3: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
08F5: 7F       RET                 (0303) ;
08F6: 30       HALT  
08F7: 31 32    XOR   A,50
08F9: 33 34    XOR   A,[X+52]
08FB: 35 36    XOR   [X+54],A
08FD: 37 38 39 XOR   [X+56],57
0900: 41 42 43 AND   REG[66],67
0903: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TRANSMIT_Start:
                                   (0317) _TRANSMIT_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TRANSMIT_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TRANSMIT_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0906: 08       PUSH  A             (0335) ;
0907: 67       ASR   A             (0336) ;  RETURNS:  none
0908: 67       ASR   A             (0337) ;
0909: 67       ASR   A             (0338) ;  SIDE EFFECTS:
090A: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
090B: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
090D: FF E7    INDEX 0x08F6        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
090F: 90 0F    CALL  0x0920        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0911: 18       POP   A             (0343) ;    functions.
0912: 21 0F    AND   A,15          (0344) ;
0914: FF E0    INDEX 0x08F6        (0345)  TRANSMIT_Stop:
0916: 90 08    CALL  0x0920        (0346) _TRANSMIT_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0918: 7F       RET                 (0348)    and   REG[TRANSMIT_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TRANSMIT_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TRANSMIT_SendData:
                                   (0375) _TRANSMIT_SendData:
0919: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
091A: 9F EA    CALL  0x0906        (0377)    mov REG[TRANSMIT_TX_BUFFER_REG], A
091C: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
091D: 9F E7    CALL  0x0906        (0379)    ret
                                   (0380) .ENDSECTION
091F: 7F       RET                 (0381) 
0920: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TRANSMIT_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TRANSMIT_bReadTxStatus:
                                   (0405) _TRANSMIT_bReadTxStatus:
                                   (0406)  bTRANSMIT_ReadTxStatus:
                                   (0407) _bTRANSMIT_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TRANSMIT_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0923: AF FC    JZ    0x0920        (0416) ;  FUNCTION NAME: TRANSMIT_PutSHexByte
0925: 60 29    MOV   REG[41],A
                                   (0417) ;
0927: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TRANSMIT_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TRANSMIT_PutSHexByte:
                                   (0441) _TRANSMIT_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TRANSMIT_HEX_STR             ; Get Hex value
                                   (0450)     call  TRANSMIT_PutChar             ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TRANSMIT_HEX_STR             ; Get Hex value
                                   (0454)     call  TRANSMIT_PutChar             ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0928: 70 BF    AND   F,191         (0456)     ret
092A: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
092C: 52 00    MOV   A,[X+0]       (0459) .SECTION
092E: A0 06    JZ    0x0935        (0460) ;-----------------------------------------------------------------------------
0930: 9F EE    CALL  0x0920        (0461) ;  FUNCTION NAME: TRANSMIT_PutSHexInt
0932: 75       INC   X             (0462) ;
0933: 8F F8    JMP   0x092C        (0463) ;  DESCRIPTION:
0935: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0937: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0939: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TRANSMIT_PutSHexInt:
                                   (0482) _TRANSMIT_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TRANSMIT_PutSHexByte         ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TRANSMIT_PutSHexByte         ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TRANSMIT_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
093A: 70 BF    AND   F,191         (0503) ;  RETURNS:
093C: 62 D3 03 MOV   REG[211],3    (0504) ;     none
093F: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0940: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0942: A0 1A    JZ    0x095D        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0944: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0946: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TRANSMIT_CONTROL_REG], TRANSMIT_TX_BUFFER_EMPTY    ; Check Tx Status
0948: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
094A: 60 D3    MOV   REG[211],A    (0517)    mov REG[TRANSMIT_TX_BUFFER_REG], @Source    ; Write data to Tx Port
094C: 52 00    MOV   A,[X+0]       (0518)    endm
094E: 49 2B 10 TST   REG[43],16
0951: AF FC    JZ    0x094E        (0519) 
0953: 60 29    MOV   REG[41],A
0955: 4F       MOV   X,SP          (0520) 
0956: 62 D3 03 MOV   REG[211],3    (0521)  TRANSMIT_PutChar:
0959: 77 FD    INC   [X-3]         (0522) _TRANSMIT_PutChar:
095B: 8F E4    JMP   0x0940        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
095D: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
095F: 71 C0    OR    F,192         (0526)    ret
0961: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TRANSMIT_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TRANSMIT_PutString:
                                   (0563) _TRANSMIT_PutString:
0962: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0963: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0966: B0 06    JNZ   0x096D        (0569)    call  TRANSMIT_PutChar                   ; Send character to Tx port
0968: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
096B: A0 1D    JZ    0x0989        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
096D: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
096E: 52 FC    MOV   A,[X-4]       (0575)    ret
0970: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0972: 28       ROMX                (0577) 
0973: 49 2B 10 TST   REG[43],16
0976: AF FC    JZ    0x0973        (0578) .SECTION
0978: 60 29    MOV   REG[41],A
097A: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TRANSMIT_Write
097B: 07 FD 01 ADD   [X-3],1       (0581) ;
097E: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0981: 17 FB 01 SUB   [X-5],1       (0585) ;
0984: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0987: 8F DB    JMP   0x0963        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0989: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TRANSMIT_Write:
                                   (0610) _TRANSMIT_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
098A: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
098B: 10       PUSH  X             (0622)    ENDIF
098C: 28       ROMX                (0623) 
098D: A0 0B    JZ    0x0999        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
098F: 9F 8F    CALL  0x0920        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0991: 20       POP   X             (0626)    mov   A,[X]
0992: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0993: 75       INC   X             (0628)    mov   X, SP
0994: DF F5    JNC   0x098A        (0629)    RAM_SETPAGE_IDX2STK
0996: 74       INC   A             (0630)    inc   [X+STR_LSB]
0997: 8F F2    JMP   0x098A        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0999: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
099B: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TRANSMIT_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
099C: 50 0D    MOV   A,13          (0663) ;
099E: 9F 80    CALL  0x0920        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
09A0: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
09A2: 9F 7C    CALL  0x0920        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
09A5: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\rx_timeout.asm
                                   (0102) ;;*****************************************************************************
09A8: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: RX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "RX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
09A9: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
09AC: 7F       RET                 (0131) export  RX_TIMEOUT_EnableInt
                                   (0132) export _RX_TIMEOUT_EnableInt
                                   (0133) export  RX_TIMEOUT_DisableInt
                                   (0134) export _RX_TIMEOUT_DisableInt
                                   (0135) export  RX_TIMEOUT_Start
                                   (0136) export _RX_TIMEOUT_Start
                                   (0137) export  RX_TIMEOUT_Stop
                                   (0138) export _RX_TIMEOUT_Stop
                                   (0139) export  RX_TIMEOUT_WritePeriod
                                   (0140) export _RX_TIMEOUT_WritePeriod
                                   (0141) export  RX_TIMEOUT_WriteCompareValue
                                   (0142) export _RX_TIMEOUT_WriteCompareValue
                                   (0143) export  RX_TIMEOUT_wReadCompareValue
                                   (0144) export _RX_TIMEOUT_wReadCompareValue
                                   (0145) export  RX_TIMEOUT_wReadTimer
                                   (0146) export _RX_TIMEOUT_wReadTimer
                                   (0147) export  RX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _RX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
09AD: 43 23 01 OR    REG[35],1     (0157) export _wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
09B0: 7F       RET                 (0159) export  wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA receiver_config_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: RX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
09B1: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
09B4: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  RX_TIMEOUT_EnableInt:
                                   (0200) _RX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    RX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: RX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
09B5: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
09B7: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
09B8: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
09BA: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  RX_TIMEOUT_DisableInt:
                                   (0228) _RX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    RX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: RX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
09BB: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
09BD: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
09BE: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
09C0: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  RX_TIMEOUT_Start:
                                   (0256) _RX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    RX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: RX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
09C1: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
09C3: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
09C4: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
09C6: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  RX_TIMEOUT_Stop:
                                   (0284) _RX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    RX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: RX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  RX_TIMEOUT_WritePeriod:
                                   (0313) _RX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[RX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[RX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: RX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call RX_TIMEOUT_Stop to disable).
09C7: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
09C8: 38 03    ADD   SP,3          (0334) ;
09CA: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
09CC: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
09CD: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
09CF: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
09D0: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
09D2: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
09D3: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
09D5: 5D 26    MOV   A,REG[38]     (0343) ;
09D7: 54 01    MOV   [X+1],A       (0344)  RX_TIMEOUT_WriteCompareValue:
09D9: 5D 22    MOV   A,REG[34]     (0345) _RX_TIMEOUT_WriteCompareValue:
09DB: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
09DD: 50 00    MOV   A,0           (0347)    mov   reg[RX_TIMEOUT_COMPARE_LSB_REG], A
09DF: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
09E2: A0 03    JZ    0x09E6        (0349)    mov   reg[RX_TIMEOUT_COMPARE_MSB_REG], A
09E4: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
09E6: 54 00    MOV   [X+0],A       (0352) 
09E8: 70 FE    AND   F,254         (0353) .ENDSECTION
09EA: 41 23 FE AND   REG[35],254   (0354) 
09ED: 18       POP   A             (0355) 
09EE: 60 26    MOV   REG[38],A     (0356) .SECTION
09F0: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
09F1: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: RX_TIMEOUT_wReadCompareValue
09F3: 18       POP   A             (0359) ;
09F4: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
09F6: 18       POP   A             (0361) ;     Reads the Compare registers.
09F7: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
09F8: 70 3F    AND   F,63
09FA: 71 C0    OR    F,192         (0363) ;
09FC: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  RX_TIMEOUT_wReadCompareValue:
                                   (0374) _RX_TIMEOUT_wReadCompareValue:
                                   (0375)  wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[RX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[RX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: RX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
09FD: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
09FF: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0A01: 5C       MOV   X,A           (0409) ;
0A02: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0A05: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\receiveint.asm
0A06: 10       PUSH  X             (0104) ;;*****************************************************************************
0A07: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVEINT.asm
0A09: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0A0A: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0A0C: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0A0E: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0A0F: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0A11: B0 04    JNZ   0x0A16        (0115) 
0A13: 18       POP   A             (0116) include "m8c.inc"
0A14: 80 5E    JMP   0x0A73        (0117) include "memory.inc"
                                   (0118) include "RECEIVE.inc"
                                   (0119) 
                                   (0120) 
0A16: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0A17: 21 E0    AND   A,224         (0124) export  _RECEIVE_ISR
0A19: A0 12    JZ    0x0A2C        (0125) 
                                   (0126) 
0A1B: 2C 00    OR    [0],A         (0127) IF (RECEIVE_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_aRxBuffer
0A1D: 49 2A 00 TST   REG[42],0     (0129) export _RECEIVE_aRxBuffer
                                   (0130) export  RECEIVE_bRxCnt
0A20: 21 20    AND   A,32          (0131) export _RECEIVE_bRxCnt
0A22: A0 50    JZ    0x0A73        (0132) export  RECEIVE_fStatus
                                   (0133) export _RECEIVE_fStatus
                                   (0134) ENDIF
                                   (0135) 
0A24: 41 2B FE AND   REG[43],254   (0136) 
0A27: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0A2A: 80 48    JMP   0x0A73        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_RXBUF_ENABLE)
0A2C: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_fStatus:
                                   (0144) _RECEIVE_fStatus:      BLK  1
0A2E: 47 00 01 TST   [0],1         (0145)  RECEIVE_bRxCnt:
0A31: B0 41    JNZ   0x0A73        (0146) _RECEIVE_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_RAM(RAM,REL,CON)
0A33: 39 00    CMP   A,0           (0148)  RECEIVE_aRxBuffer:    
0A35: B0 14    JNZ   0x0A4A        (0149) _RECEIVE_aRxBuffer:    BLK RECEIVE_RX_BUFFER_SIZE
0A37: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0A3A: 62 D3 00 MOV   REG[211],0    (0152) 
0A3D: 70 3F    AND   F,63
0A3F: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0A41: 56 45 00 MOV   [X+69],0      (0154) 
0A44: 70 3F    AND   F,63
0A46: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0A48: 80 2A    JMP   0x0A73        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0A4A: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0A4D: C0 14    JC    0x0A62        (0168) 
0A4F: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0A52: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0A55: 70 3F    AND   F,63
0A57: 71 80    OR    F,128         (0172) ;------------------------
0A59: 56 45 00 MOV   [X+69],0      (0173) 
0A5C: 70 3F    AND   F,63
0A5E: 71 00    OR    F,0           (0174) 
0A60: 80 12    JMP   0x0A73        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0A62: 75       INC   X             (0179) 
0A63: 5A 01    MOV   [1],X         (0180) 
0A65: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0A66: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0A69: 70 3F    AND   F,63
0A6B: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_ISR
0A6D: 54 45    MOV   [X+69],A      (0185) ;
0A6F: 70 3F    AND   F,63
0A71: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0A73: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0A74: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0A76: 20       POP   X             (0195)    ; Insert your custom code below this banner
0A77: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0A79: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\receive.asm
                                   (0121) ;;*****************************************************************************
0A7C: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE.inc"
0A7D: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0A80: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_EnableInt
                                   (0155) export  _RECEIVE_EnableInt
                                   (0156) export   RECEIVE_DisableInt
                                   (0157) export  _RECEIVE_DisableInt
                                   (0158) export   RECEIVE_Start
                                   (0159) export  _RECEIVE_Start
                                   (0160) export   RECEIVE_Stop
                                   (0161) export  _RECEIVE_Stop
                                   (0162) export   RECEIVE_bReadRxData
                                   (0163) export  _RECEIVE_bReadRxData
                                   (0164) export   RECEIVE_bReadRxStatus
                                   (0165) export  _RECEIVE_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_ReadRxData
                                   (0170) export _bRECEIVE_ReadRxData
                                   (0171) export  bRECEIVE_ReadRxStatus
                                   (0172) export _bRECEIVE_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_cGetChar
0A81: 29 01    OR    A,1           (0179) export _RECEIVE_cGetChar
0A83: 60 2B    MOV   REG[43],A     (0180) export  RECEIVE_cReadChar
                                   (0181) export _RECEIVE_cReadChar
0A85: 7F       RET                 (0182) export  RECEIVE_iReadChar
                                   (0183) export _RECEIVE_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_CmdReset
                                   (0187) export _RECEIVE_CmdReset
                                   (0188) export  RECEIVE_bCmdCheck
                                   (0189) export _RECEIVE_bCmdCheck
                                   (0190) export  RECEIVE_bCmdLength
                                   (0191) export _RECEIVE_bCmdLength
                                   (0192) export  RECEIVE_bErrCheck
                                   (0193) export _RECEIVE_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_szGetParam
                                   (0196) export _RECEIVE_szGetParam
                                   (0197) export  RECEIVE_szGetRestOfParams
                                   (0198) export _RECEIVE_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0A86: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0A89: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_EnableInt:
                                   (0238) _RECEIVE_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0A8A: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask RECEIVE_INT_REG, RECEIVE_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0A8C: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_DisableInt:
                                   (0267) _RECEIVE_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_INT_REG, RECEIVE_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0A8D: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0A8F: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_Start:
                                   (0297) _RECEIVE_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0A90: 49 2B 08 TST   REG[43],8     (0311) ;
0A93: AF FC    JZ    0x0A90        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0A95: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0A97: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_Stop:
                                   (0326) _RECEIVE_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0A98: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0A9A: 08       PUSH  A             (0347) ;
0A9B: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0A9D: B0 04    JNZ   0x0AA2        (0349) ;    The A and X registers may be modified by this or future implementations
0A9F: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0AA0: 80 0B    JMP   0x0AAC        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0AA2: 5D 2A    MOV   A,REG[42]     (0354) ;
0AA4: 4B       SWAP  A,X           (0355)  RECEIVE_bReadRxData:
                                   (0356) _RECEIVE_bReadRxData:
0AA5: 18       POP   A             (0357)  bRECEIVE_ReadRxData:
0AA6: 21 A0    AND   A,160         (0358) _bRECEIVE_ReadRxData:
0AA8: B0 03    JNZ   0x0AAC        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0AAA: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0AAB: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0AAC: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_bReadRxStatus
                                   (0368) ;
0AAE: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_bReadRxStatus:
                                   (0388) _RECEIVE_bReadRxStatus:
                                   (0389)  bRECEIVE_ReadRxStatus:
                                   (0390) _bRECEIVE_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0AAF: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0AB1: 21 E8    AND   A,232         (0408) ;
0AB3: 08       PUSH  A             (0409) ;  ARGUMENTS:
0AB4: 21 08    AND   A,8           (0410) ;      none
0AB6: B0 07    JNZ   0x0ABE        (0411) ;
0AB8: 18       POP   A             (0412) ;  RETURNS:
0AB9: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0ABB: 4B       SWAP  A,X           (0414) ;
0ABC: 80 07    JMP   0x0AC4        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0ABE: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0ABF: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0AC1: 4B       SWAP  A,X           (0420) ;    functions.
0AC2: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0AC4: 7F       RET                 (0426)  RECEIVE_cGetChar:
                                   (0427) _RECEIVE_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_CONTROL_REG],RECEIVE_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_cReadChar:
                                   (0463) _RECEIVE_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_RX_COMPLETE                              ; Check if a character is ready
0AC5: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0AC8: 55 45 00 MOV   [69],0        (0470)    pop  A
0ACB: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0ACE: 55 75 00 MOV   [COMMAND_DESTINATION+1],0(0472) 
0AD1: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0AD4: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[RECEIVE_RX_BUFFER_REG]                       ; Read data first, then
0AD7: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0ADA: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_RX_PARITY_ERROR | RECEIVE_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0ADB: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0ADE: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0AE0: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0AE2: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_iReadChar:
                                   (0523) _RECEIVE_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_RX_ERROR|RECEIVE_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_RXBUF_ENABLE)
                                   (0552) .SECTION
0AE3: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0AE6: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0AE8: 21 F0    AND   A,240         (0555) ;
0AEA: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0AED: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_CmdReset:
0AEE: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_CmdReset:
0AF1: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_aRxBuffer
0AF3: 7F       RET                 (0590)    mov [RECEIVE_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_bRxCnt
                                   (0594)    mov [RECEIVE_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_bCmdCheck:
                                   (0628) _RECEIVE_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_fStatus
                                   (0631)    mov A,  [RECEIVE_fStatus]
                                   (0632)    and A, RECEIVE_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0AF4: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0AF6: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0AF9: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0AFC: 50 45    MOV   A,69          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0AFE: 02 75    ADD   A,[COMMAND_DESTINATION+1](0649) ;                     Returns non-zero value in A if command is valid.
0B00: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0B01: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0B03: B0 04    JNZ   0x0B08        (0653) ;           0x10 => Software Buffer OverRun
0B05: 10       PUSH  X             (0654) ;
0B06: 80 33    JMP   0x0B3A        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0B08: 39 00    CMP   A,0           (0660) ;    functions.
0B0A: B0 11    JNZ   0x0B1C        (0661) ;          
0B0C: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0B0D: 76 75    INC   [COMMAND_DESTINATION+1](0663) ;          CUR_PP
0B0F: 52 00    MOV   A,[X+0]       (0664) ;
0B11: 3C 75 0F CMP   [COMMAND_DESTINATION+1],15(0665) ;     Error Status is clear when read.
0B14: BF F3    JNZ   0x0B08        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0B16: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_bErrCheck:
0B17: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_bErrCheck:
0B1A: 80 1F    JMP   0x0B3A        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_fStatus
                                   (0674)    mov A,  [RECEIVE_fStatus]
0B1C: 10       PUSH  X             (0675)    and A, RECEIVE_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [RECEIVE_fStatus], ~RECEIVE_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0B1D: 75       INC   X             (0679) .ENDSECTION
0B1E: 76 75    INC   [COMMAND_DESTINATION+1](0680) 
0B20: 3C 75 0F CMP   [COMMAND_DESTINATION+1],15(0681) .SECTION
0B23: AF F3    JZ    0x0B17        (0682) ;-----------------------------------------------------------------------------
0B25: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_bCmdLength
0B27: A0 12    JZ    0x0B3A        (0684) ;
0B29: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0B2B: BF F1    JNZ   0x0B1D        (0686) ;     Get length of command string
                                   (0687) ;
0B2D: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0B30: 76 75    INC   [COMMAND_DESTINATION+1](0689) ;     none.
0B32: 3C 75 0F CMP   [COMMAND_DESTINATION+1],15(0690) ;
0B35: B0 04    JNZ   0x0B3A        (0691) ;  RETURNS:
0B37: 55 75 0F MOV   [COMMAND_DESTINATION+1],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0B3A: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0B3B: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0B3C: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0B3F: B0 0B    JNZ   0x0B4B        (0699) ;    functions.
0B41: 20       POP   X             (0700) ;          
0B42: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0B44: 50 00    MOV   A,0           (0702) ;          CUR_PP
0B46: 70 3F    AND   F,63
0B48: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_bCmdLength:
0B4A: 7F       RET                 (0705) _RECEIVE_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_bRxCnt
0B4B: 20       POP   X             (0708)    mov A,  [RECEIVE_bRxCnt]
0B4C: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0B4E: 70 3F    AND   F,63
0B50: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0B52: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0B53: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0B56: 50 45    MOV   A,69          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0B58: 02 75    ADD   A,[COMMAND_DESTINATION+1](0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0B5A: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0B5B: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_szGetParam, is
0B5E: 7E       RETI                (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\comp_serialint.asm
                                   (0102) ;;*****************************************************************************
                                   (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME:   COMP_SERIALINT.asm
                                   (0105) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                   (0109) ;;-----------------------------------------------------------------------------
                                   (0110) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0111) ;;*****************************************************************************
                                   (0112) ;;*****************************************************************************
                                   (0113) 
                                   (0114) 
                                   (0115) include "COMP_SERIAL.inc"
                                   (0116) include "memory.inc"
                                   (0117) include "m8c.inc"
                                   (0118) 
                                   (0119) ;-----------------------------------------------
                                   (0120) ;  Global Symbols
                                   (0121) ;-----------------------------------------------
                                   (0122) export  _COMP_SERIAL_TX_ISR
                                   (0123) export  _COMP_SERIAL_RX_ISR
                                   (0124) 
                                   (0125) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0126) export  COMP_SERIAL_aRxBuffer
                                   (0127) export _COMP_SERIAL_aRxBuffer
                                   (0128) export  COMP_SERIAL_bRxCnt
                                   (0129) export _COMP_SERIAL_bRxCnt
                                   (0130) export  COMP_SERIAL_fStatus
                                   (0131) export _COMP_SERIAL_fStatus
                                   (0132) ENDIF
                                   (0133) 
                                   (0134) 
                                   (0135) ;-----------------------------------------------
                                   (0136) ; Variable Allocation
                                   (0137) ;-----------------------------------------------
                                   (0138) AREA InterruptRAM (RAM, REL, CON)
                                   (0139) 
                                   (0140) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0141)  COMP_SERIAL_fStatus:
                                   (0142) _COMP_SERIAL_fStatus:      BLK  1
                                   (0143)  COMP_SERIAL_bRxCnt:
                                   (0144) _COMP_SERIAL_bRxCnt:       BLK  1
                                   (0145) AREA COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0146)  COMP_SERIAL_aRxBuffer:
                                   (0147) _COMP_SERIAL_aRxBuffer:    BLK COMP_SERIAL_RX_BUFFER_SIZE
                                   (0148) ENDIF
                                   (0149) 
                                   (0150) AREA InterruptRAM (RAM, REL, CON)
                                   (0151) 
0B5F: 08       PUSH  A             (0152) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0B60: 10       PUSH  X             (0153) ;---------------------------------------------------
0B61: 5D D3    MOV   A,REG[211]
                                   (0154) ; Insert your custom declarations below this banner
                                   (0155) ;---------------------------------------------------
0B63: 08       PUSH  A             (0156) 
                                   (0157) ;------------------------
                                   (0158) ;  Includes
0B64: 58 04    MOV   X,[4]         (0159) ;------------------------
0B66: 5D 3F    MOV   A,REG[63]     (0160) 
0B68: 08       PUSH  A             (0161) 
                                   (0162) ;------------------------
0B69: 21 08    AND   A,8           (0163) ;  Constant Definitions
0B6B: B0 04    JNZ   0x0B70        (0164) ;------------------------
0B6D: 18       POP   A             (0165) 
0B6E: 80 5E    JMP   0x0BCD        (0166) 
                                   (0167) ;------------------------
                                   (0168) ; Variable Allocation
0B70: 18       POP   A             (0169) ;------------------------
                                   (0170) 
                                   (0171) 
0B71: 21 E0    AND   A,224         (0172) ;---------------------------------------------------
0B73: A0 12    JZ    0x0B86        (0173) ; Insert your custom declarations above this banner
                                   (0174) ;---------------------------------------------------
0B75: 2C 03    OR    [3],A         (0175) ;@PSoC_UserCode_END@ (Do not change this line.)
0B77: 49 3E 00 TST   REG[62],0     (0176) 
0B7A: 21 20    AND   A,32          (0177) 
0B7C: A0 50    JZ    0x0BCD        (0178) AREA UserModules (ROM, REL, CON)
                                   (0179) 
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: _COMP_SERIAL_TX_ISR
0B7E: 41 3F FE AND   REG[63],254   (0182) ;
0B81: 43 3F 01 OR    REG[63],1     (0183) ;  DESCRIPTION:
0B84: 80 48    JMP   0x0BCD        (0184) ;     UART TX interrupt handler for instance COMP_SERIAL.
                                   (0185) ;
                                   (0186) ;     This is a place holder function.  If the user requires use of an interrupt
                                   (0187) ;     handler for this function, then place code where specified.
0B86: 5D 3E    MOV   A,REG[62]     (0188) ;-----------------------------------------------------------------------------
                                   (0189) 
                                   (0190) _COMP_SERIAL_TX_ISR:
0B88: 47 03 01 TST   [3],1         (0191)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
0B8B: B0 41    JNZ   0x0BCD        (0192)    ;---------------------------------------------------
                                   (0193)    ; Insert your custom code below this banner
0B8D: 39 3B    CMP   A,59          (0194)    ;---------------------------------------------------
0B8F: B0 14    JNZ   0x0BA4        (0195)    ;   NOTE: interrupt service routines must preserve
0B91: 2E 03 01 OR    [3],1         (0196)    ;   the values of the A and X CPU registers.
                                   (0197)    
                                   (0198)    ;---------------------------------------------------
                                   (0199)    ; Insert your custom code above this banner
0B94: 62 D3 00 MOV   REG[211],0    (0200)    ;---------------------------------------------------
0B97: 70 3F    AND   F,63
0B99: 71 80    OR    F,128         (0201)    ;@PSoC_UserCode_END@ (Do not change this line.)
0B9B: 56 05 00 MOV   [X+5],0       (0202)    reti
0B9E: 70 3F    AND   F,63
0BA0: 71 00    OR    F,0           (0203) 
0BA2: 80 2A    JMP   0x0BCD        (0204) 
                                   (0205) ;-----------------------------------------------------------------------------
                                   (0206) ;  FUNCTION NAME: _COMP_SERIAL_RX_ISR
                                   (0207) ;
                                   (0208) ;  DESCRIPTION:
                                   (0209) ;     UART RX interrupt handler for instance COMP_SERIAL.
                                   (0210) ;     This ISR handles the background processing of received characters if
                                   (0211) ;     the buffer is enabled.
                                   (0212) ;
                                   (0213) ;
                                   (0214) ;  The following assumes that the RX buffer feature has been enabled.
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;     There are 3 posible errors that may occur with the serial port.
0BA4: 39 20    CMP   A,32          (0218) ;      1) Parity Error
0BA6: C0 26    JC    0x0BCD        (0219) ;      2) Framing Error
                                   (0220) ;      3) OverRun Error
                                   (0221) ;
                                   (0222) ;  This user module check for parity and framing error.  If either of these
                                   (0223) ;  two errors are detected, the data is read and ignored.  When an overRun
0BA8: 62 D3 00 MOV   REG[211],0    (0224) ;  error occurs, the last byte was lost, but the current byte is valid.  For
0BAB: 3C 04 3F CMP   [4],63        (0225) ;  this reason this error is ignored at this time.  Code could be added to
0BAE: C0 11    JC    0x0BC0        (0226) ;  this ISR to set a flag if an error condition occurs.
0BB0: 70 3F    AND   F,63
0BB2: 71 80    OR    F,128         (0227) ;
0BB4: 56 05 00 MOV   [X+5],0       (0228) ;  THEORY of OPERATION:
0BB7: 70 3F    AND   F,63
0BB9: 71 00    OR    F,0           (0229) ;     When using the RX buffer feature, the ISR collects received characters
0BBB: 2E 03 10 OR    [3],16        (0230) ;     in a buffer until the user defined command terminator is detected.  After
0BBE: 80 0E    JMP   0x0BCD        (0231) ;     the command terminator is detected, the command bit is set and all other
0BC0: 70 3F    AND   F,63
                                   (0232) ;     characters will be ignored until the command bit is reset.  Up to
                                   (0233) ;     buffer_size - 1 characters will be collected waiting for a command
                                   (0234) ;     terminator.  After that, the characters will be discarded, although
0BC2: 71 80    OR    F,128         (0235) ;     a command determinator will still cause the command bit to be set.
0BC4: 54 05    MOV   [X+5],A       (0236) ;
0BC6: 70 3F    AND   F,63
0BC8: 71 00    OR    F,0           (0237) ;-----------------------------------------------------------------------------
0BCA: 75       INC   X             (0238) _COMP_SERIAL_RX_ISR:
0BCB: 5A 04    MOV   [4],X         (0239) 
0BCD: 18       POP   A
                                   (0240)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0241)    ;---------------------------------------------------
                                   (0242)    ; Insert your custom code below this banner
0BCE: 60 D3    MOV   REG[211],A    (0243)    ;---------------------------------------------------
                                   (0244)    ;   NOTE: interrupt service routines must preserve
                                   (0245)    ;   the values of the A and X CPU registers.
                                   (0246) 
0BD0: 20       POP   X             (0247)    ;---------------------------------------------------
0BD1: 18       POP   A             (0248)    ; Insert your custom code above this banner
                                   (0249)    ;---------------------------------------------------
                                   (0250)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0251) 
                                   (0252) IF (COMP_SERIAL_RXBUF_ENABLE)
0BD3: 43 E1 40 OR    REG[225],64   (0253)    push A

FILE: lib\comp_serial.asm
0BD6: 43 E1 80 OR    REG[225],128  (0180) ;;*****************************************************************************
                                   (0181) ;;*****************************************************************************
0BD9: 7F       RET                 (0182) ;;  Filename:   COMP_SERIAL.asm
                                   (0183) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0184) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0185) ;;
                                   (0186) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                   (0187) ;;                22/24/25/26/27xxx families.
                                   (0188) ;;
                                   (0189) ;;
                                   (0190) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0191) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0192) ;;        This means it is the caller's responsibility to preserve any values
                                   (0193) ;;        in the X and A registers that are still needed after the API functions
                                   (0194) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0195) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0196) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0197) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0198) ;;-----------------------------------------------------------------------------
                                   (0199) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0200) ;;*****************************************************************************
                                   (0201) ;;*****************************************************************************
                                   (0202) 
                                   (0203) 
                                   (0204) include "m8c.inc"
                                   (0205) include "memory.inc"
                                   (0206) include "COMP_SERIAL.inc"
                                   (0207) 
                                   (0208) ;-----------------------------------------------
                                   (0209) ;  Global Symbols
                                   (0210) ;-----------------------------------------------
0BDA: 41 E1 BF AND   REG[225],191  (0211) ;-------------------------------------------------------------------
0BDD: 41 E1 7F AND   REG[225],127  (0212) ;  Declare the functions global for both assembler and C compiler.
                                   (0213) ;
0BE0: 7F       RET                 (0214) ;  Note that there are two names for each API. First name is
                                   (0215) ;  assembler reference. Name with underscore is name refence for
                                   (0216) ;  C compiler.  Calling function in C source code does not require
                                   (0217) ;  the underscore.
                                   (0218) ;-------------------------------------------------------------------
                                   (0219) export  COMP_SERIAL_SetTxIntMode
                                   (0220) export _COMP_SERIAL_SetTxIntMode
                                   (0221) export  COMP_SERIAL_EnableInt
                                   (0222) export _COMP_SERIAL_EnableInt
                                   (0223) export  COMP_SERIAL_DisableInt
                                   (0224) export _COMP_SERIAL_DisableInt
                                   (0225) 
                                   (0226) export  COMP_SERIAL_Start
                                   (0227) export _COMP_SERIAL_Start
                                   (0228) export  COMP_SERIAL_Stop
                                   (0229) export _COMP_SERIAL_Stop
                                   (0230) export  COMP_SERIAL_SendData
                                   (0231) export _COMP_SERIAL_SendData
                                   (0232) export  COMP_SERIAL_bReadTxStatus
                                   (0233) export _COMP_SERIAL_bReadTxStatus
                                   (0234) export  COMP_SERIAL_bReadRxData
                                   (0235) export _COMP_SERIAL_bReadRxData
                                   (0236) export  COMP_SERIAL_bReadRxStatus
                                   (0237) export _COMP_SERIAL_bReadRxStatus
                                   (0238) 
                                   (0239) export  COMP_SERIAL_IntCntl
                                   (0240) export _COMP_SERIAL_IntCntl
                                   (0241) 
                                   (0242) export  COMP_SERIAL_TxIntMode
                                   (0243) export _COMP_SERIAL_TxIntMode
                                   (0244) 
                                   (0245) export  COMP_SERIAL_PutSHexByte
                                   (0246) export _COMP_SERIAL_PutSHexByte
0BE1: 71 10    OR    F,16          (0247) export  COMP_SERIAL_PutSHexInt
0BE3: 21 01    AND   A,1           (0248) export _COMP_SERIAL_PutSHexInt
0BE5: A0 07    JZ    0x0BED        (0249) 
0BE7: 43 38 10 OR    REG[56],16    (0250) export  COMP_SERIAL_CPutString
0BEA: 70 EF    AND   F,239         (0251) export _COMP_SERIAL_CPutString
                                   (0252) export  COMP_SERIAL_PutString
0BEC: 7F       RET                 (0253) export _COMP_SERIAL_PutString
                                   (0254) export  COMP_SERIAL_PutChar
                                   (0255) export _COMP_SERIAL_PutChar
0BED: 41 38 EF AND   REG[56],239   (0256) export  COMP_SERIAL_Write
0BF0: 70 EF    AND   F,239         (0257) export _COMP_SERIAL_Write
                                   (0258) export  COMP_SERIAL_CWrite
0BF2: 7F       RET                 (0259) export _COMP_SERIAL_CWrite
                                   (0260) 
                                   (0261) export  COMP_SERIAL_cGetChar
                                   (0262) export _COMP_SERIAL_cGetChar
                                   (0263) export  COMP_SERIAL_cReadChar
                                   (0264) export _COMP_SERIAL_cReadChar
                                   (0265) export  COMP_SERIAL_iReadChar
                                   (0266) export _COMP_SERIAL_iReadChar
                                   (0267) export  COMP_SERIAL_PutCRLF
                                   (0268) export _COMP_SERIAL_PutCRLF
                                   (0269) 
                                   (0270) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0271) export  COMP_SERIAL_CmdReset
                                   (0272) export _COMP_SERIAL_CmdReset
                                   (0273) export  COMP_SERIAL_bCmdCheck
                                   (0274) export _COMP_SERIAL_bCmdCheck
                                   (0275) export  COMP_SERIAL_bCmdLength
                                   (0276) export _COMP_SERIAL_bCmdLength
                                   (0277) export  COMP_SERIAL_bErrCheck
                                   (0278) export _COMP_SERIAL_bErrCheck
                                   (0279) 
                                   (0280) export  COMP_SERIAL_szGetParam
                                   (0281) export _COMP_SERIAL_szGetParam
                                   (0282) export  COMP_SERIAL_szGetRestOfParams
                                   (0283) export _COMP_SERIAL_szGetRestOfParams
                                   (0284) ENDIF
                                   (0285) 
                                   (0286) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0287) ; WARNING WARNING WARNING
                                   (0288) ; The following exports are for backwards compatibility only and should
                                   (0289) ; not be used for new designs. They may be eliminated in a future release.
0BF3: 29 01    OR    A,1           (0290) ; Their status is "NO FURTHER MAINTENANCE". 
0BF5: 60 3B    MOV   REG[59],A     (0291) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0BF7: 60 3F    MOV   REG[63],A     (0292) export  bCOMP_SERIAL_ReadTxStatus
                                   (0293) export _bCOMP_SERIAL_ReadTxStatus
0BF9: 91 2A    CALL  0x0D25        (0294) export  bCOMP_SERIAL_ReadRxData
                                   (0295) export _bCOMP_SERIAL_ReadRxData
                                   (0296) export  bCOMP_SERIAL_ReadRxStatus
0BFB: 7F       RET                 (0297) export _bCOMP_SERIAL_ReadRxStatus
                                   (0298) 	
                                   (0299) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0300) ;             END WARNING
                                   (0301) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0302) 
                                   (0303) ;-----------------------------------------------
                                   (0304) ; Variable Allocation
                                   (0305) ;-----------------------------------------------
                                   (0306) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0307)     
                                   (0308) area COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0309)     
                                   (0310)  ptrParam:   BLK  1
                                   (0311) 
                                   (0312) ENDIF
                                   (0313) 
                                   (0314) area text (ROM,REL)
                                   (0315) 
                                   (0316) ;-----------------------------------------------
                                   (0317) ;  EQUATES
                                   (0318) ;-----------------------------------------------
                                   (0319) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                   (0320) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                   (0321) 
                                   (0322) area UserModules (ROM, REL, CON)
                                   (0323) 
                                   (0324) ;=============================================================================
0BFC: 41 3B FE AND   REG[59],254   (0325) ;=============================================================================
0BFF: 41 3F FE AND   REG[63],254   (0326) ;
                                   (0327) ;     Low-Level Commands
0C02: 7F       RET                 (0328) ;
                                   (0329) ;=============================================================================
                                   (0330) ;=============================================================================
                                   (0331) 
                                   (0332) .SECTION
                                   (0333) ;-----------------------------------------------------------------------------
                                   (0334) ;  FUNCTION NAME: COMP_SERIAL_EnableInt
                                   (0335) ;
                                   (0336) ;  DESCRIPTION:
                                   (0337) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                   (0338) ;     bit associated with this User Module. Remember to call the global
                                   (0339) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;
                                   (0342) ;  ARGUMENTS:
                                   (0343) ;     none.
                                   (0344) ;
                                   (0345) ;  RETURNS:
                                   (0346) ;     none.
                                   (0347) ;
                                   (0348) ;  SIDE EFFECTS:
                                   (0349) ;    The A and X registers may be modified by this or future implementations
                                   (0350) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
                                   (0354) ;
                                   (0355)  COMP_SERIAL_EnableInt:
0C03: 60 39    MOV   REG[57],A     (0356) _COMP_SERIAL_EnableInt:
                                   (0357)    RAM_PROLOGUE RAM_USE_CLASS_1
0C05: 7F       RET                 (0358)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0359)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0361)    ret
                                   (0362) .ENDSECTION
                                   (0363) 
                                   (0364)     
                                   (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: COMP_SERIAL_DisableInt
                                   (0368) ;
                                   (0369) ;  DESCRIPTION:
                                   (0370) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                   (0371) ;     associated with this User Module.
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:
                                   (0375) ;     none.
                                   (0376) ;
                                   (0377) ;  RETURNS:
                                   (0378) ;     none.
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  COMP_SERIAL_DisableInt:
                                   (0388) _COMP_SERIAL_DisableInt:
0C06: 5D 3B    MOV   A,REG[59]     (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0390)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
0C08: 7F       RET                 (0391)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0392)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0393)    ret
                                   (0394) .ENDSECTION
                                   (0395) 
                                   (0396) 
                                   (0397) .SECTION
                                   (0398) ;-----------------------------------------------------------------------------
                                   (0399) ;  FUNCTION NAME: COMP_SERIAL_SetTxIntMode(BYTE bTxIntMode)
                                   (0400) ;
                                   (0401) ;  DESCRIPTION:
                                   (0402) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0403) ;-----------------------------------------------------------------------------
                                   (0404) ;
                                   (0405) ;  ARGUMENTS:
                                   (0406) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0407) ;        Passed in the A register
                                   (0408) ;
                                   (0409) ;  RETURNS:
                                   (0410) ;     none.
                                   (0411) ;
                                   (0412) ;  SIDE EFFECTS:
                                   (0413) ;    The A and X registers may be modified by this or future implementations
                                   (0414) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0415) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0416) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0417) ;    functions.
                                   (0418) ;
                                   (0419) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0420) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0421) ;     on TX register empty or TX transmit complete
0C09: 5D 3E    MOV   A,REG[62]     (0422) ;
                                   (0423)  COMP_SERIAL_SetTxIntMode:
0C0B: 7F       RET                 (0424) _COMP_SERIAL_SetTxIntMode:
                                   (0425)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0426)    M8C_SetBank1
                                   (0427)    and   A, COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0428)    jz    .SetModeRegEmpty
                                   (0429)    or    REG[COMP_SERIAL_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0430)    M8C_SetBank0
                                   (0431)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0432)    ret
                                   (0433) 
                                   (0434) .SetModeRegEmpty:
                                   (0435)    and   REG[COMP_SERIAL_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0436)    M8C_SetBank0
                                   (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0438)    ret
                                   (0439) .ENDSECTION
                                   (0440) 
                                   (0441) 
                                   (0442) .SECTION
                                   (0443) ;-----------------------------------------------------------------------------
                                   (0444) ;  FUNCTION NAME: COMP_SERIAL_Start(BYTE bParity)
                                   (0445) ;
                                   (0446) ;  DESCRIPTION:
                                   (0447) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0448) ;-----------------------------------------------------------------------------
                                   (0449) ;
                                   (0450) ;  ARGUMENTS:
                                   (0451) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                   (0452) ;        Passed in the A register.
                                   (0453) ;
                                   (0454) ;  RETURNS:
                                   (0455) ;     none.
0C0C: 5D 3F    MOV   A,REG[63]     (0456) ;
                                   (0457) ;  SIDE EFFECTS:
0C0E: 7F       RET                 (0458) ;    The A and X registers may be modified by this or future implementations
                                   (0459) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0460) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0461) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0462) ;    functions.
                                   (0463) ;
                                   (0464)  COMP_SERIAL_Start:
                                   (0465) _COMP_SERIAL_Start:
                                   (0466)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0467)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                   (0468) 
                                   (0469)    or    A, bfCONTROL_REG_START_BIT
                                   (0470)    mov   REG[COMP_SERIAL_TX_CONTROL_REG], A
                                   (0471)    mov   REG[COMP_SERIAL_RX_CONTROL_REG], A
                                   (0472) IF ( COMP_SERIAL_RXBUF_ENABLE )
                                   (0473)    call  _COMP_SERIAL_CmdReset
                                   (0474) ENDIF
                                   (0475)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0476)    ret
                                   (0477) .ENDSECTION
                                   (0478) 
                                   (0479) 
                                   (0480) .SECTION
                                   (0481) ;-----------------------------------------------------------------------------
                                   (0482) ;  FUNCTION NAME: COMP_SERIAL_Stop
                                   (0483) ;
                                   (0484) ;  DESCRIPTION:
                                   (0485) ;     Disables UART operation.
                                   (0486) ;-----------------------------------------------------------------------------
                                   (0487) ;
                                   (0488) ;  ARGUMENTS:
0C0F: 21 01    AND   A,1           (0489) ;     none.
0C11: 71 10    OR    F,16          (0490) ;
0C13: 39 01    CMP   A,1           (0491) ;  RETURNS:
0C15: A0 06    JZ    0x0C1C        (0492) ;     none.
                                   (0493) ;
0C17: 41 38 EF AND   REG[56],239   (0494) ;  SIDE EFFECTS:
0C1A: 80 04    JMP   0x0C1F        (0495) ;    The A and X registers may be modified by this or future implementations
                                   (0496) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0497) ;    the Large Memory Model.  When necessary, it is the calling function's
0C1C: 43 38 10 OR    REG[56],16    (0498) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0499) ;    functions.
                                   (0500) ;
0C1F: 70 EF    AND   F,239         (0501)  COMP_SERIAL_Stop:
                                   (0502) _COMP_SERIAL_Stop:
0C21: 7F       RET                 (0503)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0504)    and   REG[COMP_SERIAL_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0505)    and   REG[COMP_SERIAL_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0506)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0507)    ret
                                   (0508) .ENDSECTION
                                   (0509) 
                                   (0510) 
                                   (0511) .SECTION
                                   (0512) ;-----------------------------------------------------------------------------
                                   (0513) ;  FUNCTION NAME: COMP_SERIAL_SendData
                                   (0514) ;
                                   (0515) ;  DESCRIPTION:
                                   (0516) ;     Initiates a transmission of data.
                                   (0517) ;-----------------------------------------------------------------------------
                                   (0518) ;
                                   (0519) ;  ARGUMENTS:
                                   (0520) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                   (0521) ;
                                   (0522) ;  RETURNS:
                                   (0523) ;     none.
                                   (0524) ;
                                   (0525) ;  SIDE EFFECTS:
                                   (0526) ;    The A and X registers may be modified by this or future implementations
                                   (0527) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0528) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0529) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0530) ;    functions.
                                   (0531) ;
                                   (0532)  COMP_SERIAL_SendData:
                                   (0533) _COMP_SERIAL_SendData:
                                   (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0535)    mov REG[COMP_SERIAL_TX_BUFFER_REG], A
0C22: 08       PUSH  A             (0536)    RAM_EPILOGUE RAM_USE_CLASS_1
0C23: 21 01    AND   A,1           (0537)    ret
0C25: A0 06    JZ    0x0C2C        (0538) .ENDSECTION
                                   (0539) 
0C27: 43 E1 80 OR    REG[225],128  (0540) 
0C2A: 80 04    JMP   0x0C2F        (0541) .SECTION
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;  FUNCTION NAME: COMP_SERIAL_bReadTxStatus
0C2C: 41 E1 7F AND   REG[225],127  (0544) ;
                                   (0545) ;  DESCRIPTION:
                                   (0546) ;     Reads the Tx Status bits in the Control/Status register.
0C2F: 18       POP   A             (0547) ;-----------------------------------------------------------------------------
0C30: 21 02    AND   A,2           (0548) ;
0C32: A0 06    JZ    0x0C39        (0549) ;  ARGUMENTS:
                                   (0550) ;     none.
0C34: 43 E1 40 OR    REG[225],64   (0551) ;
0C37: 80 04    JMP   0x0C3C        (0552) ;  RETURNS:
                                   (0553) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                   (0554) ;           status bits (returned in A)
0C39: 41 E1 BF AND   REG[225],191  (0555) ;
                                   (0556) ;  SIDE EFFECTS:
                                   (0557) ;    The A and X registers may be modified by this or future implementations
                                   (0558) ;    of this function.  The same is true for all RAM page pointer registers in
0C3C: 7F       RET                 (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
0C3D: 30       HALT  
0C3E: 31 32    XOR   A,50
0C40: 33 34    XOR   A,[X+52]
0C42: 35 36    XOR   [X+54],A
0C44: 37 38 39 XOR   [X+56],57
0C47: 41 42 43 AND   REG[66],67
0C4A: 44 45 46 OR    REG[X+69],70
                                   (0560) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0561) ;    functions.
                                   (0562) ;
                                   (0563)  COMP_SERIAL_bReadTxStatus:
                                   (0564) _COMP_SERIAL_bReadTxStatus:
                                   (0565)  bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0566) _bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0567)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0568)    mov A,  REG[COMP_SERIAL_TX_CONTROL_REG]
                                   (0569)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0570)    ret
                                   (0571) .ENDSECTION
                                   (0572) 
                                   (0573) 
                                   (0574) .SECTION
                                   (0575) ;-----------------------------------------------------------------------------
                                   (0576) ;  FUNCTION NAME: COMP_SERIAL_bReadRxData
                                   (0577) ;
                                   (0578) ;  DESCRIPTION:
                                   (0579) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0580) ;     sure data is valid.
                                   (0581) ;-----------------------------------------------------------------------------
                                   (0582) ;
                                   (0583) ;  ARGUMENTS:
                                   (0584) ;     none.
                                   (0585) ;
                                   (0586) ;  RETURNS:
                                   (0587) ;     bRxData - returned in A.
                                   (0588) ;
                                   (0589) ;  SIDE EFFECTS:
                                   (0590) ;    The A and X registers may be modified by this or future implementations
                                   (0591) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0592) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0593) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0594) ;    functions.
                                   (0595) ;
                                   (0596)  COMP_SERIAL_bReadRxData:
                                   (0597) _COMP_SERIAL_bReadRxData:
                                   (0598)  bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0599) _bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
0C4D: 08       PUSH  A             (0601)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]
0C4E: 67       ASR   A             (0602)    RAM_EPILOGUE RAM_USE_CLASS_1
0C4F: 67       ASR   A             (0603)    ret
0C50: 67       ASR   A             (0604) .ENDSECTION
0C51: 67       ASR   A             (0605) 
0C52: 21 0F    AND   A,15          (0606) 
0C54: FF E7    INDEX 0x0C3D        (0607) .SECTION
0C56: 90 0F    CALL  0x0C67        (0608) ;-----------------------------------------------------------------------------
0C58: 18       POP   A             (0609) ;  FUNCTION NAME: COMP_SERIAL_bReadRxStatus
0C59: 21 0F    AND   A,15          (0610) ;
0C5B: FF E0    INDEX 0x0C3D        (0611) ;  DESCRIPTION:
0C5D: 90 08    CALL  0x0C67        (0612) ;     Reads the RX Status bits in the Control/Status register.
                                   (0613) ;-----------------------------------------------------------------------------
0C5F: 7F       RET                 (0614) ;
                                   (0615) ;  ARGUMENTS:
                                   (0616) ;     none.
                                   (0617) ;
                                   (0618) ;  RETURNS:
                                   (0619) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                   (0620) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0621) ;           returned in A.
                                   (0622) ;
                                   (0623) ;  SIDE EFFECTS:
                                   (0624) ;    The A and X registers may be modified by this or future implementations
                                   (0625) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0626) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0627) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0628) ;    functions.
                                   (0629) ;
                                   (0630)  COMP_SERIAL_bReadRxStatus:
                                   (0631) _COMP_SERIAL_bReadRxStatus:
                                   (0632)  bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0633) _bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0634)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0635)    mov A,  REG[COMP_SERIAL_RX_CONTROL_REG]
                                   (0636)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0637)    ret
                                   (0638) .ENDSECTION
                                   (0639) 
                                   (0640) 
                                   (0641) .SECTION
                                   (0642) ;-----------------------------------------------------------------------------
                                   (0643) ;  FUNCTION NAME: COMP_SERIAL_TxIntMode
                                   (0644) ;
0C60: 4B       SWAP  A,X           (0645) ;  DESCRIPTION:
0C61: 9F EA    CALL  0x0C4D        (0646) ;     This function is used to change the TX Interrupt mode.
0C63: 5B       MOV   A,X           (0647) ;-----------------------------------------------------------------------------
0C64: 9F E7    CALL  0x0C4D        (0648) ;
                                   (0649) ;  ARGUMENTS:
0C66: 7F       RET                 (0650) ;     A => Tx Interrupt mode
0C67: 49 3B 10 TST   REG[59],16
                                   (0651) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                   (0652) ;             1 => Interrupt on TX Complete
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none.
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
                                   (0663) ;
                                   (0664)  COMP_SERIAL_TxIntMode:
                                   (0665) _COMP_SERIAL_TxIntMode:
                                   (0666)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0667) 
                                   (0668)    and  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0669)    M8C_SetBank1
                                   (0670)    cmp  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0671)    jz   .SetTxCmpMode
                                   (0672) 
                                   (0673)    and  reg[COMP_SERIAL_TX_FUNC_REG],0xEF        ; Set Interrupt on Tx_Reg_Empty
                                   (0674)    jmp  .TxIntMode_End
                                   (0675) 
                                   (0676) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
                                   (0677)    or   reg[COMP_SERIAL_TX_FUNC_REG],0x10
                                   (0678) 
                                   (0679) .TxIntMode_End:
                                   (0680)    M8C_SetBank0
                                   (0681)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0682)    ret
                                   (0683) .ENDSECTION
                                   (0684) 
                                   (0685)     
0C6A: AF FC    JZ    0x0C67        (0686) .SECTION
0C6C: 60 39    MOV   REG[57],A
                                   (0687) ;-----------------------------------------------------------------------------
0C6E: 7F       RET                 (0688) ;  FUNCTION NAME: COMP_SERIAL_IntCntl
                                   (0689) ;
                                   (0690) ;  DESCRIPTION:
                                   (0691) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                   (0692) ;-----------------------------------------------------------------------------
                                   (0693) ;
                                   (0694) ;  ARGUMENTS:
                                   (0695) ;     A => Interrupt mask
                                   (0696) ;
                                   (0697) ;  RETURNS:
                                   (0698) ;     none.
                                   (0699) ;
                                   (0700) ;  SIDE EFFECTS:
                                   (0701) ;    The A and X registers may be modified by this or future implementations
                                   (0702) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0703) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0704) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0705) ;    functions.
                                   (0706) ;
                                   (0707) ;  THEORY of OPERATION or PROCEDURE:
                                   (0708) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                   (0709) ;     and RX block.
                                   (0710) ;
                                   (0711)  COMP_SERIAL_IntCntl:
                                   (0712) _COMP_SERIAL_IntCntl:
                                   (0713)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0714) 
                                   (0715)    push A
                                   (0716)    and  A,COMP_SERIAL_ENABLE_RX_INT
                                   (0717)    jz   .DisRxInt
                                   (0718)      ; Enable Rx Interrupt
                                   (0719)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
0C6F: 49 3F 08 TST   REG[63],8     (0720)    jmp  .CheckTxInt
0C72: AF FC    JZ    0x0C6F        (0721) .DisRxInt:
0C74: 5D 3E    MOV   A,REG[62]     (0722)      ; Disable Rx Interrupt
                                   (0723)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
0C76: 7F       RET                 (0724) 
                                   (0725) .CheckTxInt:
                                   (0726)    pop  A
                                   (0727)    and  A,COMP_SERIAL_ENABLE_TX_INT
                                   (0728)    jz   .DisTxInt
                                   (0729)      ; Enable Tx Interrupt
                                   (0730)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0731)    jmp  .End_IntCntl
                                   (0732) .DisTxInt:
                                   (0733)      ; Disable Tx Interrupt
                                   (0734)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0735) 
                                   (0736) .End_IntCntl:
                                   (0737)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0738)    ret
                                   (0739) .ENDSECTION
                                   (0740) 
                                   (0741) 
                                   (0742) ;=============================================================================
                                   (0743) ;=============================================================================
                                   (0744) ;
                                   (0745) ;     High-Level Commands
                                   (0746) ;
                                   (0747) ;=============================================================================
                                   (0748) ;=============================================================================
                                   (0749) 
                                   (0750) 
                                   (0751) ;-----------------------------------------------------------------------------
                                   (0752) ;  FUNCTION NAME: COMP_SERIAL_PutSHexByte
                                   (0753) ;
                                   (0754) ;  DESCRIPTION:
0C77: 5D 3F    MOV   A,REG[63]     (0755) ;     Print a byte in Hex (two characters) to the UART Tx
0C79: 08       PUSH  A             (0756) ;-----------------------------------------------------------------------------
0C7A: 21 08    AND   A,8           (0757) ;
0C7C: B0 04    JNZ   0x0C81        (0758) ;  ARGUMENTS:
0C7E: 18       POP   A             (0759) ;     A  => (BYTE) Data/char to be printed
0C7F: 80 0B    JMP   0x0C8B        (0760) ;
                                   (0761) ;  RETURNS:
                                   (0762) ;     none.
0C81: 5D 3E    MOV   A,REG[62]     (0763) ;
0C83: 4B       SWAP  A,X           (0764) ;  SIDE EFFECTS:
                                   (0765) ;    The A and X registers may be modified by this or future implementations
0C84: 18       POP   A             (0766) ;    of this function.  The same is true for all RAM page pointer registers in
0C85: 21 A0    AND   A,160         (0767) ;    the Large Memory Model.  When necessary, it is the calling function's
0C87: B0 03    JNZ   0x0C8B        (0768) ;    responsibility to perserve their values across calls to fastcall16 
0C89: 4B       SWAP  A,X           (0769) ;    functions.
                                   (0770) ;
0C8A: 7F       RET                 (0771) .LITERAL
                                   (0772) COMP_SERIAL_HEX_STR:
                                   (0773)      DS    "0123456789ABCDEF"
0C8B: 50 00    MOV   A,0           (0774) .ENDLITERAL
                                   (0775) 
                                   (0776) .SECTION
                                   (0777)  COMP_SERIAL_PutSHexByte:
0C8D: 7F       RET                 (0778) _COMP_SERIAL_PutSHexByte:
                                   (0779)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0780)    push  A                             ; Save lower nibble
                                   (0781)    asr   A                             ; Shift high nibble to right
                                   (0782)    asr   A
                                   (0783)    asr   A
                                   (0784)    asr   A
                                   (0785)    and   A,0Fh                         ; Mask off nibble
                                   (0786)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0787)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0788)    pop   A                             ; Restore value
                                   (0789)    and   A,0Fh                         ; Mask off lower nibble
                                   (0790)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0791)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0792)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0793)    ret
                                   (0794) .ENDSECTION
                                   (0795) 
                                   (0796) 
                                   (0797) .SECTION
                                   (0798) ;-----------------------------------------------------------------------------
                                   (0799) ;  FUNCTION NAME: COMP_SERIAL_PutSHexInt
                                   (0800) ;
                                   (0801) ;  DESCRIPTION:
                                   (0802) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0803) ;-----------------------------------------------------------------------------
                                   (0804) ;
                                   (0805) ;  ARGUMENTS:
                                   (0806) ;     Pointer to string
                                   (0807) ;     A  => ASB of Int
                                   (0808) ;     X  => MSB of Int
                                   (0809) ;
                                   (0810) ;  RETURNS:
                                   (0811) ;     none.
                                   (0812) ;
                                   (0813) ;  SIDE EFFECTS:
                                   (0814) ;    The A and X registers may be modified by this or future implementations
                                   (0815) ;    of this function.  The same is true for all RAM page pointer registers in
0C8E: 5D 3F    MOV   A,REG[63]     (0816) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0817) ;    responsibility to perserve their values across calls to fastcall16 
0C90: 21 E8    AND   A,232         (0818) ;    functions.
0C92: 08       PUSH  A             (0819) ;
0C93: 21 08    AND   A,8           (0820) 
0C95: B0 07    JNZ   0x0C9D        (0821)  COMP_SERIAL_PutSHexInt:
0C97: 18       POP   A             (0822) _COMP_SERIAL_PutSHexInt:
0C98: 29 01    OR    A,1           (0823)    RAM_PROLOGUE RAM_USE_CLASS_1
0C9A: 4B       SWAP  A,X           (0824)    swap  A,X
0C9B: 80 07    JMP   0x0CA3        (0825)    call  COMP_SERIAL_PutSHexByte       ; Print MSB
                                   (0826)    mov   A,X                           ; Move LSB into position
                                   (0827)    call  COMP_SERIAL_PutSHexByte       ; Print LSB
0C9D: 18       POP   A             (0828)    RAM_EPILOGUE RAM_USE_CLASS_1
0C9E: 21 E0    AND   A,224         (0829)    ret
0CA0: 4B       SWAP  A,X           (0830) .ENDSECTION
0CA1: 5D 3E    MOV   A,REG[62]     (0831) 
                                   (0832) 
                                   (0833) .SECTION
                                   (0834) ;-----------------------------------------------------------------------------
                                   (0835) ;  FUNCTION NAME: COMP_SERIAL_PutChar
0CA3: 7F       RET                 (0836) ;
                                   (0837) ;  DESCRIPTION:
                                   (0838) ;     Send character out through UART TX port.
                                   (0839) ;-----------------------------------------------------------------------------
                                   (0840) ;
                                   (0841) ;  ARGUMENTS:
                                   (0842) ;     A has Character to send to UART Tx Port
                                   (0843) ;
                                   (0844) ;  RETURNS:
                                   (0845) ;     none
                                   (0846) ;
                                   (0847) ;  SIDE EFFECTS:
                                   (0848) ;    The A and X registers may be modified by this or future implementations
                                   (0849) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0850) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0851) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0852) ;    functions.
                                   (0853) ;
                                   (0854) 
                                   (0855)    macro InLinePutChar( Source )
                                   (0856) .BufEmptyWaitLoop:
                                   (0857)    tst REG[COMP_SERIAL_TX_CONTROL_REG], COMP_SERIAL_TX_BUFFER_EMPTY     ; Check Tx Status
                                   (0858)    jz  .BufEmptyWaitLoop
                                   (0859)    mov REG[COMP_SERIAL_TX_BUFFER_REG], @Source     ; Write data to Tx Port
                                   (0860)    endm
                                   (0861) 
                                   (0862)  COMP_SERIAL_PutChar:
                                   (0863) _COMP_SERIAL_PutChar:
                                   (0864)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0865)    InLinePutChar A
                                   (0866)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0867)    ret
0CA4: 70 BF    AND   F,191         (0868) .ENDSECTION
0CA6: 60 D3    MOV   REG[211],A    (0869) 
                                   (0870) 
0CA8: 52 00    MOV   A,[X+0]       (0871) .SECTION
0CAA: A0 06    JZ    0x0CB1        (0872) ;-----------------------------------------------------------------------------
0CAC: 9F B9    CALL  0x0C67        (0873) ;  FUNCTION NAME: COMP_SERIAL_cGetChar
0CAE: 75       INC   X             (0874) ;
0CAF: 8F F8    JMP   0x0CA8        (0875) ;  DESCRIPTION:
0CB1: 70 3F    AND   F,63
                                   (0876) ;     Read character from UART RX port.
                                   (0877) ;-----------------------------------------------------------------------------
0CB3: 71 C0    OR    F,192         (0878) ;
0CB5: 7F       RET                 (0879) ;  ARGUMENTS:
                                   (0880) ;      none
                                   (0881) ;
                                   (0882) ;  RETURNS:
                                   (0883) ;     char that is returned from UART
                                   (0884) ;
                                   (0885) ;  SIDE EFFECTS:
                                   (0886) ;    The A and X registers may be modified by this or future implementations
                                   (0887) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0888) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0889) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0890) ;    functions.
                                   (0891) ;
                                   (0892) ;    Program flow will stay in this function until a character is received.
                                   (0893) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0894) ;    the delay between characters is less than the watchdog timeout.
                                   (0895) ;
                                   (0896)  COMP_SERIAL_cGetChar:
                                   (0897) _COMP_SERIAL_cGetChar:
                                   (0898)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0899)    tst REG[COMP_SERIAL_RX_CONTROL_REG],COMP_SERIAL_RX_REG_FULL    ; Check if a character is ready
                                   (0900)    jz  COMP_SERIAL_cGetChar                              ; If not loop
                                   (0901)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]                 ; Get character
                                   (0902)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0903)    ret
                                   (0904) .ENDSECTION
                                   (0905) 
                                   (0906) 
                                   (0907) .SECTION
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) ;  FUNCTION NAME: COMP_SERIAL_cReadChar
                                   (0910) ;
                                   (0911) ;  DESCRIPTION:
                                   (0912) ;     Read character from UART RX port.
                                   (0913) ;-----------------------------------------------------------------------------
                                   (0914) ;
0CB6: 70 BF    AND   F,191         (0915) ;  ARGUMENTS:
0CB8: 62 D3 03 MOV   REG[211],3    (0916) ;      none
0CBB: 4F       MOV   X,SP          (0917) ;
                                   (0918) ;  RETURNS:
                                   (0919) ;     char that is returned from UART
0CBC: 52 FB    MOV   A,[X-5]       (0920) ;
0CBE: A0 1A    JZ    0x0CD9        (0921) ;  SIDE EFFECTS:
0CC0: 7B FB    DEC   [X-5]         (0922) ;    The A and X registers may be modified by this or future implementations
                                   (0923) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0924) ;    the Large Memory Model.  When necessary, it is the calling function's
0CC2: 52 FC    MOV   A,[X-4]       (0925) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0926) ;    functions.
                                   (0927) ;
0CC4: 59 FD    MOV   X,[X-3]       (0928) ;    A valid 0x00 character will be ignored, since a 0x00 return value
0CC6: 60 D3    MOV   REG[211],A    (0929) ;    implies a valid character or an error condition occured.
0CC8: 52 00    MOV   A,[X+0]       (0930) ;
0CCA: 49 3B 10 TST   REG[59],16
0CCD: AF FC    JZ    0x0CCA        (0931)  COMP_SERIAL_cReadChar:
0CCF: 60 39    MOV   REG[57],A
0CD1: 4F       MOV   X,SP          (0932) _COMP_SERIAL_cReadChar:
0CD2: 62 D3 03 MOV   REG[211],3    (0933)    RAM_PROLOGUE RAM_USE_CLASS_1
0CD5: 77 FD    INC   [X-3]         (0934)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
0CD7: 8F E4    JMP   0x0CBC        (0935)    push A
0CD9: 70 3F    AND   F,63
                                   (0936)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (0937)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0CDB: 71 C0    OR    F,192         (0938)    pop  A
0CDD: 7F       RET                 (0939)    jmp  .RX_NO_VALID_CHAR
                                   (0940) 
                                   (0941) .RX_DATA_RDY:
                                   (0942)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]          
                                   (0943)    swap A,X                                                ; determine if data is valid
                                   (0944) 
                                   (0945)    pop  A                                                  ; Check for errors
                                   (0946)    and  A,(COMP_SERIAL_RX_PARITY_ERROR | COMP_SERIAL_RX_FRAMING_ERROR)
                                   (0947)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0948)    swap A,X                                                ; Put data in A and exit
                                   (0949)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0950)    ret
                                   (0951) 
                                   (0952) .RX_NO_VALID_CHAR:
                                   (0953)    mov A,0x00                                              ; Zero out character
                                   (0954) 
                                   (0955)  End_COMP_SERIAL_cReadChar:
                                   (0956)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0957)    ret
                                   (0958) .ENDSECTION
                                   (0959) 
                                   (0960) 
                                   (0961) .SECTION
                                   (0962) ;-----------------------------------------------------------------------------
                                   (0963) ;  FUNCTION NAME: COMP_SERIAL_iReadChar
                                   (0964) ;
                                   (0965) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0966) ;  to just set a value in the upper byte if error conditions exists.
                                   (0967) ;
                                   (0968) ;  DESCRIPTION:
                                   (0969) ;     Read character from UART RX port.
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;
                                   (0972) ;  ARGUMENTS:
                                   (0973) ;      none
                                   (0974) ;
                                   (0975) ;  RETURNS:
                                   (0976) ;     An integer value is returned.  A negative value inplies and error
0CDE: 4F       MOV   X,SP          (0977) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0978) ;
0CDF: 3D FA 00 CMP   [X-6],0       (0979) ;     Error Codes:
0CE2: B0 06    JNZ   0x0CE9        (0980) ;        0x80CC    Parity Error
0CE4: 3D FB 00 CMP   [X-5],0       (0981) ;        0x40CC    Overrun Error
0CE7: A0 1D    JZ    0x0D05        (0982) ;        0x20CC    Framing Error
                                   (0983) ;        0x01CC    No Data available
                                   (0984) ;
0CE9: 10       PUSH  X             (0985) ;  SIDE EFFECTS:
0CEA: 52 FC    MOV   A,[X-4]       (0986) ;    The A and X registers may be modified by this or future implementations
0CEC: 59 FD    MOV   X,[X-3]       (0987) ;    of this function.  The same is true for all RAM page pointer registers in
0CEE: 28       ROMX                (0988) ;    the Large Memory Model.  When necessary, it is the calling function's
0CEF: 49 3B 10 TST   REG[59],16
0CF2: AF FC    JZ    0x0CEF        (0989) ;    responsibility to perserve their values across calls to fastcall16 
0CF4: 60 39    MOV   REG[57],A
0CF6: 20       POP   X             (0990) ;    functions.
0CF7: 07 FD 01 ADD   [X-3],1       (0991) ;
0CFA: 0F FC 00 ADC   [X-4],0       (0992)  COMP_SERIAL_iReadChar:
0CFD: 17 FB 01 SUB   [X-5],1       (0993) _COMP_SERIAL_iReadChar:
0D00: 1F FA 00 SBB   [X-6],0       (0994)    RAM_PROLOGUE RAM_USE_CLASS_1
0D03: 8F DB    JMP   0x0CDF        (0995)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
0D05: 70 3F    AND   F,63
                                   (0996)                                                            ; Mask only errors and data ready
                                   (0997)    and  A,(COMP_SERIAL_RX_ERROR|COMP_SERIAL_RX_REG_FULL)
0D07: 71 C0    OR    F,192         (0998)    push A
0D09: 7F       RET                 (0999)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (1000)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (1001)    pop  A
                                   (1002)    or   A,COMP_SERIAL_RX_NO_DATA                           ; Add no data flag
                                   (1003)    swap A,X
                                   (1004)    jmp  End_COMP_SERIAL_iReadChar
                                   (1005) 
                                   (1006) .RX_GET_DATA:
                                   (1007)    pop  A
                                   (1008)    and  A,COMP_SERIAL_RX_ERROR
                                   (1009)    swap A,X
                                   (1010)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]                  ; Read data first, then
                                   (1011)                                                            ; determine if data is valid
                                   (1012) 
                                   (1013)  End_COMP_SERIAL_iReadChar:
                                   (1014)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1015)    ret
                                   (1016) .ENDSECTION
                                   (1017) 
                                   (1018) 
                                   (1019) .SECTION
                                   (1020) ;-----------------------------------------------------------------------------
                                   (1021) ;  FUNCTION NAME: COMP_SERIAL_PutString
                                   (1022) ;
                                   (1023) ;  DESCRIPTION:
                                   (1024) ;     Send String out through UART TX port.
                                   (1025) ;-----------------------------------------------------------------------------
                                   (1026) ;
                                   (1027) ;  ARGUMENTS:
                                   (1028) ;     Pointer to String
0D0A: 08       PUSH  A             (1029) ;     A has MSB of string address
0D0B: 10       PUSH  X             (1030) ;     X has LSB of string address
0D0C: 28       ROMX                (1031) ;
0D0D: A0 0B    JZ    0x0D19        (1032) ;  RETURNS:
0D0F: 9F 56    CALL  0x0C67        (1033) ;     none
0D11: 20       POP   X             (1034) ;
0D12: 18       POP   A             (1035) ;  SIDE EFFECTS:
0D13: 75       INC   X             (1036) ;    The A and X registers may be modified by this or future implementations
0D14: DF F5    JNC   0x0D0A        (1037) ;    of this function.  The same is true for all RAM page pointer registers in
0D16: 74       INC   A             (1038) ;    the Large Memory Model.  When necessary, it is the calling function's
0D17: 8F F2    JMP   0x0D0A        (1039) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1040) ;    functions.
                                   (1041) ;          
                                   (1042) ;    Currently only the page pointer registers listed below are modified: 
0D19: 38 FE    ADD   SP,254        (1043) ;          IDX_PP
                                   (1044) ;
0D1B: 7F       RET                 (1045)  COMP_SERIAL_PutString:
                                   (1046) _COMP_SERIAL_PutString:
                                   (1047)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1048)    RAM_SETPAGE_IDX A
                                   (1049) .PutStringLoop:
                                   (1050)    mov   A,[X]                                   ; Get value pointed to by X
                                   (1051)    jz    End_PutString                           ; Check for end of string
                                   (1052)    call  COMP_SERIAL_PutChar                     ; Send character to Tx port
                                   (1053)    inc   X                                       ; Advance pointer to next character
                                   (1054)    jmp   .PutStringLoop                          ; Get next character
                                   (1055) 
                                   (1056) End_PutString:
                                   (1057)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1058)    ret
                                   (1059) .ENDSECTION
                                   (1060)     
                                   (1061) .SECTION
                                   (1062) ;-----------------------------------------------------------------------------
                                   (1063) ;  FUNCTION NAME: COMP_SERIAL_Write
                                   (1064) ;
                                   (1065) ;  DESCRIPTION:
                                   (1066) ;     Send String of length X to serial port
                                   (1067) ;-----------------------------------------------------------------------------
                                   (1068) ;
                                   (1069) ;  ARGUMENTS:
                                   (1070) ;     Pointer to String
                                   (1071) ;     [SP-5] Count of characters to send
                                   (1072) ;     [SP-4] has MSB of string address
0D1C: 50 0D    MOV   A,13          (1073) ;     [SP-3] has LSB of string address
0D1E: 9F 47    CALL  0x0C67        (1074) ;
0D20: 50 0A    MOV   A,10          (1075) ;  RETURNS:
0D22: 9F 43    CALL  0x0C67        (1076) ;     none
                                   (1077) ;
0D24: 7F       RET                 (1078) ;  SIDE EFFECTS:
                                   (1079) ;    The A and X registers may be modified by this or future implementations
                                   (1080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1083) ;    functions.
                                   (1084) ;          
                                   (1085) ;    Currently only the page pointer registers listed below are modified: 
                                   (1086) ;          IDX_PP
                                   (1087) ;
                                   (1088) CNT_LEN:    equ -5                               ; Length of data to send
                                   (1089) STR_MSB:    equ -4                               ; MSB pointer of string 
                                   (1090) STR_LSB:    equ -3                               ; LSB pointer of string 
                                   (1091) 
                                   (1092)  COMP_SERIAL_Write:
                                   (1093) _COMP_SERIAL_Write:
                                   (1094)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1095)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
                                   (1096)    mov   X, SP                                   ; Establish the frame pointer 
                                   (1097) 
                                   (1098) .NextByteLoop:
                                   (1099)    mov   A, [X+CNT_LEN]                          ; End of the string?
                                   (1100)    jz    .End_Write                              ;   Yes, prepare to exit
                                   (1101)    dec   [X+CNT_LEN]                             ; Decrement counter
                                   (1102) 
                                   (1103)    IF SYSTEM_LARGE_MEMORY_MODEL
                                   (1104)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                   (1105)    ENDIF
                                   (1106) 
                                   (1107)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
                                   (1108)    RAM_SETPAGE_IDX A                             ; switch index pages
                                   (1109)    mov   A, [X]                                  ; Grab the data
                                   (1110)    InLinePutChar A                               ; Put data in empty TX buf reg
                                   (1111)    mov   X, SP                                   ; Recover frame pointer
                                   (1112)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
                                   (1113)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
                                   (1114)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
                                   (1115) 
                                   (1116) .End_Write:
                                   (1117)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1118)    ret
                                   (1119) .ENDSECTION
                                   (1120)     
0D25: 62 D0 00 MOV   REG[208],0    (1121) 
0D28: 55 05 00 MOV   [5],0         (1122) .SECTION
0D2B: 62 D0 00 MOV   REG[208],0    (1123) ;-----------------------------------------------------------------------------
0D2E: 55 04 00 MOV   [4],0         (1124) ;  FUNCTION NAME: COMP_SERIAL_CWrite
0D31: 26 03 00 AND   [3],0         (1125) ;
0D34: 62 D0 00 MOV   REG[208],0    (1126) ;             WARNING WARNING NOT COMPLETE
0D37: 55 72 00 MOV   [NUM_MODULES+2],0(1127) ;
                                   (1128) ;  DESCRIPTION:
0D3A: 7F       RET                 (1129) ;     Send String of length X to serial port
                                   (1130) ;-----------------------------------------------------------------------------
                                   (1131) ;
                                   (1132) ;  ARGUMENTS:
                                   (1133) ;     [SP-4] MSB of Count of character to send
                                   (1134) ;     [SP-3] LSB of Count of character to send
                                   (1135) ;     [SP-2] has MSB of string address
                                   (1136) ;     [SP-1] has LSB of string address
                                   (1137) ;
                                   (1138) ;  RETURNS:
                                   (1139) ;     none
                                   (1140) ;
                                   (1141) ;  SIDE EFFECTS:
                                   (1142) ;    The A and X registers may be modified by this or future implementations
                                   (1143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1146) ;    functions.
                                   (1147) ;
                                   (1148) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                   (1149) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                   (1150) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (1151) CSTR_LSB:   equ -3           ; LSB pointer of string
                                   (1152) 
                                   (1153)  COMP_SERIAL_CWrite:
                                   (1154) _COMP_SERIAL_CWrite:
                                   (1155)    RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1156)    mov   X,SP
                                   (1157) .CW_Loop:
                                   (1158)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
                                   (1159)    jnz   .CW_WRITEIT
                                   (1160)    cmp   [X+CLEN_LSB],0x00
                                   (1161)    jz    .End_CWrite                        ; Leave if done
                                   (1162) 
                                   (1163) .CW_WRITEIT:                                
0D3B: 62 D0 00 MOV   REG[208],0    (1164)    push  X                                  ; Save frame pointer
0D3E: 51 03    MOV   A,[3]         (1165)    mov   A,[X+CSTR_MSB]
0D40: 21 01    AND   A,1           (1166)    mov   X,[X+CSTR_LSB]
                                   (1167)    romx                                     ; Get character from ROM
0D42: 7F       RET                 (1168)    InLinePutChar A                          ; Put data in empty TX buf reg
                                   (1169)    pop   X                                  ; Restore frame pointer
                                   (1170)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
                                   (1171)    adc   [X+CSTR_MSB],0
                                   (1172)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
                                   (1173)    sbb   [X+CLEN_MSB],0x00
                                   (1174)    jmp   .CW_Loop
                                   (1175) 
                                   (1176) .End_CWrite:
                                   (1177)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1178)    ret
                                   (1179) .ENDSECTION
                                   (1180) 
                                   (1181) 
                                   (1182) .SECTION
                                   (1183) ;-----------------------------------------------------------------------------
                                   (1184) ;  FUNCTION NAME: COMP_SERIAL_CPutString
                                   (1185) ;
                                   (1186) ;  DESCRIPTION:
                                   (1187) ;     Send String out through UART TX port.
                                   (1188) ;-----------------------------------------------------------------------------
                                   (1189) ;
                                   (1190) ;  ARGUMENTS:
                                   (1191) ;     Pointer to String
                                   (1192) ;     A has MSB of string address
                                   (1193) ;     X has LSB of string address
                                   (1194) ;
                                   (1195) ;  RETURNS:
                                   (1196) ;     none
                                   (1197) ;
                                   (1198) ;  SIDE EFFECTS:
                                   (1199) ;    The A and X registers may be modified by this or future implementations
                                   (1200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1203) ;    functions.
                                   (1204) ;
                                   (1205)  COMP_SERIAL_CPutString:
                                   (1206) _COMP_SERIAL_CPutString:
                                   (1207)    RAM_PROLOGUE RAM_USE_CLASS_1
0D43: 62 D0 00 MOV   REG[208],0    (1208)    push  A                                       ; Store ROM pointer
0D46: 51 03    MOV   A,[3]         (1209)    push  X
0D48: 21 F0    AND   A,240         (1210)    romx                                          ; Get character from ROM
0D4A: 26 03 0F AND   [3],15        (1211)    jz    .End_CPutString
                                   (1212)    call  COMP_SERIAL_PutChar                     ; Print character
0D4D: 7F       RET                 (1213)    pop   X
                                   (1214)    pop   A
                                   (1215)    inc   X                                       ; Inc LSB of pointer
                                   (1216)    jnc   COMP_SERIAL_CPutString                  ; Check for carry
                                   (1217)    inc   A                                       ; Inc MSB of pointer
                                   (1218)    jmp   COMP_SERIAL_CPutString
                                   (1219) 
                                   (1220) 
                                   (1221) .End_CPutString:
                                   (1222)    add   SP, -2
                                   (1223)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1224)    ret
                                   (1225) .ENDSECTION
                                   (1226) 
                                   (1227) 
                                   (1228) .SECTION
                                   (1229) ;-----------------------------------------------------------------------------
                                   (1230) ;  FUNCTION NAME: COMP_SERIAL_PutCRLF
                                   (1231) ;
                                   (1232) ;  DESCRIPTION:
                                   (1233) ;     Send a CR and LF
                                   (1234) ;-----------------------------------------------------------------------------
                                   (1235) ;
                                   (1236) ;  ARGUMENTS:
                                   (1237) ;     none.
                                   (1238) ;
                                   (1239) ;  RETURNS:
                                   (1240) ;     none.
                                   (1241) ;
                                   (1242) ;  SIDE EFFECTS:
0D4E: 62 D0 00 MOV   REG[208],0    (1243) ;    The A and X registers may be modified by this or future implementations
0D51: 51 04    MOV   A,[4]         (1244) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1245) ;    the Large Memory Model.  When necessary, it is the calling function's
0D53: 7F       RET                 (1246) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1247) ;    functions.
                                   (1248) ;
                                   (1249)  COMP_SERIAL_PutCRLF:
                                   (1250) _COMP_SERIAL_PutCRLF:
                                   (1251)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1252)    mov  A,0x0D                        ; Send CR
                                   (1253)    call COMP_SERIAL_PutChar
                                   (1254)    mov  A,0x0A                        ; Send LF
                                   (1255)    call COMP_SERIAL_PutChar
                                   (1256)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1257)    ret
                                   (1258) .ENDSECTION
                                   (1259) 
                                   (1260) 
                                   (1261) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (1262) ;=============================================================================
                                   (1263) ;=============================================================================
                                   (1264) ;
                                   (1265) ;     Command Buffer commands
                                   (1266) ;
                                   (1267) ;=============================================================================
                                   (1268) ;=============================================================================
                                   (1269) 
                                   (1270) .SECTION
                                   (1271) ;-----------------------------------------------------------------------------
                                   (1272) ;  FUNCTION NAME: COMP_SERIAL_CmdReset
                                   (1273) ;
                                   (1274) ;  DESCRIPTION:
                                   (1275) ;     Reset command string and status flags
                                   (1276) ;-----------------------------------------------------------------------------
                                   (1277) ;
                                   (1278) ;  ARGUMENTS:
                                   (1279) ;     none.
                                   (1280) ;
                                   (1281) ;  RETURNS:
                                   (1282) ;     none.
                                   (1283) ;
                                   (1284) ;  SIDE EFFECTS:
                                   (1285) ;    The A and X registers may be modified by this or future implementations
                                   (1286) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1287) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1288) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1289) ;    functions.
                                   (1290) ;          
                                   (1291) ;    Currently only the page pointer registers listed below are modified: 
                                   (1292) ;          CUR_PP
                                   (1293) ;
                                   (1294) ;  THEORY of OPERATION or PROCEDURE:
                                   (1295) ;     Clear the command buffer, command counter, and flag.
                                   (1296) ;
                                   (1297)  COMP_SERIAL_CmdReset:
                                   (1298) _COMP_SERIAL_CmdReset:
                                   (1299)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1300)    RAM_SETPAGE_CUR >COMP_SERIAL_aRxBuffer
0D54: 70 BF    AND   F,191         (1301)    mov [COMP_SERIAL_aRxBuffer], 0x00
                                   (1302)    RAM_SETPAGE_CUR >COMP_SERIAL_bRxCnt
0D56: 62 D0 00 MOV   REG[208],0    (1303)    mov [COMP_SERIAL_bRxCnt], 0x00
0D59: 50 05    MOV   A,5           (1304)    and [COMP_SERIAL_fStatus], 0x00
0D5B: 02 72    ADD   A,[NUM_MODULES+2](1305)    RAM_SETPAGE_CUR >ptrParam
0D5D: 5C       MOV   X,A           (1306)    mov [ptrParam],0x00
0D5E: 62 D3 00 MOV   REG[211],0    (1307)    RAM_EPILOGUE RAM_USE_CLASS_4
0D61: 52 00    MOV   A,[X+0]       (1308)    ret
0D63: B0 04    JNZ   0x0D68        (1309) .ENDSECTION
0D65: 10       PUSH  X             (1310) 
0D66: 80 33    JMP   0x0D9A        (1311) 
                                   (1312) .SECTION
                                   (1313) ;-----------------------------------------------------------------------------
                                   (1314) ;  FUNCTION NAME: COMP_SERIAL_bCmdCheck
0D68: 39 2C    CMP   A,44          (1315) ;
0D6A: B0 11    JNZ   0x0D7C        (1316) ;  DESCRIPTION:
0D6C: 75       INC   X             (1317) ;     Check to see if valid command in buffer.
0D6D: 76 72    INC   [NUM_MODULES+2](1318) ;-----------------------------------------------------------------------------
0D6F: 52 00    MOV   A,[X+0]       (1319) ;
0D71: 3C 72 3F CMP   [NUM_MODULES+2],63(1320) ;  ARGUMENTS:
0D74: BF F3    JNZ   0x0D68        (1321) ;     none.
                                   (1322) ;
                                   (1323) ;  RETURNS:
0D76: 10       PUSH  X             (1324) ;     BYTE  fStatus - Status of command receive buffer.
                                   (1325) ;                     Returns non-zero value in A if command is valid.
0D77: 56 00 00 MOV   [X+0],0       (1326) ;
0D7A: 80 1F    JMP   0x0D9A        (1327) ;  SIDE EFFECTS:
                                   (1328) ;    The A and X registers may be modified by this or future implementations
                                   (1329) ;    of this function.  The same is true for all RAM page pointer registers in
0D7C: 10       PUSH  X             (1330) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1331) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1332) ;    functions.
0D7D: 75       INC   X             (1333) ;          
0D7E: 76 72    INC   [NUM_MODULES+2](1334) ;    Currently only the page pointer registers listed below are modified: 
0D80: 3C 72 3F CMP   [NUM_MODULES+2],63(1335) ;          CUR_PP
0D83: AF F3    JZ    0x0D77        (1336) ;
0D85: 52 00    MOV   A,[X+0]       (1337) ;  THEORY of OPERATION or PROCEDURE:
0D87: A0 12    JZ    0x0D9A        (1338) ;     Read the status and control register.
0D89: 39 2C    CMP   A,44          (1339) ;
0D8B: BF F1    JNZ   0x0D7D        (1340)  COMP_SERIAL_bCmdCheck:
0D8D: 56 00 00 MOV   [X+0],0       (1341) _COMP_SERIAL_bCmdCheck:
0D90: 76 72    INC   [NUM_MODULES+2](1342)    RAM_PROLOGUE RAM_USE_CLASS_4
0D92: 3C 72 3F CMP   [NUM_MODULES+2],63(1343)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
0D95: B0 04    JNZ   0x0D9A        (1344)    mov A,  [COMP_SERIAL_fStatus]
0D97: 55 72 3F MOV   [NUM_MODULES+2],63(1345)    and A, COMP_SERIAL_RX_BUF_CMDTERM             ; Mask off Command status
                                   (1346)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1347)    ret
0D9A: 20       POP   X             (1348) .ENDSECTION
0D9B: 10       PUSH  X             (1349)     
0D9C: 3D 00 00 CMP   [X+0],0       (1350) 
0D9F: B0 0B    JNZ   0x0DAB        (1351) .SECTION
0DA1: 20       POP   X             (1352) ;-----------------------------------------------------------------------------
0DA2: 57 00    MOV   X,0           (1353) ;  FUNCTION NAME: COMP_SERIAL_bErrCheck
0DA4: 50 00    MOV   A,0           (1354) ;
0DA6: 70 3F    AND   F,63
0DA8: 71 C0    OR    F,192         (1355) ;  DESCRIPTION:
                                   (1356) ;     Check to see if an error has occured since last CmdReset
0DAA: 7F       RET                 (1357) ;-----------------------------------------------------------------------------
                                   (1358) ;
                                   (1359) ;  ARGUMENTS:
0DAB: 20       POP   X             (1360) ;     none.
0DAC: 50 00    MOV   A,0           (1361) ;
0DAE: 70 3F    AND   F,63
0DB0: 71 C0    OR    F,192         (1362) ;  RETURNS:
                                   (1363) ;     BYTE  fStatus - Status of command receive buffer.
0DB2: 7F       RET                 (1364) ;                     Returns non-zero value in A if command is valid.
                                   (1365) ;           0x80 => Parity Error
                                   (1366) ;           0x40 => OverRun Error
                                   (1367) ;           0x20 => Framing Error
                                   (1368) ;           0x10 => Software Buffer OverRun
                                   (1369) ;
                                   (1370) ;  SIDE EFFECTS:
                                   (1371) ;    The A and X registers may be modified by this or future implementations
                                   (1372) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1373) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1374) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1375) ;    functions.
                                   (1376) ;          
                                   (1377) ;    Currently only the page pointer registers listed below are modified: 
                                   (1378) ;          CUR_PP
                                   (1379) ;     Error Status is clear when read.
                                   (1380) ;
                                   (1381) ;  THEORY of OPERATION or PROCEDURE:
                                   (1382) ;     Read RX buffer error status and clear status
                                   (1383) ;
                                   (1384)  COMP_SERIAL_bErrCheck:
                                   (1385) _COMP_SERIAL_bErrCheck:
                                   (1386)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1387)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
                                   (1388)    mov A,  [COMP_SERIAL_fStatus]
                                   (1389)    and A, COMP_SERIAL_RX_BUF_ERROR               ; Mask off Error status
                                   (1390)    and [COMP_SERIAL_fStatus], ~COMP_SERIAL_RX_BUF_ERROR
                                   (1391)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1392)    ret
                                   (1393) .ENDSECTION
                                   (1394) 
0DB3: 62 D0 00 MOV   REG[208],0    (1395) .SECTION
0DB6: 50 05    MOV   A,5           (1396) ;-----------------------------------------------------------------------------
0DB8: 02 72    ADD   A,[NUM_MODULES+2](1397) ;  FUNCTION NAME: COMP_SERIAL_bCmdLength
0DBA: 5C       MOV   X,A           (1398) ;
0DBB: 50 00    MOV   A,0           (1399) ;  DESCRIPTION:
                                   (1400) ;     Get length of command string
_main:
__text_start:
0DBE: 62 D0 00 MOV   REG[208],0    (1401) ;-----------------------------------------------------------------------------
0DC1: 55 71 00 MOV   [NUM_MODULES+1],0
0DC4: 55 70 00 MOV   [NUM_MODULES],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THC055~1\THESIS~1\main.c
(0118) // Author: Jason Tennyson
0DC7: 62 D0 00 MOV   REG[208],0
0DCA: 55 6F 01 MOV   [PREV_NUM_MODULES+1],1
0DCD: 55 6E 00 MOV   [PREV_NUM_MODULES],0
(0119) // Date: 8-3-11
0DD0: 62 D0 00 MOV   REG[208],0
0DD3: 55 6D 09 MOV   [SUGGESTED_NUM_MODULES+1],9
0DD6: 55 6C 00 MOV   [SUGGESTED_NUM_MODULES],0
(0120) // File: main.c
(0121) //
(0122) // This is the design for the parent module of Jason Tennyson's Thesis.
0DD9: 43 E0 20 OR    REG[224],32
(0123) // This design is made for a PSoC CY8C28433-24PVXI.
(0124) //
(0125) // Controller Packet Structure (each field is a byte)
0DDC: 71 01    OR    F,1
0DDE: 80 21    JMP   0x0E00
(0126) // -----------------------------------------------------
(0127) // All Packets:
(0128) // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0129) //
0DE0: 62 D0 00 MOV   REG[208],0
0DE3: 3C 70 00 CMP   [NUM_MODULES],0
0DE6: B0 0B    JNZ   0x0DF2
0DE8: 3C 71 00 CMP   [NUM_MODULES+1],0
0DEB: B0 06    JNZ   0x0DF2
(0130) // Servo Packet Structure (each field is a byte)
(0131) // -----------------------------------------------------
(0132) // Source Packets:
0DED: 7C 1A 63 LCALL _initializeChildren
(0133) // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
0DF0: 80 0F    JMP   0x0E00
(0134) //
0DF2: 10       PUSH  X
0DF3: 7C 0D 3B LCALL 0x0D3B
0DF6: 62 D0 00 MOV   REG[208],0
0DF9: 20       POP   X
0DFA: 39 00    CMP   A,0
0DFC: A0 03    JZ    0x0E00
(0135) // Return Packets:
(0136) // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
(0137) 
0DFE: 93 31    CALL  _decodeTransmission
0E00: 8F DF    JMP   0x0DE0
0E02: 8F FF    JMP   0x0E02
(0138) #include <m8c.h>        	// part specific constants and macros
(0139) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules
(0140) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
(0141) #include <stdlib.h>			// Required for string conversions to floats/ints and vice versa.
(0142) #include <string.h>
(0143) 
_pingModule:
  response             --> X+0
  module_id            --> X-5
0E04: 10       PUSH  X
0E05: 4F       MOV   X,SP
0E06: 38 02    ADD   SP,2
(0144) // These are declarations of all of the timer interrupts that are used for all configurations.
0E08: 56 01 00 MOV   [X+1],0
0E0B: 56 00 00 MOV   [X+0],0
(0145) #pragma interrupt_handler TX_TIMEOUT_ISR
0E0E: 50 00    MOV   A,0
0E10: 08       PUSH  A
0E11: 50 03    MOV   A,3
0E13: 08       PUSH  A
0E14: 7C 19 69 LCALL _configToggle
0E17: 38 FE    ADD   SP,254
(0146) #pragma interrupt_handler RX_TIMEOUT_ISR
0E19: 7C 1C 07 LCALL _txConfigWait
(0147) 
(0148) // These defines are used as parameters of the configToggle function.
(0149) // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
0E1C: 10       PUSH  X
0E1D: 50 FC    MOV   A,252
0E1F: 7C 09 20 LCALL 0x0920
0E22: 20       POP   X
(0150) #define		PC_MODE						(1)
0E23: 10       PUSH  X
0E24: 50 FC    MOV   A,252
0E26: 7C 09 20 LCALL 0x0920
0E29: 20       POP   X
(0151) #define		RX_MODE						(2)
0E2A: 10       PUSH  X
0E2B: 50 00    MOV   A,0
0E2D: 7C 09 20 LCALL 0x0920
0E30: 20       POP   X
(0152) #define		TX_MODE						(3)
0E31: 62 D0 00 MOV   REG[208],0
0E34: 52 FC    MOV   A,[X-4]
0E36: 10       PUSH  X
0E37: 7C 09 20 LCALL 0x0920
0E3A: 20       POP   X
(0153) 
0E3B: 10       PUSH  X
0E3C: 50 CB    MOV   A,203
0E3E: 7C 09 20 LCALL 0x0920
0E41: 20       POP   X
(0154) // These defines are used as comparisons to find what port the newest module is connected to.
0E42: 10       PUSH  X
0E43: 50 FD    MOV   A,253
0E45: 7C 09 20 LCALL 0x0920
0E48: 20       POP   X
(0155) #define		PORT_1						('1')
0E49: 10       PUSH  X
0E4A: 50 FD    MOV   A,253
0E4C: 7C 09 20 LCALL 0x0920
0E4F: 20       POP   X
(0156) #define		PORT_2						('2')
(0157) #define		PORT_3						('3')
(0158) #define		PORT_4						('4')
0E50: 10       PUSH  X
0E51: 7C 08 F3 LCALL 0x08F3
0E54: 62 D0 00 MOV   REG[208],0
0E57: 20       POP   X
0E58: 53 67    MOV   [__r0],A
0E5A: 47 67 20 TST   [__r0],32
0E5D: AF F2    JZ    0x0E50
(0159) 
(0160) // These defines are used as transmission indicators.
(0161) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
0E5F: 7C 1B E8 LCALL _xmitWait
(0162) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0163) #define		HELLO_BYTE					(200)	// Indicates master is ready to talk.
(0164) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the master.
0E62: 91 C0    CALL  _validResponse
0E64: 62 D0 00 MOV   REG[208],0
0E67: 3C 67 00 CMP   [__r0],0
0E6A: B0 06    JNZ   0x0E71
0E6C: 3C 66 00 CMP   [__r1],0
0E6F: A0 2D    JZ    0x0E9D
(0165) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is acknowledged.
(0166) #define		PING						(203)	// Indicates that someone is pinging someone else.
0E71: 62 D0 00 MOV   REG[208],0
0E74: 3C 73 CB CMP   [COMMAND_TYPE],203
0E77: B0 25    JNZ   0x0E9D
(0167) #define		CLEAR						(204)	// Indicates that the master is asking for a config clear.
(0168) #define		MASTER_ID					(0)		// The master node's ID.
(0169) #define		BROADCAST					(254)	// The broadcast ID for talking to all nodes.
0E79: 62 D0 00 MOV   REG[208],0
0E7C: 3C 74 00 CMP   [COMMAND_DESTINATION],0
0E7F: B0 1D    JNZ   0x0E9D
(0170) #define		BLANK_MODULE_ID				(251)	// This is the ID of an unconfigured module.
(0171) #define		SERVO_START					(255)	// The start byte of a servo transmission.
0E81: 62 D0 00 MOV   REG[208],0
0E84: 51 76    MOV   A,[COMMAND_SOURCE]
0E86: 62 D0 00 MOV   REG[208],0
0E89: 53 66    MOV   [__r1],A
0E8B: 50 00    MOV   A,0
0E8D: 3B FB    CMP   A,[X-5]
0E8F: B0 0D    JNZ   0x0E9D
0E91: 51 66    MOV   A,[__r1]
0E93: 3B FC    CMP   A,[X-4]
0E95: B0 07    JNZ   0x0E9D
(0172) 
(0173) // These defines are used to fill in the instruction we are using on the servo.
0E97: 56 01 01 MOV   [X+1],1
0E9A: 56 00 00 MOV   [X+0],0
(0174) #define		PING_SERVO					(1)		// This is the instruction number for ping.
(0175) #define		READ_SERVO					(2)		// This is the instruction number for a read.
(0176) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0177) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
(0178) 
(0179) // These defines are used for transmission timing.
0E9D: 62 D0 00 MOV   REG[208],0
0EA0: 52 01    MOV   A,[X+1]
0EA2: 53 66    MOV   [__r1],A
0EA4: 52 00    MOV   A,[X+0]
0EA6: 53 67    MOV   [__r0],A
0EA8: 38 FE    ADD   SP,254
0EAA: 20       POP   X
0EAB: 7F       RET   
(0180) #define 	RX_TIMEOUT_DURATION			(3)		// This is receive wait time in ms.
(0181) #define		POST_RX_WAIT				(10)	// Wait time after a controller responds in ms.
(0182) #define		SERVO_FIND_TIME				(24)	// The wait time after issuing clear config in ms.
(0183) #define		MAX_TIMEOUTS				(50)	// Number of timeouts allowed before hello mode exit.
_assignID:
  success              --> X+0
  assigned_ID          --> X-5
0EAC: 10       PUSH  X
0EAD: 4F       MOV   X,SP
0EAE: 38 02    ADD   SP,2
(0184) 
0EB0: 56 01 00 MOV   [X+1],0
0EB3: 56 00 00 MOV   [X+0],0
(0185) // This is the maximum number of allowable modules per branch out from the master
0EB6: 50 00    MOV   A,0
0EB8: 08       PUSH  A
0EB9: 50 03    MOV   A,3
0EBB: 08       PUSH  A
0EBC: 7C 19 69 LCALL _configToggle
0EBF: 38 FE    ADD   SP,254
(0186) #define		MAX_MODULES					(9)
0EC1: 7C 1C 07 LCALL _txConfigWait
(0187) 
(0188) // This function receives a mode identifier as a parameter and toggles the
(0189) // system configuration between receive and transmit modes for half duplex UART.
0EC4: 10       PUSH  X
0EC5: 50 FC    MOV   A,252
0EC7: 7C 09 20 LCALL 0x0920
0ECA: 20       POP   X
(0190) void configToggle(int mode);
0ECB: 10       PUSH  X
0ECC: 50 FC    MOV   A,252
0ECE: 7C 09 20 LCALL 0x0920
0ED1: 20       POP   X
(0191) // Transmits a hello message.
0ED2: 10       PUSH  X
0ED3: 50 00    MOV   A,0
0ED5: 7C 09 20 LCALL 0x0920
0ED8: 20       POP   X
(0192) void sayHello(void);
0ED9: 10       PUSH  X
0EDA: 50 FB    MOV   A,251
0EDC: 7C 09 20 LCALL 0x0920
0EDF: 20       POP   X
(0193) // This function pings the index passed to it. Returns 1 on success, 0 on fail.
0EE0: 10       PUSH  X
0EE1: 50 C9    MOV   A,201
0EE3: 7C 09 20 LCALL 0x0920
0EE6: 20       POP   X
(0194) int pingModule(int module_id);
0EE7: 62 D0 00 MOV   REG[208],0
0EEA: 52 FC    MOV   A,[X-4]
0EEC: 10       PUSH  X
0EED: 7C 09 20 LCALL 0x0920
0EF0: 20       POP   X
(0195) // This function assigns an ID to a module.
0EF1: 10       PUSH  X
0EF2: 50 FD    MOV   A,253
0EF4: 7C 09 20 LCALL 0x0920
0EF7: 20       POP   X
(0196) int assignID(int assigned_ID);
0EF8: 10       PUSH  X
0EF9: 50 FD    MOV   A,253
0EFB: 7C 09 20 LCALL 0x0920
0EFE: 20       POP   X
(0197) // Performs a non-blocking read operation on a data packet that has come from a controller.
(0198) int validResponse(void);
(0199) // Performs a data packet decode on a transmission from an external computer.
0EFF: 10       PUSH  X
0F00: 7C 08 F3 LCALL 0x08F3
0F03: 62 D0 00 MOV   REG[208],0
0F06: 20       POP   X
0F07: 53 67    MOV   [__r0],A
0F09: 47 67 20 TST   [__r0],32
0F0C: AF F2    JZ    0x0EFF
(0200) // This function also performs the desired operation when it is finished decoding.
(0201) void decodeTransmission(void);
(0202) // Performs a standard read or write command to a servo.
0F0E: 7C 1B E8 LCALL _xmitWait
(0203) void servoInstruction(char id, char length, char instruction, char address, char value);
(0204) // Performs a write command to a servo value that is larger than one byte long.
(0205) void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
0F11: 91 11    CALL  _validResponse
0F13: 62 D0 00 MOV   REG[208],0
0F16: 3C 67 00 CMP   [__r0],0
0F19: B0 06    JNZ   0x0F20
0F1B: 3C 66 00 CMP   [__r1],0
0F1E: A0 2D    JZ    0x0F4C
(0206) // Sends out a request to clear all information and start over.
(0207) void clearConfig(void);
0F20: 62 D0 00 MOV   REG[208],0
0F23: 3C 73 CA CMP   [COMMAND_TYPE],202
0F26: B0 25    JNZ   0x0F4C
(0208) // This function checks the current mode and unloads the configuration for that mode.
(0209) void unloadAllConfigs(void);
(0210) // This function unloads the configuration corresponding to the number passed to it.
0F28: 62 D0 00 MOV   REG[208],0
0F2B: 3C 74 00 CMP   [COMMAND_DESTINATION],0
0F2E: B0 1D    JNZ   0x0F4C
(0211) void unloadConfig(int config_num);
(0212) // Initialization function for the slave module controllers.
0F30: 62 D0 00 MOV   REG[208],0
0F33: 51 76    MOV   A,[COMMAND_SOURCE]
0F35: 62 D0 00 MOV   REG[208],0
0F38: 53 66    MOV   [__r1],A
0F3A: 50 00    MOV   A,0
0F3C: 3B FB    CMP   A,[X-5]
0F3E: B0 0D    JNZ   0x0F4C
0F40: 51 66    MOV   A,[__r1]
0F42: 3B FC    CMP   A,[X-4]
0F44: B0 07    JNZ   0x0F4C
(0213) void initializeChildren(void);
(0214) // A single initialization sweep.
0F46: 56 01 01 MOV   [X+1],1
0F49: 56 00 00 MOV   [X+0],0
(0215) int initSweep(void);
(0216) // Static wait time of approximately 50 microseconds for use after starting a transmission.
(0217) void xmitWait(void);
(0218) // This is a wait that is approximately 1 ms long, used to wait before transmitting to children.
(0219) void txConfigWait(void);
(0220) 
0F4C: 62 D0 00 MOV   REG[208],0
0F4F: 52 01    MOV   A,[X+1]
0F51: 53 66    MOV   [__r1],A
0F53: 52 00    MOV   A,[X+0]
0F55: 53 67    MOV   [__r0],A
0F57: 38 FE    ADD   SP,254
0F59: 20       POP   X
0F5A: 7F       RET   
(0221) int NUM_MODULES;			// Stores the number of modules that have been discovered.
(0222) int PREV_NUM_MODULES;		// Stores the previous number of modules that has been discovered.
(0223) int SUGGESTED_NUM_MODULES;	// Stores the module number that is suggested from the PC.
(0224) char COMMAND_SOURCE;		// Stores who the current command is from.
(0225) char COMMAND_DESTINATION;	// Stores who the current command is for.
_clearConfig:
0F5B: 50 00    MOV   A,0
0F5D: 08       PUSH  A
0F5E: 50 03    MOV   A,3
0F60: 08       PUSH  A
0F61: 7C 19 69 LCALL _configToggle
0F64: 38 FE    ADD   SP,254
(0226) char COMMAND_TYPE;			// Stores the type of command that was just read.
0F66: 7C 1C 07 LCALL _txConfigWait
(0227) char PARAM[10];				// Stores a parameters that accompanies the command (if any).
(0228) int STATE;					// Stores the current configuration state of the system.
(0229) int TIMEOUT;				// This flag is set if there is a timeout.
0F69: 10       PUSH  X
0F6A: 50 FC    MOV   A,252
0F6C: 7C 09 20 LCALL 0x0920
0F6F: 20       POP   X
(0230) 
0F70: 10       PUSH  X
0F71: 50 FC    MOV   A,252
0F73: 7C 09 20 LCALL 0x0920
0F76: 20       POP   X
(0231) void main()
0F77: 10       PUSH  X
0F78: 50 00    MOV   A,0
0F7A: 7C 09 20 LCALL 0x0920
0F7D: 20       POP   X
(0232) {	
0F7E: 10       PUSH  X
0F7F: 50 FE    MOV   A,254
0F81: 7C 09 20 LCALL 0x0920
0F84: 20       POP   X
(0233) 	// Initialize the number of modules.
0F85: 10       PUSH  X
0F86: 50 CC    MOV   A,204
0F88: 7C 09 20 LCALL 0x0920
0F8B: 20       POP   X
(0234) 	NUM_MODULES = 0;
0F8C: 10       PUSH  X
0F8D: 50 FD    MOV   A,253
0F8F: 7C 09 20 LCALL 0x0920
0F92: 20       POP   X
(0235) 	PREV_NUM_MODULES = 1;
0F93: 10       PUSH  X
0F94: 50 FD    MOV   A,253
0F96: 7C 09 20 LCALL 0x0920
0F99: 20       POP   X
(0236) 	SUGGESTED_NUM_MODULES = MAX_MODULES;
(0237) 	
(0238) 	// Activate GPIO ISR.
0F9A: 10       PUSH  X
0F9B: 7C 08 F3 LCALL 0x08F3
0F9E: 62 D0 00 MOV   REG[208],0
0FA1: 20       POP   X
0FA2: 53 67    MOV   [__r0],A
0FA4: 47 67 20 TST   [__r0],32
0FA7: AF F2    JZ    0x0F9A
(0239) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
(0240) 	
(0241) 	// Turn on global interrupts for the transmission timeout timer.
0FA9: 7C 1B E8 LCALL _xmitWait
(0242) 	M8C_EnableGInt;
(0243) 	
(0244) 	while(1)
0FAC: 50 00    MOV   A,0
0FAE: 08       PUSH  A
0FAF: 50 02    MOV   A,2
0FB1: 08       PUSH  A
0FB2: 7C 19 69 LCALL _configToggle
0FB5: 38 FE    ADD   SP,254
(0245) 	{
0FB7: 62 D0 00 MOV   REG[208],0
0FBA: 51 6B    MOV   A,[TIMEOUT+1]
0FBC: 11 18    SUB   A,24
0FBE: 51 6A    MOV   A,[TIMEOUT]
0FC0: 31 80    XOR   A,128
0FC2: 19 80    SBB   A,128
0FC4: CF F2    JC    0x0FB7
0FC6: 7F       RET   
(0246) 		if(!NUM_MODULES)
(0247) 		{
(0248) 			// Find some modules.
(0249) 			initializeChildren();
(0250) 		}
(0251) 		else if(COMP_SERIAL_bCmdCheck())
_sayHello:
0FC7: 50 00    MOV   A,0
0FC9: 08       PUSH  A
0FCA: 50 03    MOV   A,3
0FCC: 08       PUSH  A
0FCD: 7C 19 69 LCALL _configToggle
0FD0: 38 FE    ADD   SP,254
(0252) 		{
0FD2: 7C 1C 07 LCALL _txConfigWait
(0253) 			// If there's a computer command, read it.
(0254) 			decodeTransmission();
(0255) 		}
0FD5: 10       PUSH  X
0FD6: 50 FC    MOV   A,252
0FD8: 7C 09 20 LCALL 0x0920
0FDB: 20       POP   X
(0256) 	}
0FDC: 10       PUSH  X
0FDD: 50 FC    MOV   A,252
0FDF: 7C 09 20 LCALL 0x0920
0FE2: 20       POP   X
(0257) }
0FE3: 10       PUSH  X
0FE4: 50 00    MOV   A,0
0FE6: 7C 09 20 LCALL 0x0920
0FE9: 20       POP   X
(0258) 
0FEA: 10       PUSH  X
0FEB: 50 FB    MOV   A,251
0FED: 7C 09 20 LCALL 0x0920
0FF0: 20       POP   X
(0259) int pingModule(int module_id)
0FF1: 10       PUSH  X
0FF2: 50 C8    MOV   A,200
0FF4: 7C 09 20 LCALL 0x0920
0FF7: 20       POP   X
(0260) {
0FF8: 10       PUSH  X
0FF9: 50 FD    MOV   A,253
0FFB: 7C 09 20 LCALL 0x0920
0FFE: 20       POP   X
(0261) 	int response = 0;		// Initialize the response to a fail.
0FFF: 10       PUSH  X
1000: 50 FD    MOV   A,253
1002: 7C 09 20 LCALL 0x0920
1005: 20       POP   X
(0262) 	configToggle(TX_MODE);	// Toggle into TX mode.
(0263) 	txConfigWait();			// Wait 1 ms, in case this ping function is called in a loop.
(0264) 	
1006: 10       PUSH  X
1007: 7C 08 F3 LCALL 0x08F3
100A: 62 D0 00 MOV   REG[208],0
100D: 20       POP   X
100E: 53 67    MOV   [__r0],A
1010: 47 67 20 TST   [__r0],32
1013: AF F2    JZ    0x1006
(0265) 	// Transmit a hello.
(0266) 	TRANSMIT_PutChar(START_TRANSMIT);
(0267) 	TRANSMIT_PutChar(START_TRANSMIT);
1015: 7C 1B E8 LCALL _xmitWait
(0268) 	TRANSMIT_PutChar(MASTER_ID);
(0269) 	TRANSMIT_PutChar(module_id);
(0270) 	TRANSMIT_PutChar(PING);
1018: 50 00    MOV   A,0
101A: 08       PUSH  A
101B: 50 02    MOV   A,2
101D: 08       PUSH  A
101E: 7C 19 69 LCALL _configToggle
1021: 38 FE    ADD   SP,254
1023: 7F       RET   
(0271) 	TRANSMIT_PutChar(END_TRANSMIT);
(0272) 	TRANSMIT_PutChar(END_TRANSMIT);
(0273) 	
(0274) 	// Wait for the transmission to finish.
(0275) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
_validResponse:
  valid_transmit       --> X+3
  i                    --> X+1
  tempByte             --> X+0
1024: 10       PUSH  X
1025: 4F       MOV   X,SP
1026: 38 05    ADD   SP,5
(0276) 	
1028: 56 04 00 MOV   [X+4],0
102B: 56 03 00 MOV   [X+3],0
(0277) 	// Wait an additional amount of time to be sure.
102E: 56 02 00 MOV   [X+2],0
1031: 56 01 00 MOV   [X+1],0
(0278) 	xmitWait();
1034: 56 00 00 MOV   [X+0],0
(0279) 
(0280) 	// If we get a valid response, check the extracted parameters for what we want.
1037: 50 00    MOV   A,0
1039: 08       PUSH  A
103A: 50 02    MOV   A,2
103C: 08       PUSH  A
103D: 7C 19 69 LCALL _configToggle
1040: 38 FE    ADD   SP,254
1042: 80 C2    JMP   0x1105
(0281) 	if(validResponse())
(0282) 	{
(0283) 		if(COMMAND_TYPE == PING)
(0284) 		{
(0285) 			// If this is for me, check who it was from.
(0286) 			if(COMMAND_DESTINATION == MASTER_ID)
(0287) 			{
(0288) 				if(COMMAND_SOURCE == module_id)
1044: 10       PUSH  X
1045: 7C 0A 98 LCALL 0x0A98
1048: 62 D0 00 MOV   REG[208],0
104B: 20       POP   X
104C: 39 FC    CMP   A,252
104E: B0 B6    JNZ   0x1105
(0289) 				{
1050: 80 A5    JMP   0x10F6
(0290) 					response = 1;
(0291) 				}
(0292) 			}
1052: 10       PUSH  X
1053: 7C 0A 98 LCALL 0x0A98
1056: 62 D0 00 MOV   REG[208],0
1059: 20       POP   X
105A: 39 FC    CMP   A,252
105C: B0 99    JNZ   0x10F6
(0293) 		}
105E: 80 88    JMP   0x10E7
(0294) 	}
(0295) 	
(0296) 	return response;
1060: 10       PUSH  X
1061: 7C 0A 98 LCALL 0x0A98
1064: 20       POP   X
1065: 54 00    MOV   [X+0],A
1067: 39 00    CMP   A,0
1069: A0 7D    JZ    0x10E7
(0297) }
(0298) 
106B: 52 00    MOV   A,[X+0]
106D: 62 D0 00 MOV   REG[208],0
1070: 53 76    MOV   [COMMAND_SOURCE],A
1072: 80 65    JMP   0x10D8
(0299) int assignID(int assigned_ID)
(0300) {
(0301) 	int success = 0;		// Stores 0 on fail, 1 on success.
(0302) 	configToggle(TX_MODE);	// Switch to TX mode.
1074: 10       PUSH  X
1075: 7C 0A 98 LCALL 0x0A98
1078: 62 D0 00 MOV   REG[208],0
107B: 20       POP   X
107C: 54 00    MOV   [X+0],A
107E: 39 00    CMP   A,0
1080: A0 57    JZ    0x10D8
(0303) 	txConfigWait();			// Wait 1 ms in case this function is called multiple times.
(0304) 	
1082: 3D 00 C8 CMP   [X+0],200
1085: C0 52    JC    0x10D8
(0305) 	// Transmit the assignment.
(0306) 	TRANSMIT_PutChar(START_TRANSMIT);
1087: 52 00    MOV   A,[X+0]
1089: 62 D0 00 MOV   REG[208],0
108C: 53 73    MOV   [COMMAND_TYPE],A
108E: 80 3A    JMP   0x10C9
(0307) 	TRANSMIT_PutChar(START_TRANSMIT);
(0308) 	TRANSMIT_PutChar(MASTER_ID);
(0309) 	TRANSMIT_PutChar(BLANK_MODULE_ID);
(0310) 	TRANSMIT_PutChar(ID_ASSIGNMENT);
1090: 10       PUSH  X
1091: 7C 0A 98 LCALL 0x0A98
1094: 62 D0 00 MOV   REG[208],0
1097: 20       POP   X
1098: 54 00    MOV   [X+0],A
109A: 39 00    CMP   A,0
109C: A0 2C    JZ    0x10C9
(0311) 	TRANSMIT_PutChar(assigned_ID);
(0312) 	TRANSMIT_PutChar(END_TRANSMIT);
109E: 3D 00 FD CMP   [X+0],253
10A1: A0 18    JZ    0x10BA
(0313) 	TRANSMIT_PutChar(END_TRANSMIT);
(0314) 	
10A3: 52 02    MOV   A,[X+2]
10A5: 01 55    ADD   A,85
10A7: 53 66    MOV   [__r1],A
10A9: 52 01    MOV   A,[X+1]
10AB: 09 00    ADC   A,0
10AD: 60 D5    MOV   REG[213],A
10AF: 52 00    MOV   A,[X+0]
10B1: 3F 66    MVI   [__r1],A
(0315) 	// Wait for the transmission to finish.
10B3: 77 02    INC   [X+2]
10B5: 0F 01 00 ADC   [X+1],0
(0316) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
10B8: 80 10    JMP   0x10C9
(0317) 	
(0318) 	// Wait an additional amount of time to make sure the xmit gets out.
(0319) 	xmitWait();
10BA: 56 04 01 MOV   [X+4],1
10BD: 56 03 00 MOV   [X+3],0
(0320) 	
10C0: 62 D0 00 MOV   REG[208],0
10C3: 55 6B 03 MOV   [TIMEOUT+1],3
10C6: 55 6A 00 MOV   [TIMEOUT],0
10C9: 62 D0 00 MOV   REG[208],0
10CC: 51 6B    MOV   A,[TIMEOUT+1]
10CE: 11 03    SUB   A,3
10D0: 51 6A    MOV   A,[TIMEOUT]
10D2: 31 80    XOR   A,128
10D4: 19 80    SBB   A,128
10D6: CF B9    JC    0x1090
10D8: 62 D0 00 MOV   REG[208],0
10DB: 51 6B    MOV   A,[TIMEOUT+1]
10DD: 11 03    SUB   A,3
10DF: 51 6A    MOV   A,[TIMEOUT]
10E1: 31 80    XOR   A,128
10E3: 19 80    SBB   A,128
10E5: CF 8E    JC    0x1074
10E7: 62 D0 00 MOV   REG[208],0
10EA: 51 6B    MOV   A,[TIMEOUT+1]
10EC: 11 03    SUB   A,3
10EE: 51 6A    MOV   A,[TIMEOUT]
10F0: 31 80    XOR   A,128
10F2: 19 80    SBB   A,128
10F4: CF 6B    JC    0x1060
10F6: 62 D0 00 MOV   REG[208],0
10F9: 51 6B    MOV   A,[TIMEOUT+1]
10FB: 11 03    SUB   A,3
10FD: 51 6A    MOV   A,[TIMEOUT]
10FF: 31 80    XOR   A,128
1101: 19 80    SBB   A,128
1103: CF 4E    JC    0x1052
1105: 62 D0 00 MOV   REG[208],0
1108: 51 6B    MOV   A,[TIMEOUT+1]
110A: 11 03    SUB   A,3
110C: 51 6A    MOV   A,[TIMEOUT]
110E: 31 80    XOR   A,128
1110: 19 80    SBB   A,128
1112: CF 31    JC    0x1044
(0321) 	// If we read a valid response, check the extracted parameters for what we want.
(0322) 	if(validResponse())
(0323) 	{
(0324) 		if(COMMAND_TYPE == ID_ASSIGN_OK)
(0325) 		{
(0326) 			// If this is for me, check who it was from.
(0327) 			if(COMMAND_DESTINATION == MASTER_ID)
(0328) 			{
(0329) 				if(COMMAND_SOURCE == assigned_ID)
(0330) 				{
(0331) 					success = 1;
(0332) 				}
(0333) 			}
(0334) 		}
1114: 10       PUSH  X
1115: 7C 09 B1 LCALL 0x09B1
1118: 20       POP   X
(0335) 	}
1119: 62 D0 00 MOV   REG[208],0
111C: 55 6B 00 MOV   [TIMEOUT+1],0
111F: 55 6A 00 MOV   [TIMEOUT],0
(0336) 	
(0337) 	return success;
1122: 62 D0 00 MOV   REG[208],0
1125: 52 04    MOV   A,[X+4]
1127: 53 66    MOV   [__r1],A
1129: 52 03    MOV   A,[X+3]
112B: 53 67    MOV   [__r0],A
112D: 38 FB    ADD   SP,251
112F: 20       POP   X
1130: 7F       RET   
(0338) }
(0339) 
(0340) void clearConfig(void)
(0341) {
(0342) 	configToggle(TX_MODE);	// Toggle into TX mode.
_decodeTransmission:
  speed                --> X+10
  angle                --> X+8
  tempByte             --> X+7
  total                --> X+5
  ID                   --> X+4
  runningTotal         --> X+2
  param                --> X+0
1131: 10       PUSH  X
1132: 4F       MOV   X,SP
1133: 38 0C    ADD   SP,12
(0343) 	txConfigWait();			// Wait 1 ms.
(0344) 	
1135: 56 04 00 MOV   [X+4],0
(0345) 	// Transmit a clear.
(0346) 	TRANSMIT_PutChar(START_TRANSMIT);
(0347) 	TRANSMIT_PutChar(START_TRANSMIT);
(0348) 	TRANSMIT_PutChar(MASTER_ID);
1138: 56 06 00 MOV   [X+6],0
113B: 56 05 00 MOV   [X+5],0
(0349) 	TRANSMIT_PutChar(BROADCAST);
113E: 56 03 00 MOV   [X+3],0
1141: 56 02 00 MOV   [X+2],0
(0350) 	TRANSMIT_PutChar(CLEAR);
(0351) 	TRANSMIT_PutChar(END_TRANSMIT);
1144: 10       PUSH  X
1145: 7C 0D 54 LCALL 0x0D54
1148: 62 D0 00 MOV   REG[208],0
114B: 53 67    MOV   [__r0],A
114D: 5A 66    MOV   [__r1],X
114F: 20       POP   X
1150: 51 66    MOV   A,[__r1]
1152: 54 01    MOV   [X+1],A
1154: 51 67    MOV   A,[__r0]
1156: 54 00    MOV   [X+0],A
1158: 3C 67 00 CMP   [__r0],0
115B: B0 06    JNZ   0x1162
115D: 3C 66 00 CMP   [__r1],0
1160: A6 89    JZ    0x17EA
(0352) 	TRANSMIT_PutChar(END_TRANSMIT);
(0353) 	
1162: 62 D0 00 MOV   REG[208],0
1165: 52 01    MOV   A,[X+1]
1167: 53 66    MOV   [__r1],A
1169: 52 00    MOV   A,[X+0]
116B: 60 D4    MOV   REG[212],A
116D: 3E 66    MVI   A,[__r1]
116F: 53 66    MOV   [__r1],A
1171: 55 67 00 MOV   [__r0],0
1174: 3C 67 00 CMP   [__r0],0
1177: B0 05    JNZ   0x117D
1179: 39 78    CMP   A,120
117B: A0 0E    JZ    0x118A
117D: 62 D0 00 MOV   REG[208],0
1180: 3C 67 00 CMP   [__r0],0
1183: B0 99    JNZ   0x121D
1185: 3C 66 58 CMP   [__r1],88
1188: B0 94    JNZ   0x121D
(0354) 	// Wait for the transmission to finish.
(0355) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
(0356) 	
118A: 62 D0 00 MOV   REG[208],0
118D: 55 71 00 MOV   [NUM_MODULES+1],0
1190: 55 70 00 MOV   [NUM_MODULES],0
(0357) 	// Wait an additional amount of time to make sure that our xmit got out.
1193: 10       PUSH  X
1194: 7C 0D 54 LCALL 0x0D54
1197: 62 D0 00 MOV   REG[208],0
119A: 53 67    MOV   [__r0],A
119C: 5A 66    MOV   [__r1],X
119E: 20       POP   X
119F: 51 66    MOV   A,[__r1]
11A1: 54 01    MOV   [X+1],A
11A3: 51 67    MOV   A,[__r0]
11A5: 54 00    MOV   [X+0],A
11A7: 3C 67 00 CMP   [__r0],0
11AA: B0 06    JNZ   0x11B1
11AC: 3C 66 00 CMP   [__r1],0
11AF: A0 59    JZ    0x1209
(0358) 	xmitWait();
(0359) 	
11B1: 62 D0 00 MOV   REG[208],0
11B4: 52 01    MOV   A,[X+1]
11B6: 53 66    MOV   [__r1],A
11B8: 52 00    MOV   A,[X+0]
11BA: 60 D4    MOV   REG[212],A
11BC: 3E 66    MVI   A,[__r1]
11BE: 53 66    MOV   [__r1],A
11C0: 55 67 00 MOV   [__r0],0
11C3: 11 31    SUB   A,49
11C5: 50 00    MOV   A,0
11C7: 31 80    XOR   A,128
11C9: 19 80    SBB   A,128
11CB: C6 1E    JC    0x17EA
11CD: 62 D0 00 MOV   REG[208],0
11D0: 50 39    MOV   A,57
11D2: 12 66    SUB   A,[__r1]
11D4: 51 67    MOV   A,[__r0]
11D6: 31 80    XOR   A,128
11D8: 53 61    MOV   [__rX],A
11DA: 50 80    MOV   A,128
11DC: 1A 61    SBB   A,[__rX]
11DE: C6 0B    JC    0x17EA
(0360) 	// Wait for servo find time to allow the children to reset.
(0361) 	configToggle(RX_MODE);
11E0: 62 D0 00 MOV   REG[208],0
11E3: 52 01    MOV   A,[X+1]
11E5: 53 66    MOV   [__r1],A
11E7: 52 00    MOV   A,[X+0]
11E9: 60 D4    MOV   REG[212],A
11EB: 3E 66    MVI   A,[__r1]
11ED: 11 30    SUB   A,48
11EF: 62 D0 00 MOV   REG[208],0
11F2: 53 6F    MOV   [PREV_NUM_MODULES+1],A
11F4: 50 00    MOV   A,0
11F6: 19 00    SBB   A,0
11F8: 53 6E    MOV   [PREV_NUM_MODULES],A
(0362) 	while(TIMEOUT < SERVO_FIND_TIME) { }
11FA: 51 6F    MOV   A,[PREV_NUM_MODULES+1]
11FC: 08       PUSH  A
11FD: 51 6E    MOV   A,[PREV_NUM_MODULES]
11FF: 62 D0 00 MOV   REG[208],0
1202: 53 6C    MOV   [SUGGESTED_NUM_MODULES],A
1204: 18       POP   A
1205: 53 6D    MOV   [SUGGESTED_NUM_MODULES+1],A
(0363) }
(0364) 
1207: 85 E2    JMP   0x17EA
(0365) // This function transmits a hello message.
(0366) void sayHello(void)
(0367) {
1209: 62 D0 00 MOV   REG[208],0
120C: 55 6F 01 MOV   [PREV_NUM_MODULES+1],1
120F: 55 6E 00 MOV   [PREV_NUM_MODULES],0
(0368) 	configToggle(TX_MODE);	// Toggle into TX mode.
1212: 62 D0 00 MOV   REG[208],0
1215: 55 6D 09 MOV   [SUGGESTED_NUM_MODULES+1],9
1218: 55 6C 00 MOV   [SUGGESTED_NUM_MODULES],0
(0369) 	txConfigWait();			// Wait 1 ms so that this function can be called in a loop.
(0370) 	
121B: 85 CE    JMP   0x17EA
(0371) 	// Transmit a hello.
121D: 62 D0 00 MOV   REG[208],0
1220: 52 01    MOV   A,[X+1]
1222: 53 66    MOV   [__r1],A
1224: 52 00    MOV   A,[X+0]
1226: 60 D4    MOV   REG[212],A
1228: 3E 66    MVI   A,[__r1]
122A: 53 66    MOV   [__r1],A
122C: 55 67 00 MOV   [__r0],0
122F: 3C 67 00 CMP   [__r0],0
1232: B0 05    JNZ   0x1238
1234: 39 6E    CMP   A,110
1236: A0 0E    JZ    0x1245
1238: 62 D0 00 MOV   REG[208],0
123B: 3C 67 00 CMP   [__r0],0
123E: B0 35    JNZ   0x1274
1240: 3C 66 4E CMP   [__r1],78
1243: B0 30    JNZ   0x1274
(0372) 	TRANSMIT_PutChar(START_TRANSMIT);
(0373) 	TRANSMIT_PutChar(START_TRANSMIT);
(0374) 	TRANSMIT_PutChar(MASTER_ID);
1245: 50 00    MOV   A,0
1247: 08       PUSH  A
1248: 50 0A    MOV   A,10
124A: 08       PUSH  A
124B: 62 D0 00 MOV   REG[208],0
124E: 51 70    MOV   A,[NUM_MODULES]
1250: 08       PUSH  A
1251: 51 71    MOV   A,[NUM_MODULES+1]
1253: 08       PUSH  A
1254: 52 00    MOV   A,[X+0]
1256: 08       PUSH  A
1257: 52 01    MOV   A,[X+1]
1259: 08       PUSH  A
125A: 7C 1E 70 LCALL _itoa
125D: 38 FA    ADD   SP,250
(0375) 	TRANSMIT_PutChar(BLANK_MODULE_ID);
125F: 10       PUSH  X
1260: 52 00    MOV   A,[X+0]
1262: 08       PUSH  A
1263: 52 01    MOV   A,[X+1]
1265: 5C       MOV   X,A
1266: 18       POP   A
1267: 7C 0C A4 LCALL 0x0CA4
126A: 20       POP   X
(0376) 	TRANSMIT_PutChar(HELLO_BYTE);
126B: 10       PUSH  X
126C: 50 0A    MOV   A,10
126E: 7C 0C 67 LCALL 0x0C67
1271: 20       POP   X
(0377) 	TRANSMIT_PutChar(END_TRANSMIT);
1272: 85 77    JMP   0x17EA
(0378) 	TRANSMIT_PutChar(END_TRANSMIT);
1274: 62 D0 00 MOV   REG[208],0
1277: 52 01    MOV   A,[X+1]
1279: 53 66    MOV   [__r1],A
127B: 52 00    MOV   A,[X+0]
127D: 60 D4    MOV   REG[212],A
127F: 3E 66    MVI   A,[__r1]
1281: 53 66    MOV   [__r1],A
1283: 55 67 00 MOV   [__r0],0
1286: 3C 67 00 CMP   [__r0],0
1289: B0 05    JNZ   0x128F
128B: 39 77    CMP   A,119
128D: A0 0E    JZ    0x129C
128F: 62 D0 00 MOV   REG[208],0
1292: 3C 67 00 CMP   [__r0],0
1295: B2 14    JNZ   0x14AA
1297: 3C 66 57 CMP   [__r1],87
129A: B2 0F    JNZ   0x14AA
(0379) 	
(0380) 	// Wait for the transmission to finish.
129C: 10       PUSH  X
129D: 7C 0D 54 LCALL 0x0D54
12A0: 62 D0 00 MOV   REG[208],0
12A3: 53 67    MOV   [__r0],A
12A5: 5A 66    MOV   [__r1],X
12A7: 20       POP   X
12A8: 51 66    MOV   A,[__r1]
12AA: 54 01    MOV   [X+1],A
12AC: 51 67    MOV   A,[__r0]
12AE: 54 00    MOV   [X+0],A
12B0: 3C 67 00 CMP   [__r0],0
12B3: B0 06    JNZ   0x12BA
12B5: 3C 66 00 CMP   [__r1],0
12B8: A5 31    JZ    0x17EA
(0381) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
(0382) 	
12BA: 52 00    MOV   A,[X+0]
12BC: 08       PUSH  A
12BD: 52 01    MOV   A,[X+1]
12BF: 08       PUSH  A
12C0: 7C 1D 2F LCALL _atoi
12C3: 38 FE    ADD   SP,254
12C5: 62 D0 00 MOV   REG[208],0
12C8: 51 66    MOV   A,[__r1]
12CA: 54 04    MOV   [X+4],A
(0383) 	// Wait an additional amount of time to allow the xmit to get out.
(0384) 	xmitWait();
12CC: 10       PUSH  X
12CD: 7C 0D 54 LCALL 0x0D54
12D0: 62 D0 00 MOV   REG[208],0
12D3: 53 67    MOV   [__r0],A
12D5: 5A 66    MOV   [__r1],X
12D7: 20       POP   X
12D8: 51 66    MOV   A,[__r1]
12DA: 54 01    MOV   [X+1],A
12DC: 51 67    MOV   A,[__r0]
12DE: 54 00    MOV   [X+0],A
12E0: 3C 67 00 CMP   [__r0],0
12E3: B0 06    JNZ   0x12EA
12E5: 3C 66 00 CMP   [__r1],0
12E8: A5 01    JZ    0x17EA
(0385) 	
(0386) 	// Listen for the response.
12EA: 62 D0 00 MOV   REG[208],0
12ED: 52 01    MOV   A,[X+1]
12EF: 53 66    MOV   [__r1],A
12F1: 52 00    MOV   A,[X+0]
12F3: 60 D4    MOV   REG[212],A
12F5: 3E 66    MVI   A,[__r1]
12F7: 53 66    MOV   [__r1],A
12F9: 55 67 00 MOV   [__r0],0
12FC: 3C 67 00 CMP   [__r0],0
12FF: B0 05    JNZ   0x1305
1301: 39 61    CMP   A,97
1303: A0 0E    JZ    0x1312
1305: 62 D0 00 MOV   REG[208],0
1308: 3C 67 00 CMP   [__r0],0
130B: B0 84    JNZ   0x1390
130D: 3C 66 41 CMP   [__r1],65
1310: B0 7F    JNZ   0x1390
(0387) 	configToggle(RX_MODE);
(0388) }
1312: 10       PUSH  X
1313: 7C 0D 54 LCALL 0x0D54
1316: 62 D0 00 MOV   REG[208],0
1319: 53 67    MOV   [__r0],A
131B: 5A 66    MOV   [__r1],X
131D: 20       POP   X
131E: 51 66    MOV   A,[__r1]
1320: 54 01    MOV   [X+1],A
1322: 51 67    MOV   A,[__r0]
1324: 54 00    MOV   [X+0],A
1326: 3C 67 00 CMP   [__r0],0
1329: B0 06    JNZ   0x1330
132B: 3C 66 00 CMP   [__r1],0
132E: A4 BB    JZ    0x17EA
(0389) 
(0390) // This function returns whether or not a valid transmission has been received.
(0391) int validResponse(void)
1330: 52 00    MOV   A,[X+0]
1332: 08       PUSH  A
1333: 52 01    MOV   A,[X+1]
1335: 08       PUSH  A
1336: 7C 1D 2F LCALL _atoi
1339: 38 FE    ADD   SP,254
133B: 62 D0 00 MOV   REG[208],0
133E: 51 66    MOV   A,[__r1]
1340: 54 06    MOV   [X+6],A
1342: 51 67    MOV   A,[__r0]
1344: 54 05    MOV   [X+5],A
(0392) {
1346: 50 01    MOV   A,1
1348: 08       PUSH  A
1349: 50 00    MOV   A,0
134B: 08       PUSH  A
134C: 52 05    MOV   A,[X+5]
134E: 08       PUSH  A
134F: 52 06    MOV   A,[X+6]
1351: 08       PUSH  A
1352: 7C 1C 9D LCALL __divmod_16X16_16
1355: 38 FE    ADD   SP,254
1357: 18       POP   A
1358: 53 66    MOV   [__r1],A
135A: 18       POP   A
135B: 51 66    MOV   A,[__r1]
135D: 54 08    MOV   [X+8],A
(0393) 	int valid_transmit = 0;
135F: 50 01    MOV   A,1
1361: 08       PUSH  A
1362: 50 00    MOV   A,0
1364: 08       PUSH  A
1365: 52 05    MOV   A,[X+5]
1367: 08       PUSH  A
1368: 52 06    MOV   A,[X+6]
136A: 08       PUSH  A
136B: 7C 1C 9D LCALL __divmod_16X16_16
136E: 18       POP   A
136F: 53 66    MOV   [__r1],A
1371: 18       POP   A
1372: 38 FE    ADD   SP,254
1374: 51 66    MOV   A,[__r1]
1376: 54 09    MOV   [X+9],A
(0394) 	int i = 0;
1378: 52 09    MOV   A,[X+9]
137A: 08       PUSH  A
137B: 52 08    MOV   A,[X+8]
137D: 08       PUSH  A
137E: 50 1E    MOV   A,30
1380: 08       PUSH  A
1381: 50 03    MOV   A,3
1383: 08       PUSH  A
1384: 50 05    MOV   A,5
1386: 08       PUSH  A
1387: 52 04    MOV   A,[X+4]
1389: 08       PUSH  A
138A: 95 2C    CALL  _longServoInstruction
138C: 38 FA    ADD   SP,250
(0395) 	char tempByte = 0;
(0396) 	
138E: 84 5B    JMP   0x17EA
(0397) 	configToggle(RX_MODE);	// Listen for the response.
1390: 62 D0 00 MOV   REG[208],0
1393: 52 01    MOV   A,[X+1]
1395: 53 66    MOV   [__r1],A
1397: 52 00    MOV   A,[X+0]
1399: 60 D4    MOV   REG[212],A
139B: 3E 66    MVI   A,[__r1]
139D: 53 66    MOV   [__r1],A
139F: 55 67 00 MOV   [__r0],0
13A2: 3C 67 00 CMP   [__r0],0
13A5: B0 05    JNZ   0x13AB
13A7: 39 70    CMP   A,112
13A9: A0 0E    JZ    0x13B8
13AB: 62 D0 00 MOV   REG[208],0
13AE: 3C 67 00 CMP   [__r0],0
13B1: B0 45    JNZ   0x13F7
13B3: 3C 66 50 CMP   [__r1],80
13B6: B0 40    JNZ   0x13F7
(0398) 	
(0399) 	// The following code looks very nasty. Basically, while we haven't hit the rx timeout,
13B8: 10       PUSH  X
13B9: 7C 0D 54 LCALL 0x0D54
13BC: 62 D0 00 MOV   REG[208],0
13BF: 53 67    MOV   [__r0],A
13C1: 5A 66    MOV   [__r1],X
13C3: 20       POP   X
13C4: 51 66    MOV   A,[__r1]
13C6: 54 01    MOV   [X+1],A
13C8: 51 67    MOV   A,[__r0]
13CA: 54 00    MOV   [X+0],A
13CC: 3C 67 00 CMP   [__r0],0
13CF: B0 06    JNZ   0x13D6
13D1: 3C 66 00 CMP   [__r1],0
13D4: A4 15    JZ    0x17EA
(0400) 	// it checks the buffer for a command with non-blocking read commands. When the next byte
(0401) 	// is found, we enter another while loop to read for the next byte and so on. We do this
(0402) 	// so that the parent doesn't get stuck in rx mode when a child doesn't respond.
13D6: 52 00    MOV   A,[X+0]
13D8: 08       PUSH  A
13D9: 52 01    MOV   A,[X+1]
13DB: 08       PUSH  A
13DC: 7C 1D 2F LCALL _atoi
13DF: 62 D0 00 MOV   REG[208],0
13E2: 51 66    MOV   A,[__r1]
13E4: 08       PUSH  A
13E5: 50 18    MOV   A,24
13E7: 08       PUSH  A
13E8: 50 03    MOV   A,3
13EA: 08       PUSH  A
13EB: 50 04    MOV   A,4
13ED: 08       PUSH  A
13EE: 52 04    MOV   A,[X+4]
13F0: 08       PUSH  A
13F1: 94 22    CALL  _servoInstruction
13F3: 38 F9    ADD   SP,249
(0403) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0404) 	{
13F5: 83 F4    JMP   0x17EA
(0405) 		if(RECEIVE_cReadChar() == START_TRANSMIT)
13F7: 62 D0 00 MOV   REG[208],0
13FA: 52 01    MOV   A,[X+1]
13FC: 53 66    MOV   [__r1],A
13FE: 52 00    MOV   A,[X+0]
1400: 60 D4    MOV   REG[212],A
1402: 3E 66    MVI   A,[__r1]
1404: 53 66    MOV   [__r1],A
1406: 55 67 00 MOV   [__r0],0
1409: 3C 67 00 CMP   [__r0],0
140C: B0 05    JNZ   0x1412
140E: 39 73    CMP   A,115
1410: A0 0E    JZ    0x141F
1412: 62 D0 00 MOV   REG[208],0
1415: 3C 67 00 CMP   [__r0],0
1418: B3 D1    JNZ   0x17EA
141A: 3C 66 53 CMP   [__r1],83
141D: B3 CC    JNZ   0x17EA
(0406) 		{
(0407) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
141F: 10       PUSH  X
1420: 7C 0D 54 LCALL 0x0D54
1423: 62 D0 00 MOV   REG[208],0
1426: 53 67    MOV   [__r0],A
1428: 5A 66    MOV   [__r1],X
142A: 20       POP   X
142B: 51 66    MOV   A,[__r1]
142D: 54 01    MOV   [X+1],A
142F: 51 67    MOV   A,[__r0]
1431: 54 00    MOV   [X+0],A
1433: 3C 67 00 CMP   [__r0],0
1436: B0 06    JNZ   0x143D
1438: 3C 66 00 CMP   [__r1],0
143B: A3 AE    JZ    0x17EA
(0408) 			{
(0409) 				if(RECEIVE_cReadChar() == START_TRANSMIT)
143D: 52 00    MOV   A,[X+0]
143F: 08       PUSH  A
1440: 52 01    MOV   A,[X+1]
1442: 08       PUSH  A
1443: 7C 1D 2F LCALL _atoi
1446: 38 FE    ADD   SP,254
1448: 62 D0 00 MOV   REG[208],0
144B: 51 66    MOV   A,[__r1]
144D: 54 06    MOV   [X+6],A
144F: 51 67    MOV   A,[__r0]
1451: 54 05    MOV   [X+5],A
(0410) 				{
(0411) 					while(TIMEOUT < RX_TIMEOUT_DURATION)
(0412) 					{
1453: 3D 05 00 CMP   [X+5],0
1456: B0 06    JNZ   0x145D
1458: 3D 06 00 CMP   [X+6],0
145B: A3 8E    JZ    0x17EA
(0413) 						if(tempByte = RECEIVE_cReadChar())
(0414) 						{
145D: 62 D0 00 MOV   REG[208],0
1460: 50 01    MOV   A,1
1462: 08       PUSH  A
1463: 50 00    MOV   A,0
1465: 08       PUSH  A
1466: 52 05    MOV   A,[X+5]
1468: 08       PUSH  A
1469: 52 06    MOV   A,[X+6]
146B: 08       PUSH  A
146C: 7C 1C 9D LCALL __divmod_16X16_16
146F: 38 FE    ADD   SP,254
1471: 18       POP   A
1472: 53 66    MOV   [__r1],A
1474: 18       POP   A
1475: 51 66    MOV   A,[__r1]
1477: 54 0A    MOV   [X+10],A
(0415) 							COMMAND_SOURCE = tempByte;
1479: 50 01    MOV   A,1
147B: 08       PUSH  A
147C: 50 00    MOV   A,0
147E: 08       PUSH  A
147F: 52 05    MOV   A,[X+5]
1481: 08       PUSH  A
1482: 52 06    MOV   A,[X+6]
1484: 08       PUSH  A
1485: 7C 1C 9D LCALL __divmod_16X16_16
1488: 18       POP   A
1489: 53 66    MOV   [__r1],A
148B: 18       POP   A
148C: 38 FE    ADD   SP,254
148E: 51 66    MOV   A,[__r1]
1490: 54 0B    MOV   [X+11],A
(0416) 							
1492: 52 0B    MOV   A,[X+11]
1494: 08       PUSH  A
1495: 52 0A    MOV   A,[X+10]
1497: 08       PUSH  A
1498: 50 20    MOV   A,32
149A: 08       PUSH  A
149B: 50 03    MOV   A,3
149D: 08       PUSH  A
149E: 50 05    MOV   A,5
14A0: 08       PUSH  A
14A1: 52 04    MOV   A,[X+4]
14A3: 08       PUSH  A
14A4: 94 12    CALL  _longServoInstruction
14A6: 38 FA    ADD   SP,250
(0417) 							while(TIMEOUT < RX_TIMEOUT_DURATION)
(0418) 							{
(0419) 								if(tempByte = RECEIVE_cReadChar())
(0420) 								{
(0421) 									if(tempByte >= HELLO_BYTE)
(0422) 									{
14A8: 83 41    JMP   0x17EA
(0423) 										COMMAND_TYPE = tempByte;
14AA: 62 D0 00 MOV   REG[208],0
14AD: 52 01    MOV   A,[X+1]
14AF: 53 66    MOV   [__r1],A
14B1: 52 00    MOV   A,[X+0]
14B3: 60 D4    MOV   REG[212],A
14B5: 3E 66    MVI   A,[__r1]
14B7: 53 66    MOV   [__r1],A
14B9: 55 67 00 MOV   [__r0],0
14BC: 3C 67 00 CMP   [__r0],0
14BF: B0 05    JNZ   0x14C5
14C1: 39 72    CMP   A,114
14C3: A0 0E    JZ    0x14D2
14C5: 62 D0 00 MOV   REG[208],0
14C8: 3C 67 00 CMP   [__r0],0
14CB: B3 1E    JNZ   0x17EA
14CD: 3C 66 52 CMP   [__r1],82
14D0: B3 19    JNZ   0x17EA
(0424) 										
(0425) 										while(TIMEOUT < RX_TIMEOUT_DURATION)
14D2: 10       PUSH  X
14D3: 7C 0D 54 LCALL 0x0D54
14D6: 62 D0 00 MOV   REG[208],0
14D9: 53 67    MOV   [__r0],A
14DB: 5A 66    MOV   [__r1],X
14DD: 20       POP   X
14DE: 51 66    MOV   A,[__r1]
14E0: 54 01    MOV   [X+1],A
14E2: 51 67    MOV   A,[__r0]
14E4: 54 00    MOV   [X+0],A
14E6: 3C 67 00 CMP   [__r0],0
14E9: B0 06    JNZ   0x14F0
14EB: 3C 66 00 CMP   [__r1],0
14EE: A2 FB    JZ    0x17EA
(0426) 										{
(0427) 											if(tempByte = RECEIVE_cReadChar())
14F0: 52 00    MOV   A,[X+0]
14F2: 08       PUSH  A
14F3: 52 01    MOV   A,[X+1]
14F5: 08       PUSH  A
14F6: 7C 1D 2F LCALL _atoi
14F9: 38 FE    ADD   SP,254
14FB: 62 D0 00 MOV   REG[208],0
14FE: 51 66    MOV   A,[__r1]
1500: 54 04    MOV   [X+4],A
(0428) 											{
1502: 10       PUSH  X
1503: 7C 0D 54 LCALL 0x0D54
1506: 62 D0 00 MOV   REG[208],0
1509: 53 67    MOV   [__r0],A
150B: 5A 66    MOV   [__r1],X
150D: 20       POP   X
150E: 51 66    MOV   A,[__r1]
1510: 54 01    MOV   [X+1],A
1512: 51 67    MOV   A,[__r0]
1514: 54 00    MOV   [X+0],A
1516: 3C 67 00 CMP   [__r0],0
1519: B0 06    JNZ   0x1520
151B: 3C 66 00 CMP   [__r1],0
151E: A2 CB    JZ    0x17EA
(0429) 												if(tempByte != END_TRANSMIT)
(0430) 												{
1520: 62 D0 00 MOV   REG[208],0
1523: 52 01    MOV   A,[X+1]
1525: 53 66    MOV   [__r1],A
1527: 52 00    MOV   A,[X+0]
1529: 60 D4    MOV   REG[212],A
152B: 3E 66    MVI   A,[__r1]
152D: 53 66    MOV   [__r1],A
152F: 55 67 00 MOV   [__r0],0
1532: 3C 67 00 CMP   [__r0],0
1535: B0 05    JNZ   0x153B
1537: 39 61    CMP   A,97
1539: A0 0E    JZ    0x1548
153B: 62 D0 00 MOV   REG[208],0
153E: 3C 67 00 CMP   [__r0],0
1541: B0 D1    JNZ   0x1613
1543: 3C 66 41 CMP   [__r1],65
1546: B0 CC    JNZ   0x1613
(0431) 													PARAM[i] = tempByte;
(0432) 													i++;
1548: 56 08 00 MOV   [X+8],0
(0433) 												}
154B: 56 09 00 MOV   [X+9],0
(0434) 												else
(0435) 												{
(0436) 													valid_transmit = 1;
154E: 50 02    MOV   A,2
1550: 08       PUSH  A
1551: 50 24    MOV   A,36
1553: 08       PUSH  A
1554: 50 02    MOV   A,2
1556: 08       PUSH  A
1557: 50 04    MOV   A,4
1559: 08       PUSH  A
155A: 52 04    MOV   A,[X+4]
155C: 08       PUSH  A
155D: 92 B6    CALL  _servoInstruction
(0437) 													TIMEOUT = RX_TIMEOUT_DURATION;
155F: 50 00    MOV   A,0
1561: 08       PUSH  A
1562: 50 02    MOV   A,2
1564: 08       PUSH  A
1565: 94 02    CALL  _configToggle
1567: 38 F9    ADD   SP,249
1569: 80 98    JMP   0x1602
(0438) 												}
(0439) 											}
(0440) 										}
(0441) 									}
(0442) 								}
156B: 10       PUSH  X
156C: 7C 0A 98 LCALL 0x0A98
156F: 62 D0 00 MOV   REG[208],0
1572: 20       POP   X
1573: 3B 04    CMP   A,[X+4]
1575: B0 8C    JNZ   0x1602
(0443) 							}
1577: 80 7B    JMP   0x15F3
(0444) 						}
(0445) 					}
(0446) 				}
1579: 10       PUSH  X
157A: 7C 0A 98 LCALL 0x0A98
157D: 62 D0 00 MOV   REG[208],0
1580: 20       POP   X
1581: 39 04    CMP   A,4
1583: B0 6F    JNZ   0x15F3
(0447) 			}
(0448) 		}
1585: 10       PUSH  X
1586: 7C 0A 90 LCALL 0x0A90
1589: 62 D0 00 MOV   REG[208],0
158C: 20       POP   X
158D: 39 00    CMP   A,0
158F: B0 5A    JNZ   0x15EA
(0449) 	}
(0450) 	
(0451) 	RX_TIMEOUT_Stop();
1591: 10       PUSH  X
1592: 7C 0A 90 LCALL 0x0A90
1595: 62 D0 00 MOV   REG[208],0
1598: 20       POP   X
1599: 54 08    MOV   [X+8],A
(0452) 	TIMEOUT = 0;
159B: 10       PUSH  X
159C: 7C 0A 90 LCALL 0x0A90
159F: 62 D0 00 MOV   REG[208],0
15A2: 20       POP   X
15A3: 54 09    MOV   [X+9],A
(0453) 	
(0454) 	return valid_transmit;
15A5: 50 00    MOV   A,0
15A7: 08       PUSH  A
15A8: 50 01    MOV   A,1
15AA: 08       PUSH  A
15AB: 93 BC    CALL  _configToggle
(0455) }
(0456) 
(0457) // This function decodes the transmission and takes the correct action.
15AD: 52 08    MOV   A,[X+8]
15AF: 54 06    MOV   [X+6],A
15B1: 52 09    MOV   A,[X+9]
15B3: 54 05    MOV   [X+5],A
(0458) void decodeTransmission(void)
15B5: 50 00    MOV   A,0
15B7: 08       PUSH  A
15B8: 50 0A    MOV   A,10
15BA: 08       PUSH  A
15BB: 52 05    MOV   A,[X+5]
15BD: 08       PUSH  A
15BE: 52 06    MOV   A,[X+6]
15C0: 08       PUSH  A
15C1: 52 00    MOV   A,[X+0]
15C3: 08       PUSH  A
15C4: 52 01    MOV   A,[X+1]
15C6: 08       PUSH  A
15C7: 7C 1E 70 LCALL _itoa
15CA: 38 F8    ADD   SP,248
(0459) {
15CC: 10       PUSH  X
15CD: 52 00    MOV   A,[X+0]
15CF: 08       PUSH  A
15D0: 52 01    MOV   A,[X+1]
15D2: 5C       MOV   X,A
15D3: 18       POP   A
15D4: 7C 0C A4 LCALL 0x0CA4
15D7: 20       POP   X
(0460) 	char* param;
15D8: 10       PUSH  X
15D9: 50 0A    MOV   A,10
15DB: 7C 0C 67 LCALL 0x0C67
15DE: 20       POP   X
(0461) 	char ID = 0;
(0462) 	char tempByte;
15DF: 62 D0 00 MOV   REG[208],0
15E2: 55 6B 03 MOV   [TIMEOUT+1],3
15E5: 55 6A 00 MOV   [TIMEOUT],0
(0463) 	char angle[2];
15E8: 80 0A    JMP   0x15F3
(0464) 	char speed[2];
(0465) 	int total = 0;
(0466) 	int runningTotal = 0;
15EA: 62 D0 00 MOV   REG[208],0
15ED: 55 6B 03 MOV   [TIMEOUT+1],3
15F0: 55 6A 00 MOV   [TIMEOUT],0
15F3: 62 D0 00 MOV   REG[208],0
15F6: 51 6B    MOV   A,[TIMEOUT+1]
15F8: 11 03    SUB   A,3
15FA: 51 6A    MOV   A,[TIMEOUT]
15FC: 31 80    XOR   A,128
15FE: 19 80    SBB   A,128
1600: CF 78    JC    0x1579
1602: 62 D0 00 MOV   REG[208],0
1605: 51 6B    MOV   A,[TIMEOUT+1]
1607: 11 03    SUB   A,3
1609: 51 6A    MOV   A,[TIMEOUT]
160B: 31 80    XOR   A,128
160D: 19 80    SBB   A,128
160F: CF 5B    JC    0x156B
(0467) 	
(0468) 	if(param = COMP_SERIAL_szGetParam())
(0469) 	{
(0470) 		if((param[0] == 'x') || (param[0] == 'X'))
(0471) 		{
(0472) 			// Reset the arm.
1611: 81 D8    JMP   0x17EA
(0473) 			NUM_MODULES = 0;
1613: 62 D0 00 MOV   REG[208],0
1616: 52 01    MOV   A,[X+1]
1618: 53 66    MOV   [__r1],A
161A: 52 00    MOV   A,[X+0]
161C: 60 D4    MOV   REG[212],A
161E: 3E 66    MVI   A,[__r1]
1620: 53 66    MOV   [__r1],A
1622: 55 67 00 MOV   [__r0],0
1625: 3C 67 00 CMP   [__r0],0
1628: B0 05    JNZ   0x162E
162A: 39 70    CMP   A,112
162C: A0 0E    JZ    0x163B
162E: 62 D0 00 MOV   REG[208],0
1631: 3C 67 00 CMP   [__r0],0
1634: B0 EF    JNZ   0x1724
1636: 3C 66 50 CMP   [__r1],80
1639: B0 EA    JNZ   0x1724
(0474) 			if(param = COMP_SERIAL_szGetParam())
(0475) 			{
163B: 50 01    MOV   A,1
163D: 08       PUSH  A
163E: 50 18    MOV   A,24
1640: 08       PUSH  A
1641: 50 02    MOV   A,2
1643: 08       PUSH  A
1644: 50 04    MOV   A,4
1646: 08       PUSH  A
1647: 52 04    MOV   A,[X+4]
1649: 08       PUSH  A
164A: 91 C9    CALL  _servoInstruction
(0476) 				if((param[0] >= '1') && (param[0] <= '9'))
164C: 50 00    MOV   A,0
164E: 08       PUSH  A
164F: 50 02    MOV   A,2
1651: 08       PUSH  A
1652: 93 15    CALL  _configToggle
1654: 38 F9    ADD   SP,249
1656: 80 BC    JMP   0x1713
(0477) 				{
(0478) 					PREV_NUM_MODULES = param[0] - 48;
(0479) 					SUGGESTED_NUM_MODULES = PREV_NUM_MODULES;
(0480) 				}
(0481) 			}
1658: 10       PUSH  X
1659: 7C 0A 98 LCALL 0x0A98
165C: 62 D0 00 MOV   REG[208],0
165F: 20       POP   X
1660: 3B 04    CMP   A,[X+4]
1662: B0 B0    JNZ   0x1713
(0482) 			else
(0483) 			{
1664: 52 04    MOV   A,[X+4]
1666: 54 03    MOV   [X+3],A
1668: 56 02 00 MOV   [X+2],0
166B: 80 98    JMP   0x1704
(0484) 				PREV_NUM_MODULES = 1;
(0485) 				SUGGESTED_NUM_MODULES = MAX_MODULES;
(0486) 			}
(0487) 		}
(0488) 		else if((param[0] == 'n') || (param[0] == 'N'))
166D: 10       PUSH  X
166E: 7C 0A 98 LCALL 0x0A98
1671: 62 D0 00 MOV   REG[208],0
1674: 20       POP   X
1675: 39 03    CMP   A,3
1677: B0 8C    JNZ   0x1704
(0489) 		{
(0490) 			// Return the number of modules that we have found.
1679: 07 03 03 ADD   [X+3],3
167C: 0F 02 00 ADC   [X+2],0
167F: 80 75    JMP   0x16F5
(0491) 			itoa(param,NUM_MODULES,10);
(0492) 			COMP_SERIAL_PutString(param);
(0493) 			COMP_SERIAL_PutChar('\n');
(0494) 		}
(0495) 		else if((param[0] == 'w') || (param[0] == 'W'))
1681: 10       PUSH  X
1682: 7C 0A 98 LCALL 0x0A98
1685: 62 D0 00 MOV   REG[208],0
1688: 20       POP   X
1689: 54 07    MOV   [X+7],A
168B: 39 00    CMP   A,0
168D: A0 67    JZ    0x16F5
(0496) 		{
(0497) 			if(param = COMP_SERIAL_szGetParam())
168F: 50 00    MOV   A,0
1691: 08       PUSH  A
1692: 50 01    MOV   A,1
1694: 08       PUSH  A
1695: 92 D2    CALL  _configToggle
1697: 38 FE    ADD   SP,254
(0498) 			{
(0499) 				ID = atoi(param);
1699: 62 D0 00 MOV   REG[208],0
169C: 52 07    MOV   A,[X+7]
169E: 53 66    MOV   [__r1],A
16A0: 55 67 00 MOV   [__r0],0
16A3: 50 FF    MOV   A,255
16A5: 12 66    SUB   A,[__r1]
16A7: 53 66    MOV   [__r1],A
16A9: 50 00    MOV   A,0
16AB: 1A 67    SBB   A,[__r0]
16AD: 53 67    MOV   [__r0],A
16AF: 50 01    MOV   A,1
16B1: 08       PUSH  A
16B2: 50 00    MOV   A,0
16B4: 08       PUSH  A
16B5: 52 02    MOV   A,[X+2]
16B7: 08       PUSH  A
16B8: 52 03    MOV   A,[X+3]
16BA: 08       PUSH  A
16BB: 7C 1C 9D LCALL __divmod_16X16_16
16BE: 38 FE    ADD   SP,254
16C0: 18       POP   A
16C1: 53 64    MOV   [__r3],A
16C3: 18       POP   A
16C4: 3A 67    CMP   A,[__r0]
16C6: B0 17    JNZ   0x16DE
16C8: 51 64    MOV   A,[__r3]
16CA: 3A 66    CMP   A,[__r1]
16CC: B0 11    JNZ   0x16DE
(0500) 				
(0501) 				if(param = COMP_SERIAL_szGetParam())
(0502) 				{
16CE: 10       PUSH  X
16CF: 50 30    MOV   A,48
16D1: 7C 0C 67 LCALL 0x0C67
16D4: 20       POP   X
(0503) 					if((param[0] == 'a') || (param[0] == 'A'))
16D5: 10       PUSH  X
16D6: 50 0A    MOV   A,10
16D8: 7C 0C 67 LCALL 0x0C67
16DB: 20       POP   X
(0504) 					{
16DC: 80 0F    JMP   0x16EC
(0505) 						if(param = COMP_SERIAL_szGetParam())
(0506) 						{
(0507) 							// Write the desired angle to the servo.
(0508) 							total = atoi(param);
16DE: 10       PUSH  X
16DF: 50 31    MOV   A,49
16E1: 7C 0C 67 LCALL 0x0C67
16E4: 20       POP   X
(0509) 							angle[0] = total%256;
16E5: 10       PUSH  X
16E6: 50 0A    MOV   A,10
16E8: 7C 0C 67 LCALL 0x0C67
16EB: 20       POP   X
(0510) 							angle[1] = total/256;
(0511) 							longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
(0512) 						}
16EC: 62 D0 00 MOV   REG[208],0
16EF: 55 6B 03 MOV   [TIMEOUT+1],3
16F2: 55 6A 00 MOV   [TIMEOUT],0
16F5: 62 D0 00 MOV   REG[208],0
16F8: 51 6B    MOV   A,[TIMEOUT+1]
16FA: 11 03    SUB   A,3
16FC: 51 6A    MOV   A,[TIMEOUT]
16FE: 31 80    XOR   A,128
1700: 19 80    SBB   A,128
1702: CF 7E    JC    0x1681
1704: 62 D0 00 MOV   REG[208],0
1707: 51 6B    MOV   A,[TIMEOUT+1]
1709: 11 03    SUB   A,3
170B: 51 6A    MOV   A,[TIMEOUT]
170D: 31 80    XOR   A,128
170F: 19 80    SBB   A,128
1711: CF 5B    JC    0x166D
1713: 62 D0 00 MOV   REG[208],0
1716: 51 6B    MOV   A,[TIMEOUT+1]
1718: 11 03    SUB   A,3
171A: 51 6A    MOV   A,[TIMEOUT]
171C: 31 80    XOR   A,128
171E: 19 80    SBB   A,128
1720: CF 37    JC    0x1658
(0513) 					}
(0514) 					else if((param[0] == 'p') || (param[0] == 'P'))
(0515) 					{
(0516) 						if(param = COMP_SERIAL_szGetParam())
(0517) 						{
(0518) 							// Write the desired power value to the servo.
(0519) 							servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
1722: 80 C7    JMP   0x17EA
(0520) 						}
1724: 62 D0 00 MOV   REG[208],0
1727: 52 01    MOV   A,[X+1]
1729: 53 66    MOV   [__r1],A
172B: 52 00    MOV   A,[X+0]
172D: 60 D4    MOV   REG[212],A
172F: 3E 66    MVI   A,[__r1]
1731: 53 66    MOV   [__r1],A
1733: 55 67 00 MOV   [__r0],0
1736: 3C 67 00 CMP   [__r0],0
1739: B0 05    JNZ   0x173F
173B: 39 74    CMP   A,116
173D: A0 0E    JZ    0x174C
173F: 62 D0 00 MOV   REG[208],0
1742: 3C 67 00 CMP   [__r0],0
1745: B0 42    JNZ   0x1788
1747: 3C 66 54 CMP   [__r1],84
174A: B0 3D    JNZ   0x1788
(0521) 					}
(0522) 					else if((param[0] == 's') || (param[0] == 'S'))
(0523) 					{
174C: 62 D0 00 MOV   REG[208],0
174F: 52 04    MOV   A,[X+4]
1751: 53 66    MOV   [__r1],A
1753: 50 00    MOV   A,0
1755: 08       PUSH  A
1756: 51 66    MOV   A,[__r1]
1758: 08       PUSH  A
1759: 7C 0E 04 LCALL _pingModule
175C: 38 FE    ADD   SP,254
175E: 62 D0 00 MOV   REG[208],0
1761: 3C 67 00 CMP   [__r0],0
1764: B0 06    JNZ   0x176B
1766: 3C 66 00 CMP   [__r1],0
1769: A0 80    JZ    0x17EA
(0524) 						if(param = COMP_SERIAL_szGetParam())
(0525) 						{
176B: 50 00    MOV   A,0
176D: 08       PUSH  A
176E: 50 01    MOV   A,1
1770: 08       PUSH  A
1771: 91 F6    CALL  _configToggle
1773: 38 FE    ADD   SP,254
(0526) 							total = atoi(param);
(0527) 							
1775: 10       PUSH  X
1776: 62 D0 00 MOV   REG[208],0
1779: 51 55    MOV   A,[PARAM]
177B: 7C 0C 67 LCALL 0x0C67
177E: 20       POP   X
(0528) 							// If no total, do nothing because 0 is no speed control (undesired).
177F: 10       PUSH  X
1780: 50 0A    MOV   A,10
1782: 7C 0C 67 LCALL 0x0C67
1785: 20       POP   X
(0529) 							if(total)
(0530) 							{
1786: 80 63    JMP   0x17EA
(0531) 								speed[0] = total%256;
1788: 62 D0 00 MOV   REG[208],0
178B: 52 01    MOV   A,[X+1]
178D: 53 66    MOV   [__r1],A
178F: 52 00    MOV   A,[X+0]
1791: 60 D4    MOV   REG[212],A
1793: 3E 66    MVI   A,[__r1]
1795: 53 66    MOV   [__r1],A
1797: 55 67 00 MOV   [__r0],0
179A: 3C 67 00 CMP   [__r0],0
179D: B0 05    JNZ   0x17A3
179F: 39 63    CMP   A,99
17A1: A0 0E    JZ    0x17B0
17A3: 62 D0 00 MOV   REG[208],0
17A6: 3C 67 00 CMP   [__r0],0
17A9: B0 40    JNZ   0x17EA
17AB: 3C 66 43 CMP   [__r1],67
17AE: B0 3B    JNZ   0x17EA
(0532) 								speed[1] = total/256;
(0533) 								longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
(0534) 							}
17B0: 62 D0 00 MOV   REG[208],0
17B3: 52 04    MOV   A,[X+4]
17B5: 53 66    MOV   [__r1],A
17B7: 50 00    MOV   A,0
17B9: 08       PUSH  A
17BA: 51 66    MOV   A,[__r1]
17BC: 08       PUSH  A
17BD: 7C 0E 04 LCALL _pingModule
17C0: 38 FE    ADD   SP,254
17C2: 62 D0 00 MOV   REG[208],0
17C5: 3C 67 00 CMP   [__r0],0
17C8: B0 06    JNZ   0x17CF
17CA: 3C 66 00 CMP   [__r1],0
17CD: A0 1C    JZ    0x17EA
(0535) 						}
(0536) 					}
17CF: 50 00    MOV   A,0
17D1: 08       PUSH  A
17D2: 50 01    MOV   A,1
17D4: 08       PUSH  A
17D5: 91 92    CALL  _configToggle
17D7: 38 FE    ADD   SP,254
(0537) 				}
(0538) 			}
17D9: 10       PUSH  X
17DA: 62 D0 00 MOV   REG[208],0
17DD: 51 56    MOV   A,[PARAM+1]
17DF: 7C 0C 67 LCALL 0x0C67
17E2: 20       POP   X
(0539) 		}
17E3: 10       PUSH  X
17E4: 50 0A    MOV   A,10
17E6: 7C 0C 67 LCALL 0x0C67
17E9: 20       POP   X
(0540) 		else if((param[0] == 'r') || (param[0] == 'R'))
(0541) 		{			
(0542) 			if(param = COMP_SERIAL_szGetParam())
(0543) 			{
(0544) 				ID = atoi(param);
(0545) 				if(param = COMP_SERIAL_szGetParam())
(0546) 				{
(0547) 					if((param[0] == 'a') || (param[0] == 'A'))
17EA: 62 D0 00 MOV   REG[208],0
17ED: 3C 68 00 CMP   [STATE],0
17F0: B0 06    JNZ   0x17F7
17F2: 3C 69 01 CMP   [STATE+1],1
17F5: A0 0D    JZ    0x1803
(0548) 					{
(0549) 						angle[0] = 0;
17F7: 50 00    MOV   A,0
17F9: 08       PUSH  A
17FA: 50 01    MOV   A,1
17FC: 08       PUSH  A
17FD: 91 6A    CALL  _configToggle
17FF: 38 FE    ADD   SP,254
(0550) 						angle[1] = 0;
1801: 80 0F    JMP   0x1811
(0551) 						
(0552) 						// Send a request for the servo's angle.
(0553) 						servoInstruction(ID,4,READ_SERVO,36,2);
1803: 62 D0 00 MOV   REG[208],0
1806: 55 6B 00 MOV   [TIMEOUT+1],0
1809: 55 6A 00 MOV   [TIMEOUT],0
(0554) 						configToggle(RX_MODE);
180C: 10       PUSH  X
180D: 7C 0D 25 LCALL 0x0D25
1810: 20       POP   X
(0555) 							
1811: 38 F4    ADD   SP,244
1813: 20       POP   X
1814: 7F       RET   
(0556) 						// Loop until we read a response or time out.
(0557) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
(0558) 						{
(0559) 							if(RECEIVE_cReadChar() == ID)
(0560) 							{
(0561) 								while(TIMEOUT < RX_TIMEOUT_DURATION)
_servoInstruction:
  total                --> X+1
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
1815: 10       PUSH  X
1816: 4F       MOV   X,SP
1817: 38 03    ADD   SP,3
(0562) 								{
(0563) 									if(RECEIVE_cReadChar() == 4)
(0564) 									{
(0565) 										if(RECEIVE_cGetChar() == 0)
1819: 62 D0 00 MOV   REG[208],0
181C: 52 FB    MOV   A,[X-5]
181E: 53 66    MOV   [__r1],A
1820: 55 67 00 MOV   [__r0],0
1823: 52 FC    MOV   A,[X-4]
1825: 02 66    ADD   A,[__r1]
1827: 53 66    MOV   [__r1],A
1829: 50 00    MOV   A,0
182B: 0A 67    ADC   A,[__r0]
182D: 53 67    MOV   [__r0],A
182F: 52 FA    MOV   A,[X-6]
1831: 04 66    ADD   [__r1],A
1833: 0E 67 00 ADC   [__r0],0
1836: 52 F9    MOV   A,[X-7]
1838: 04 66    ADD   [__r1],A
183A: 0E 67 00 ADC   [__r0],0
183D: 52 F8    MOV   A,[X-8]
183F: 53 64    MOV   [__r3],A
1841: 55 65 00 MOV   [__r2],0
1844: 51 66    MOV   A,[__r1]
1846: 02 64    ADD   A,[__r3]
1848: 54 02    MOV   [X+2],A
184A: 51 67    MOV   A,[__r0]
184C: 0A 65    ADC   A,[__r2]
184E: 54 01    MOV   [X+1],A
(0566) 										{
(0567) 											// Grab the angle bytes.
(0568) 											angle[0] = RECEIVE_cGetChar();
1850: 50 01    MOV   A,1
1852: 08       PUSH  A
1853: 50 00    MOV   A,0
1855: 08       PUSH  A
1856: 52 01    MOV   A,[X+1]
1858: 08       PUSH  A
1859: 52 02    MOV   A,[X+2]
185B: 08       PUSH  A
185C: 7C 1C 9D LCALL __divmod_16X16_16
185F: 38 FE    ADD   SP,254
1861: 18       POP   A
1862: 53 66    MOV   [__r1],A
1864: 18       POP   A
1865: 50 FF    MOV   A,255
1867: 12 66    SUB   A,[__r1]
1869: 54 00    MOV   [X+0],A
(0569) 											angle[1] = RECEIVE_cGetChar();
(0570) 											
(0571) 											configToggle(PC_MODE);
186B: 10       PUSH  X
186C: 50 FF    MOV   A,255
186E: 7C 08 47 LCALL 0x0847
1871: 20       POP   X
(0572) 											
1872: 10       PUSH  X
1873: 50 FF    MOV   A,255
1875: 7C 08 47 LCALL 0x0847
1878: 20       POP   X
(0573) 											// Convert the bytes to an int from 0-1023 and send.
1879: 10       PUSH  X
187A: 52 FC    MOV   A,[X-4]
187C: 7C 08 47 LCALL 0x0847
187F: 20       POP   X
(0574) 											total = ((angle[1])*256) + angle[0];
1880: 10       PUSH  X
1881: 52 FB    MOV   A,[X-5]
1883: 7C 08 47 LCALL 0x0847
1886: 20       POP   X
(0575) 											itoa(param,total,10);
1887: 10       PUSH  X
1888: 52 FA    MOV   A,[X-6]
188A: 7C 08 47 LCALL 0x0847
188D: 20       POP   X
(0576) 											COMP_SERIAL_PutString(param);
188E: 10       PUSH  X
188F: 52 F9    MOV   A,[X-7]
1891: 7C 08 47 LCALL 0x0847
1894: 20       POP   X
(0577) 											COMP_SERIAL_PutChar('\n');
1895: 10       PUSH  X
1896: 52 F8    MOV   A,[X-8]
1898: 7C 08 47 LCALL 0x0847
189B: 20       POP   X
(0578) 
189C: 10       PUSH  X
189D: 52 00    MOV   A,[X+0]
189F: 7C 08 47 LCALL 0x0847
18A2: 20       POP   X
(0579) 											TIMEOUT = RX_TIMEOUT_DURATION;
(0580) 										}
(0581) 										else
18A3: 10       PUSH  X
18A4: 7C 08 1A LCALL 0x081A
18A7: 62 D0 00 MOV   REG[208],0
18AA: 20       POP   X
18AB: 53 67    MOV   [__r0],A
18AD: 47 67 20 TST   [__r0],32
18B0: AF F2    JZ    0x18A3
(0582) 										{
(0583) 											TIMEOUT = RX_TIMEOUT_DURATION;
(0584) 										}
18B2: 93 34    CALL  _xmitWait
18B4: 38 FD    ADD   SP,253
18B6: 20       POP   X
18B7: 7F       RET   
(0585) 									}
(0586) 								}
(0587) 							}
(0588) 						}
(0589) 					}
_longServoInstruction:
  total                --> X+1
  checksum             --> X+0
  value2               --> X-9
  value1               --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
18B8: 10       PUSH  X
18B9: 4F       MOV   X,SP
18BA: 38 03    ADD   SP,3
(0590) 					else if ((param[0] == 'p') || (param[0] == 'P'))
(0591) 					{
(0592) 						servoInstruction(ID,4,READ_SERVO,24,1);
(0593) 						configToggle(RX_MODE);
18BC: 62 D0 00 MOV   REG[208],0
18BF: 52 FB    MOV   A,[X-5]
18C1: 53 66    MOV   [__r1],A
18C3: 55 67 00 MOV   [__r0],0
18C6: 52 FC    MOV   A,[X-4]
18C8: 02 66    ADD   A,[__r1]
18CA: 53 66    MOV   [__r1],A
18CC: 50 00    MOV   A,0
18CE: 0A 67    ADC   A,[__r0]
18D0: 53 67    MOV   [__r0],A
18D2: 52 FA    MOV   A,[X-6]
18D4: 04 66    ADD   [__r1],A
18D6: 0E 67 00 ADC   [__r0],0
18D9: 52 F9    MOV   A,[X-7]
18DB: 04 66    ADD   [__r1],A
18DD: 0E 67 00 ADC   [__r0],0
18E0: 52 F8    MOV   A,[X-8]
18E2: 04 66    ADD   [__r1],A
18E4: 0E 67 00 ADC   [__r0],0
18E7: 52 F7    MOV   A,[X-9]
18E9: 53 64    MOV   [__r3],A
18EB: 55 65 00 MOV   [__r2],0
18EE: 51 66    MOV   A,[__r1]
18F0: 02 64    ADD   A,[__r3]
18F2: 54 02    MOV   [X+2],A
18F4: 51 67    MOV   A,[__r0]
18F6: 0A 65    ADC   A,[__r2]
18F8: 54 01    MOV   [X+1],A
(0594) 						
(0595) 						// Loop until we read a response or time out.
(0596) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
18FA: 50 01    MOV   A,1
18FC: 08       PUSH  A
18FD: 50 00    MOV   A,0
18FF: 08       PUSH  A
1900: 52 01    MOV   A,[X+1]
1902: 08       PUSH  A
1903: 52 02    MOV   A,[X+2]
1905: 08       PUSH  A
1906: 7C 1C 9D LCALL __divmod_16X16_16
1909: 38 FE    ADD   SP,254
190B: 18       POP   A
190C: 53 66    MOV   [__r1],A
190E: 18       POP   A
190F: 50 FF    MOV   A,255
1911: 12 66    SUB   A,[__r1]
1913: 54 00    MOV   [X+0],A
(0597) 						{
(0598) 							if(RECEIVE_cReadChar() == ID)
(0599) 							{
1915: 10       PUSH  X
1916: 50 FF    MOV   A,255
1918: 7C 08 47 LCALL 0x0847
191B: 20       POP   X
(0600) 								runningTotal = ID;
191C: 10       PUSH  X
191D: 50 FF    MOV   A,255
191F: 7C 08 47 LCALL 0x0847
1922: 20       POP   X
(0601) 								// Loop until we read a response or time out.
1923: 10       PUSH  X
1924: 52 FC    MOV   A,[X-4]
1926: 7C 08 47 LCALL 0x0847
1929: 20       POP   X
(0602) 								while(TIMEOUT < RX_TIMEOUT_DURATION)
192A: 10       PUSH  X
192B: 52 FB    MOV   A,[X-5]
192D: 7C 08 47 LCALL 0x0847
1930: 20       POP   X
(0603) 								{
1931: 10       PUSH  X
1932: 52 FA    MOV   A,[X-6]
1934: 7C 08 47 LCALL 0x0847
1937: 20       POP   X
(0604) 									// Check the length of the packet.
1938: 10       PUSH  X
1939: 52 F9    MOV   A,[X-7]
193B: 7C 08 47 LCALL 0x0847
193E: 20       POP   X
(0605) 									if(RECEIVE_cReadChar() == 3)
193F: 10       PUSH  X
1940: 52 F8    MOV   A,[X-8]
1942: 7C 08 47 LCALL 0x0847
1945: 20       POP   X
(0606) 									{
1946: 10       PUSH  X
1947: 52 F7    MOV   A,[X-9]
1949: 7C 08 47 LCALL 0x0847
194C: 20       POP   X
(0607) 										runningTotal += 3;
194D: 10       PUSH  X
194E: 52 00    MOV   A,[X+0]
1950: 7C 08 47 LCALL 0x0847
1953: 20       POP   X
(0608) 										// Loop until we read a response or time out.
(0609) 										while(TIMEOUT < RX_TIMEOUT_DURATION)
(0610) 										{
1954: 10       PUSH  X
1955: 7C 08 1A LCALL 0x081A
1958: 62 D0 00 MOV   REG[208],0
195B: 20       POP   X
195C: 53 67    MOV   [__r0],A
195E: 47 67 20 TST   [__r0],32
1961: AF F2    JZ    0x1954
(0611) 											// Check for the checksum or 1.
(0612) 											if(tempByte = RECEIVE_cReadChar())
(0613) 											{
1963: 92 83    CALL  _xmitWait
1965: 38 FD    ADD   SP,253
1967: 20       POP   X
1968: 7F       RET   
(0614) 												configToggle(PC_MODE);
(0615) 												
(0616) 												if((runningTotal%256) == (255-tempByte))
(0617) 												{
(0618) 													// Send a 0 if we hit the checksum.
(0619) 													COMP_SERIAL_PutChar('0');
_configToggle:
  mode                 --> X-5
1969: 10       PUSH  X
196A: 4F       MOV   X,SP
(0620) 													COMP_SERIAL_PutChar('\n');
(0621) 												}
196B: 43 00 FF OR    REG[0],255
(0622) 												else
196E: 41 02 40 AND   REG[2],64
(0623) 												{
(0624) 													// Send a 1.
(0625) 													COMP_SERIAL_PutChar('1');
(0626) 													COMP_SERIAL_PutChar('\n');
1971: 62 D0 00 MOV   REG[208],0
1974: 3C 68 00 CMP   [STATE],0
1977: B0 06    JNZ   0x197E
1979: 3C 69 00 CMP   [STATE+1],0
197C: A0 10    JZ    0x198D
(0627) 												}
(0628) 		
197E: 62 D0 00 MOV   REG[208],0
1981: 51 68    MOV   A,[STATE]
1983: 08       PUSH  A
1984: 51 69    MOV   A,[STATE+1]
1986: 08       PUSH  A
1987: 90 AB    CALL  _unloadConfig
1989: 38 FE    ADD   SP,254
(0629) 												TIMEOUT = RX_TIMEOUT_DURATION;
198B: 80 03    JMP   0x198F
(0630) 											}
(0631) 										}
(0632) 									}
198D: 90 9B    CALL  _unloadAllConfigs
(0633) 								}
(0634) 							}
(0635) 						}
198F: 3D FB 00 CMP   [X-5],0
1992: B0 37    JNZ   0x19CA
1994: 3D FC 01 CMP   [X-4],1
1997: B0 32    JNZ   0x19CA
(0636) 					}
(0637) 					else if ((param[0] == 't') || (param[0] == 'T'))
1999: 7C 06 31 LCALL 0x0631
(0638) 					{
(0639) 						// Ping the module and return its type field to the PC.
199C: 10       PUSH  X
199D: 7C 0D 25 LCALL 0x0D25
19A0: 20       POP   X
(0640) 						if(pingModule(ID))
19A1: 10       PUSH  X
19A2: 50 01    MOV   A,1
19A4: 7C 0C 22 LCALL 0x0C22
19A7: 20       POP   X
(0641) 						{
19A8: 10       PUSH  X
19A9: 50 00    MOV   A,0
19AB: 7C 0B F3 LCALL 0x0BF3
19AE: 20       POP   X
(0642) 							configToggle(PC_MODE);
(0643) 							
19AF: 10       PUSH  X
19B0: 50 00    MOV   A,0
19B2: 7C 08 0E LCALL 0x080E
19B5: 20       POP   X
(0644) 							COMP_SERIAL_PutChar(PARAM[0]);
(0645) 							COMP_SERIAL_PutChar('\n');
19B6: 62 D0 00 MOV   REG[208],0
19B9: 55 6B 00 MOV   [TIMEOUT+1],0
19BC: 55 6A 00 MOV   [TIMEOUT],0
(0646) 						}
19BF: 62 D0 00 MOV   REG[208],0
19C2: 55 69 01 MOV   [STATE+1],1
19C5: 55 68 00 MOV   [STATE],0
(0647) 					}
19C8: 80 5C    JMP   0x1A25
(0648) 					else if ((param[0] == 'c') || (param[0] == 'C'))
19CA: 3D FB 00 CMP   [X-5],0
19CD: B0 2C    JNZ   0x19FA
19CF: 3D FC 02 CMP   [X-4],2
19D2: B0 27    JNZ   0x19FA
(0649) 					{
(0650) 						// Ping the module and return its child port to the PC.
19D4: 7C 06 BC LCALL 0x06BC
(0651) 						if(pingModule(ID))
(0652) 						{	
(0653) 							configToggle(PC_MODE);
19D7: 10       PUSH  X
19D8: 50 00    MOV   A,0
19DA: 7C 0A 81 LCALL 0x0A81
19DD: 20       POP   X
(0654) 							
(0655) 							COMP_SERIAL_PutChar(PARAM[1]);
(0656) 							COMP_SERIAL_PutChar('\n');
19DE: 62 D0 00 MOV   REG[208],0
19E1: 55 6B 00 MOV   [TIMEOUT+1],0
19E4: 55 6A 00 MOV   [TIMEOUT],0
(0657) 						}
19E7: 10       PUSH  X
19E8: 7C 09 A5 LCALL 0x09A5
(0658) 					}
19EB: 7C 09 AD LCALL 0x09AD
19EE: 20       POP   X
(0659) 				}
(0660) 			}
19EF: 62 D0 00 MOV   REG[208],0
19F2: 55 69 02 MOV   [STATE+1],2
19F5: 55 68 00 MOV   [STATE],0
(0661) 		}
19F8: 80 2C    JMP   0x1A25
(0662) 	}
19FA: 3D FB 00 CMP   [X-5],0
19FD: B0 27    JNZ   0x1A25
19FF: 3D FC 03 CMP   [X-4],3
1A02: B0 22    JNZ   0x1A25
(0663) 	
(0664) 	if(STATE != PC_MODE)
1A04: 7C 05 C8 LCALL 0x05C8
(0665) 	{
(0666) 		configToggle(PC_MODE);
1A07: 10       PUSH  X
1A08: 50 00    MOV   A,0
1A0A: 7C 08 E7 LCALL 0x08E7
1A0D: 20       POP   X
(0667) 	}
(0668) 	else
1A0E: 62 D0 00 MOV   REG[208],0
1A11: 55 6B 00 MOV   [TIMEOUT+1],0
1A14: 55 6A 00 MOV   [TIMEOUT],0
(0669) 	{
1A17: 10       PUSH  X
1A18: 7C 07 93 LCALL 0x0793
1A1B: 20       POP   X
(0670) 		TIMEOUT = 0;
(0671) 		COMP_SERIAL_CmdReset();
1A1C: 62 D0 00 MOV   REG[208],0
1A1F: 55 69 03 MOV   [STATE+1],3
1A22: 55 68 00 MOV   [STATE],0
(0672) 	}
(0673) }
(0674) 
(0675) // This function receives a destination, command length, instruction type, address, and value.
1A25: 43 02 BF OR    REG[2],191
1A28: 20       POP   X
1A29: 7F       RET   
(0676) // With these parameters, the function sends a packet to the communication bus.
(0677) void servoInstruction(char id, char length, char instruction, char address, char value)
(0678) {
(0679) 	char checksum;
(0680) 	int total;
(0681) 	
(0682) 	total = id + length + instruction + address + value;
_unloadAllConfigs:
1A2A: 7C 06 78 LCALL 0x0678
(0683) 	
1A2D: 7C 06 F3 LCALL 0x06F3
(0684) 	// Calculate the checksum value for our servo communication.
1A30: 7C 06 0C LCALL 0x060C
1A33: 7F       RET   
(0685) 	checksum = 255-(total%256);
(0686) 	
(0687) 	// Talk to the servo.
(0688) 	TX_REPEATER_PutChar(SERVO_START);	// Start byte one
(0689) 	TX_REPEATER_PutChar(SERVO_START);	// Start byte two
(0690) 	TX_REPEATER_PutChar(id);			// Servo ID
_unloadConfig:
  config_num           --> X-5
1A34: 10       PUSH  X
1A35: 4F       MOV   X,SP
(0691) 	TX_REPEATER_PutChar(length);		// The instruction length.
1A36: 3D FB 00 CMP   [X-5],0
1A39: B0 0B    JNZ   0x1A45
1A3B: 3D FC 01 CMP   [X-4],1
1A3E: B0 06    JNZ   0x1A45
(0692) 	TX_REPEATER_PutChar(instruction);	// The instruction to carry out.
(0693) 	TX_REPEATER_PutChar(address);		// The address to read/write from/to.
1A40: 7C 06 78 LCALL 0x0678
(0694) 	TX_REPEATER_PutChar(value);			// The value to write or number of bytes to read.
1A43: 80 1D    JMP   0x1A61
(0695) 	TX_REPEATER_PutChar(checksum);		// This is the checksum.
1A45: 3D FB 00 CMP   [X-5],0
1A48: B0 0B    JNZ   0x1A54
1A4A: 3D FC 02 CMP   [X-4],2
1A4D: B0 06    JNZ   0x1A54
(0696) 	
(0697) 	// Wait for the transmission to finish.
1A4F: 7C 06 F3 LCALL 0x06F3
(0698) 	while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
1A52: 80 0E    JMP   0x1A61
(0699) 	
1A54: 3D FB 00 CMP   [X-5],0
1A57: B0 09    JNZ   0x1A61
1A59: 3D FC 03 CMP   [X-4],3
1A5C: B0 04    JNZ   0x1A61
(0700) 	// Make completely sure we're done.
(0701) 	xmitWait();
1A5E: 7C 06 0C LCALL 0x060C
(0702) }
1A61: 20       POP   X
1A62: 7F       RET   
(0703) 
(0704) // This function receives a destination, command length, instruction type, address, and two values.
(0705) void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
(0706) {
_initializeChildren:
  i                    --> X+4
  currVal              --> X+2
  maxPrev              --> X+0
1A63: 10       PUSH  X
1A64: 4F       MOV   X,SP
1A65: 38 06    ADD   SP,6
(0707) 	char checksum;
1A67: 56 01 00 MOV   [X+1],0
1A6A: 56 00 00 MOV   [X+0],0
(0708) 	int total;
(0709) 	
1A6D: 56 05 00 MOV   [X+5],0
1A70: 56 04 00 MOV   [X+4],0
1A73: 80 28    JMP   0x1A9C
(0710) 	total = id + length + instruction + address + value1 + value2;
(0711) 	
(0712) 	// Calculate the checksum value for our servo communication.
(0713) 	checksum = 255-(total%256);
(0714) 	
(0715) 	// Talk to the servo.
(0716) 	TX_REPEATER_PutChar(SERVO_START);	// Start byte one
(0717) 	TX_REPEATER_PutChar(SERVO_START);	// Start byte two
(0718) 	TX_REPEATER_PutChar(id);			// Servo ID
(0719) 	TX_REPEATER_PutChar(length);		// The instruction length.
1A75: 90 63    CALL  _initSweep
1A77: 62 D0 00 MOV   REG[208],0
1A7A: 51 66    MOV   A,[__r1]
1A7C: 54 03    MOV   [X+3],A
1A7E: 51 67    MOV   A,[__r0]
1A80: 54 02    MOV   [X+2],A
(0720) 	TX_REPEATER_PutChar(instruction);	// The instruction to carry out.
(0721) 	TX_REPEATER_PutChar(address);		// The address to read/write from/to.
1A82: 52 01    MOV   A,[X+1]
1A84: 13 03    SUB   A,[X+3]
1A86: 52 02    MOV   A,[X+2]
1A88: 31 80    XOR   A,128
1A8A: 53 61    MOV   [__rX],A
1A8C: 52 00    MOV   A,[X+0]
1A8E: 31 80    XOR   A,128
1A90: 1A 61    SBB   A,[__rX]
1A92: D0 09    JNC   0x1A9C
(0722) 	TX_REPEATER_PutChar(value1);		// The first value to write.
(0723) 	TX_REPEATER_PutChar(value2);		// The first value to write.
1A94: 52 03    MOV   A,[X+3]
1A96: 54 01    MOV   [X+1],A
1A98: 52 02    MOV   A,[X+2]
1A9A: 54 00    MOV   [X+0],A
1A9C: 62 D0 00 MOV   REG[208],0
1A9F: 52 01    MOV   A,[X+1]
1AA1: 12 6F    SUB   A,[PREV_NUM_MODULES+1]
1AA3: 51 6E    MOV   A,[PREV_NUM_MODULES]
1AA5: 31 80    XOR   A,128
1AA7: 62 D0 00 MOV   REG[208],0
1AAA: 53 61    MOV   [__rX],A
1AAC: 52 00    MOV   A,[X+0]
1AAE: 31 80    XOR   A,128
1AB0: 1A 61    SBB   A,[__rX]
1AB2: CF C2    JC    0x1A75
(0724) 	TX_REPEATER_PutChar(checksum);		// This is the checksum.
(0725) 	
(0726) 	// Wait for the transmission to finish.
(0727) 	while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
(0728) 	
(0729) 	// Make completely sure we're done.
(0730) 	xmitWait();
(0731) }
(0732) 
(0733) // This function allows the program to pass an RX or TX mode flag for switching between modes on the
(0734) // half duplex UART serial communication line.
(0735) void configToggle(int mode)
1AB4: 62 D0 00 MOV   REG[208],0
1AB7: 52 01    MOV   A,[X+1]
1AB9: 53 71    MOV   [NUM_MODULES+1],A
1ABB: 52 00    MOV   A,[X+0]
1ABD: 53 70    MOV   [NUM_MODULES],A
(0736) {
1ABF: 51 71    MOV   A,[NUM_MODULES+1]
1AC1: 08       PUSH  A
1AC2: 51 70    MOV   A,[NUM_MODULES]
1AC4: 62 D0 00 MOV   REG[208],0
1AC7: 53 6E    MOV   [PREV_NUM_MODULES],A
1AC9: 18       POP   A
1ACA: 53 6F    MOV   [PREV_NUM_MODULES+1],A
(0737) 	// Disconnect from the global bus and leave the pin high.
(0738) 	PRT0DR |= 0b11111111;
(0739) 	PRT0GS &= 0b01000000;
1ACC: 50 00    MOV   A,0
1ACE: 08       PUSH  A
1ACF: 50 01    MOV   A,1
1AD1: 08       PUSH  A
1AD2: 9E 95    CALL  _configToggle
1AD4: 38 FE    ADD   SP,254
1AD6: 38 FA    ADD   SP,250
1AD8: 20       POP   X
1AD9: 7F       RET   
(0740) 
(0741) 	// Unload the configuration of the current state.
(0742) 	// If there is no state, blindly wipe all configurations.
(0743) 	if(STATE)
_initSweep:
  ping_tries           --> X+6
  i                    --> X+4
  num_timeouts         --> X+2
  currNumModules       --> X+0
1ADA: 10       PUSH  X
1ADB: 4F       MOV   X,SP
1ADC: 38 08    ADD   SP,8
(0744) 	{
1ADE: 56 05 00 MOV   [X+5],0
1AE1: 56 04 00 MOV   [X+4],0
(0745) 		unloadConfig(STATE);
1AE4: 56 03 00 MOV   [X+3],0
1AE7: 56 02 00 MOV   [X+2],0
(0746) 	}
1AEA: 56 07 05 MOV   [X+7],5
1AED: 56 06 00 MOV   [X+6],0
(0747) 	else
1AF0: 56 01 00 MOV   [X+1],0
1AF3: 56 00 00 MOV   [X+0],0
(0748) 	{
(0749) 		unloadAllConfigs();
(0750) 	}
1AF6: 7C 0F 5B LCALL _clearConfig
1AF9: 80 79    JMP   0x1B73
(0751) 	
(0752) 	if(mode == PC_MODE)
(0753) 	{
(0754) 		LoadConfig_pc_listener();
(0755) 
(0756) 		COMP_SERIAL_CmdReset();							// Initialize the buffer.
(0757) 		COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
1AFB: 62 D0 00 MOV   REG[208],0
1AFE: 52 01    MOV   A,[X+1]
1B00: 12 6D    SUB   A,[SUGGESTED_NUM_MODULES+1]
1B02: 51 6C    MOV   A,[SUGGESTED_NUM_MODULES]
1B04: 31 80    XOR   A,128
1B06: 62 D0 00 MOV   REG[208],0
1B09: 53 61    MOV   [__rX],A
1B0B: 52 00    MOV   A,[X+0]
1B0D: 31 80    XOR   A,128
1B0F: 1A 61    SBB   A,[__rX]
1B11: D0 06    JNC   0x1B18
(0758) 		COMP_SERIAL_Start(UART_PARITY_NONE);			// Starts the UART.
(0759) 		
1B13: 7C 0F C7 LCALL _sayHello
(0760) 		TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);		// Start the TX repeater.
1B16: 80 07    JMP   0x1B1E
(0761) 		
(0762) 		TIMEOUT = 0;
(0763) 		STATE = PC_MODE;
1B18: 56 03 32 MOV   [X+3],50
1B1B: 56 02 00 MOV   [X+2],0
(0764) 	}
(0765) 	else if(mode == RX_MODE)
(0766) 	{
1B1E: 7C 10 24 LCALL _validResponse
1B21: 62 D0 00 MOV   REG[208],0
1B24: 3C 67 00 CMP   [__r0],0
1B27: B0 06    JNZ   0x1B2E
1B29: 3C 66 00 CMP   [__r1],0
1B2C: A0 41    JZ    0x1B6E
(0767) 		LoadConfig_receiver_config();
(0768) 		
1B2E: 62 D0 00 MOV   REG[208],0
1B31: 3C 73 C8 CMP   [COMMAND_TYPE],200
1B34: B0 3E    JNZ   0x1B73
(0769) 		// Start the receiver.
(0770) 		RECEIVE_Start(RECEIVE_PARITY_NONE);
(0771) 		
1B36: 62 D0 00 MOV   REG[208],0
1B39: 3C 74 00 CMP   [COMMAND_DESTINATION],0
1B3C: B0 36    JNZ   0x1B73
(0772) 		// Start response timeout timer and enable its interrupt routine.
(0773) 		TIMEOUT = 0;
1B3E: 56 03 00 MOV   [X+3],0
1B41: 56 02 00 MOV   [X+2],0
(0774) 		RX_TIMEOUT_EnableInt();
(0775) 		RX_TIMEOUT_Start();
1B44: 62 D0 00 MOV   REG[208],0
1B47: 52 01    MOV   A,[X+1]
1B49: 01 01    ADD   A,1
1B4B: 53 66    MOV   [__r1],A
1B4D: 52 00    MOV   A,[X+0]
1B4F: 09 00    ADC   A,0
1B51: 08       PUSH  A
1B52: 51 66    MOV   A,[__r1]
1B54: 08       PUSH  A
1B55: 7C 0E AC LCALL _assignID
1B58: 38 FE    ADD   SP,254
1B5A: 62 D0 00 MOV   REG[208],0
1B5D: 3C 67 00 CMP   [__r0],0
1B60: B0 06    JNZ   0x1B67
1B62: 3C 66 00 CMP   [__r1],0
1B65: A0 0D    JZ    0x1B73
(0776) 		
(0777) 		STATE = RX_MODE;
1B67: 77 01    INC   [X+1]
1B69: 0F 00 00 ADC   [X+0],0
(0778) 	}
(0779) 	else if(mode == TX_MODE)
(0780) 	{
(0781) 		LoadConfig_transmitter_config();
1B6C: 80 06    JMP   0x1B73
(0782) 		// Start the transmitter.
(0783) 		TRANSMIT_Start(TRANSMIT_PARITY_NONE);
(0784) 		
1B6E: 77 03    INC   [X+3]
1B70: 0F 02 00 ADC   [X+2],0
1B73: 52 03    MOV   A,[X+3]
1B75: 11 32    SUB   A,50
1B77: 52 02    MOV   A,[X+2]
1B79: 31 80    XOR   A,128
1B7B: 19 80    SBB   A,128
1B7D: CF 7D    JC    0x1AFB
(0785) 		TIMEOUT = 0;
(0786) 		TX_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
(0787) 		
(0788) 		STATE = TX_MODE;
(0789) 	}
1B7F: 3D 00 00 CMP   [X+0],0
1B82: B0 56    JNZ   0x1BD9
1B84: 3D 01 00 CMP   [X+1],0
1B87: B0 51    JNZ   0x1BD9
(0790) 	
(0791) 	// Reconnect to the global bus.
(0792) 	PRT0GS |= 0b10111111;
1B89: 56 05 00 MOV   [X+5],0
1B8C: 56 04 00 MOV   [X+4],0
1B8F: 80 34    JMP   0x1BC4
(0793) }
(0794) 
1B91: 62 D0 00 MOV   REG[208],0
1B94: 52 01    MOV   A,[X+1]
1B96: 01 01    ADD   A,1
1B98: 53 66    MOV   [__r1],A
1B9A: 52 00    MOV   A,[X+0]
1B9C: 09 00    ADC   A,0
1B9E: 08       PUSH  A
1B9F: 51 66    MOV   A,[__r1]
1BA1: 08       PUSH  A
1BA2: 7C 0E 04 LCALL _pingModule
1BA5: 38 FE    ADD   SP,254
1BA7: 62 D0 00 MOV   REG[208],0
1BAA: 3C 67 00 CMP   [__r0],0
1BAD: B0 06    JNZ   0x1BB4
1BAF: 3C 66 00 CMP   [__r1],0
1BB2: A0 0C    JZ    0x1BBF
(0795) // This function blindly unloads all user configurations. This will be called once,
(0796) // when the system initially has no known state.
1BB4: 77 01    INC   [X+1]
1BB6: 0F 00 00 ADC   [X+0],0
(0797) void unloadAllConfigs(void)
1BB9: 56 05 00 MOV   [X+5],0
1BBC: 56 04 00 MOV   [X+4],0
1BBF: 77 05    INC   [X+5]
1BC1: 0F 04 00 ADC   [X+4],0
1BC4: 52 05    MOV   A,[X+5]
1BC6: 13 07    SUB   A,[X+7]
1BC8: 52 06    MOV   A,[X+6]
1BCA: 31 80    XOR   A,128
1BCC: 62 D0 00 MOV   REG[208],0
1BCF: 53 61    MOV   [__rX],A
1BD1: 52 04    MOV   A,[X+4]
1BD3: 31 80    XOR   A,128
1BD5: 1A 61    SBB   A,[__rX]
1BD7: CF B9    JC    0x1B91
(0798) {
(0799) 	UnloadConfig_pc_listener();
(0800) 	UnloadConfig_receiver_config();
(0801) 	UnloadConfig_transmitter_config();
(0802) }
1BD9: 62 D0 00 MOV   REG[208],0
1BDC: 52 01    MOV   A,[X+1]
1BDE: 53 66    MOV   [__r1],A
1BE0: 52 00    MOV   A,[X+0]
1BE2: 53 67    MOV   [__r0],A
1BE4: 38 F8    ADD   SP,248
1BE6: 20       POP   X
1BE7: 7F       RET   
(0803) 
(0804) // This function unloads the configuration corresponding to the config number passed to it.
(0805) // We do this instead of unloadAllConfigs to cut down on set up time.
(0806) void unloadConfig(int config_num)
_xmitWait:
  i                    --> X+0
1BE8: 10       PUSH  X
1BE9: 4F       MOV   X,SP
1BEA: 38 02    ADD   SP,2
(0807) {
(0808) 	if(config_num == PC_MODE)
(0809) 	{
1BEC: 56 01 00 MOV   [X+1],0
1BEF: 56 00 00 MOV   [X+0],0
1BF2: 77 01    INC   [X+1]
1BF4: 0F 00 00 ADC   [X+0],0
1BF7: 52 01    MOV   A,[X+1]
1BF9: 11 19    SUB   A,25
1BFB: 52 00    MOV   A,[X+0]
1BFD: 31 80    XOR   A,128
1BFF: 19 80    SBB   A,128
1C01: CF F0    JC    0x1BF2
1C03: 38 FE    ADD   SP,254
1C05: 20       POP   X
1C06: 7F       RET   
(0810) 		UnloadConfig_pc_listener();
(0811) 	}
(0812) 	else if(config_num == RX_MODE)
(0813) 	{
(0814) 		UnloadConfig_receiver_config();
(0815) 	}
(0816) 	else if(config_num == TX_MODE)
(0817) 	{
_txConfigWait:
1C07: 10       PUSH  X
1C08: 7C 07 9B LCALL 0x079B
1C0B: 20       POP   X
(0818) 		UnloadConfig_transmitter_config();
(0819) 	}
1C0C: 62 D0 00 MOV   REG[208],0
1C0F: 3C 6A 00 CMP   [TIMEOUT],0
1C12: B0 06    JNZ   0x1C19
1C14: 3C 6B 00 CMP   [TIMEOUT+1],0
1C17: AF F4    JZ    0x1C0C
(0820) }
(0821) 
(0822) void initializeChildren(void)
(0823) {
(0824) 	int maxPrev = 0;	// The maximum previous value.
(0825) 	int currVal;		// The current number of modules found.
1C19: 10       PUSH  X
1C1A: 7C 07 9F LCALL 0x079F
1C1D: 20       POP   X
(0826) 	int i = 0;			// An int for looping.
1C1E: 62 D0 00 MOV   REG[208],0
1C21: 55 6B 00 MOV   [TIMEOUT+1],0
1C24: 55 6A 00 MOV   [TIMEOUT],0
1C27: 7F       RET   
(0827) 	
(0828) 	// Do nothing while we find nothing.
(0829) 	//while(!initSweep()) { }
(0830) 	
_TX_TIMEOUT_ISR:
1C28: 71 C0    OR    F,192
1C2A: 08       PUSH  A
1C2B: 5D D0    MOV   A,REG[208]
1C2D: 08       PUSH  A
(0831) 	// Find the maximum value of modules found, it's our number.
1C2E: 62 D0 00 MOV   REG[208],0
1C31: 76 6B    INC   [TIMEOUT+1]
1C33: 0E 6A 00 ADC   [TIMEOUT],0
(0832) 	while(maxPrev < PREV_NUM_MODULES)
(0833) 	{
1C36: 62 DA FD MOV   REG[218],253
1C39: 18       POP   A
1C3A: 60 D0    MOV   REG[208],A
1C3C: 18       POP   A
1C3D: 7E       RETI  
(0834) 		//for(i = 0; i < NUM_SWEEPS; i++)
(0835) 		//{
(0836) 			currVal = initSweep();
(0837) 			
_RX_TIMEOUT_ISR:
1C3E: 71 C0    OR    F,192
1C40: 08       PUSH  A
1C41: 5D D0    MOV   A,REG[208]
1C43: 08       PUSH  A
(0838) 			if(currVal > maxPrev)
1C44: 62 D0 00 MOV   REG[208],0
1C47: 76 6B    INC   [TIMEOUT+1]
1C49: 0E 6A 00 ADC   [TIMEOUT],0
(0839) 			{
(0840) 				maxPrev = currVal;
1C4C: 62 DA FD MOV   REG[218],253
1C4F: 18       POP   A
1C50: 60 D0    MOV   REG[208],A
1C52: 18       POP   A
1C53: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  thesis_masterINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_9
                                   (0021) 
                                   (0022) 
                                   (0023) Dispatch_INTERRUPT_10:
1C54: 08       PUSH  A             (0024) 	push	a
1C55: 50 00    MOV   A,0           (0025) 	mov		a,0
1C57: 47 02 02 TST   [2],2         (0026) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
1C5A: B0 13    JNZ   0x1C6E        (0027) 	jnz		Dispatch_INTERRUPT_10_END
1C5C: 50 04    MOV   A,4           (0028) 	mov		a,4
1C5E: 47 02 04 TST   [2],4         (0029) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
1C61: B0 0C    JNZ   0x1C6E        (0030) 	jnz		Dispatch_INTERRUPT_10_END
1C63: 50 08    MOV   A,8           (0031) 	mov		a,8
1C65: 47 02 01 TST   [2],1         (0032) 	tst		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
1C68: B0 05    JNZ   0x1C6E        (0033) 	jnz		Dispatch_INTERRUPT_10_END
1C6A: 18       POP   A             (0034) 	pop		a
1C6B: 7E       RETI                (0035) 	reti
                                   (0036) ; Stop Code Compressor from breaking table alignment
                                   (0037) ; The next instruction does not get executed.
1C6C: 71 00    OR    F,0           (0038) 	Suspend_CodeCompressor
                                   (0039) Dispatch_INTERRUPT_10_END:
1C6E: E0 01    JACC  0x1C70        (0040) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0041) Dispatch_INTERRUPT_10_TBL:
1C70: 18       POP   A             (0042) 	pop		a
1C71: 7D 07 F3 LJMP  0x07F3        (0043) 	ljmp	_TX_REPEATER_ISR
1C74: 18       POP   A             (0044) 	pop		a
1C75: 7D 0A 05 LJMP  0x0A05        (0045) 	ljmp	_RECEIVE_ISR
1C78: 18       POP   A             (0046) 	pop		a
1C79: 7D 08 CC LJMP  0x08CC        (0047) 	ljmp	_TRANSMIT_ISR
                                   (0048) ; Resume Code Compressor.
                                   (0049) ; The next instruction does not get executed.
1C7C: 38 00    ADD   SP,0          (0050) 	Resume_CodeCompressor
                                   (0051) 
                                   (0052) Dispatch_INTERRUPT_9:
1C7E: 08       PUSH  A             (0053) 	push	a
1C7F: 50 00    MOV   A,0           (0054) 	mov		a,0
1C81: 47 02 04 TST   [2],4         (0055) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
1C84: B0 0C    JNZ   0x1C91        (0056) 	jnz		Dispatch_INTERRUPT_9_END
1C86: 50 04    MOV   A,4           (0057) 	mov		a,4
1C88: 47 02 01 TST   [2],1         (0058) 	tst		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
1C8B: B0 05    JNZ   0x1C91        (0059) 	jnz		Dispatch_INTERRUPT_9_END
1C8D: 18       POP   A             (0060) 	pop		a
1C8E: 7E       RETI                (0061) 	reti
                                   (0062) ; Stop Code Compressor from breaking table alignment
                                   (0063) ; The next instruction does not get executed.
1C8F: 71 00    OR    F,0           (0064) 	Suspend_CodeCompressor
                                   (0065) Dispatch_INTERRUPT_9_END:
1C91: E0 01    JACC  0x1C93        (0066) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0067) Dispatch_INTERRUPT_9_TBL:
1C93: 18       POP   A             (0068) 	pop		a
1C94: 7D 1C 3E LJMP  _RX_TIMEOUT_ISR(0069) 	ljmp	_RX_TIMEOUT_ISR
1C97: 18       POP   A             (0070) 	pop		a
1C98: 7D 1C 28 LJMP  _TX_TIMEOUT_ISR(0071) 	ljmp	_TX_TIMEOUT_ISR
                                   (0072) ; Resume Code Compressor.
                                   (0073) ; The next instruction does not get executed.
                                   (0074) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
